<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>安装ArchLinux教程</title>
    <url>/2020/08/24/19701/</url>
    <content><![CDATA[<h2 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h2><ol>
<li>首先前往 &gt;&gt; <a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/" target="_blank" rel="noopener">清华大学开源镜像站</a> 下载 Arch Linux 镜像，制作U盘启动盘。</li>
<li>开机进入U盘启动(UEFI引导)，进入系统后将会以 root 身份登陆进一个虚拟控制台，默认的 shell 是 zsh</li>
<li>进行联网<ul>
<li>确保系统已经启用了网络接口，用 <code>ip link</code> 命令检查</li>
<li>要连接到网络，可以：<ul>
<li>有线以太网–连接网线</li>
<li>WiFi–使用 iwctl 验证无线网络</li>
</ul>
</li>
<li>配置网络连接<ul>
<li>DHCP：动态 IP 地址和 DNS 服务器分配</li>
<li>静态 IP 地址</li>
</ul>
</li>
<li>用 <code>ping</code> 命令检查网络连接</li>
</ul>
</li>
<li>更新系统时间<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查服务状态</span></span><br><span class="line">timedatectl status</span><br><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure></li>
<li>建立硬盘分区，使用 <code>fdisk</code> 或 <code>cfdisk</code> 工具进行硬盘分区<table>
<thead>
<tr>
<th>挂载点</th>
<th>分区</th>
<th>分区类型</th>
<th>建议大小</th>
</tr>
</thead>
<tbody><tr>
<td>/mnt/boot/EFI</td>
<td>/dev/sdx1</td>
<td>EFI 系统分区</td>
<td>260-512MB</td>
</tr>
<tr>
<td>/mnt/</td>
<td>/dev/sdx2</td>
<td>Linux x86_64 根目录</td>
<td>剩余空间</td>
</tr>
<tr>
<td>[SWAP]</td>
<td>/dev/sdx3</td>
<td>Linux swap</td>
<td>大于 512MB</td>
</tr>
</tbody></table>
</li>
<li>格式化分区<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sdx1</span><br><span class="line">mkfs.ext4 /dev/sdx2</span><br><span class="line">mkswap /dev/sdx3 -L Swap</span><br><span class="line">swapon /dev/sdx3</span><br></pre></td></tr></table></figure></li>
<li>挂载分区<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount /dev/sdx2 /mnt</span><br><span class="line">mkdir -p /mnt/boot/EFI</span><br><span class="line">mount /dev/sdx1 /mnt/boot/EFI</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>选择镜像，编辑 /etc/pacman.d/mirrorlist 文件，选择镜像源</li>
<li>安装必须的软件包<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-firmware dhcpcd vim man-db man-pages texinfo</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><ol>
<li>生成 fstab 分区表<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure></li>
<li>进入新安装的系统<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure></li>
<li>设置时区<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure></li>
<li>本地化<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 en_US.UTF-8 和 zh_CN.UTF-8 的注释</span></span><br><span class="line">locale-gen</span><br><span class="line">vim /etc/locale.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加 LANG=en_US.UTF-8</span></span><br></pre></td></tr></table></figure></li>
<li>安装上网的软件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S iw wpa_supplicant dialog</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>passwd</code> 命令设置 root 用户密码</li>
<li>安装引导并配置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot/EFI -bootloader-id=grub</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></li>
<li>退出并重启</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(23)：责任链模式</title>
    <url>/2020/07/08/54332/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>责任链模式为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止</p>
<ul>
<li>优点<ul>
<li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息</li>
<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则</li>
<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任</li>
<li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则</li>
</ul>
</li>
<li>缺点<ul>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(22)：策略模式</title>
    <url>/2020/07/08/36459/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</p>
<ul>
<li>优点<ul>
<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离</li>
</ul>
</li>
<li>缺点<ul>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类</li>
<li>策略模式造成很多的策略类</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Hand 类表示猜拳游戏中的手势的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HAND_SHITOU = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HAND_JIANDAO = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HAND_BU = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Hand[] HAND = &#123;</span><br><span class="line">            <span class="keyword">new</span> Hand(HAND_SHITOU),</span><br><span class="line">            <span class="keyword">new</span> Hand(HAND_JIANDAO),</span><br><span class="line">            <span class="keyword">new</span> Hand(HAND_BU)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] name =&#123;</span><br><span class="line">            <span class="string">"石头"</span>,<span class="string">"剪刀"</span>,<span class="string">"布"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> handValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hand</span><span class="params">(<span class="keyword">int</span> handValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handValue = handValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hand <span class="title">getHand</span><span class="params">(<span class="keyword">int</span> handValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HAND[handValue];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrongerThan</span><span class="params">(Hand h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fight(h) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWeakerThan</span><span class="params">(Hand h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fight(h) == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fight</span><span class="params">(Hand h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == h) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.handValue + <span class="number">1</span>) % <span class="number">3</span> == h.handValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name[handValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Strategy 接口，定义猜拳策略的抽象方法的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function">Hand <span class="title">nextHand</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">boolean</span> win)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WinningStrategy 类，Strategy 接口的实现类之一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WinningStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> won = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Hand preHand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WinningStrategy</span><span class="params">(<span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">        random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hand <span class="title">nextHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!won) &#123;</span><br><span class="line">            preHand = Hand.getHand(random.nextInt(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">boolean</span> win)</span> </span>&#123;</span><br><span class="line">        won = win;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProbStrategy 类，Strategy 接口的实现类之一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProbStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> preHandValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentHandValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] history = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProbStrategy</span><span class="params">(<span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">        random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hand <span class="title">nextHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bet = random.nextInt(getSum(currentHandValue));</span><br><span class="line">        <span class="keyword">int</span> handValue;</span><br><span class="line">        <span class="keyword">if</span> (bet &lt; history[currentHandValue][<span class="number">0</span>]) &#123;</span><br><span class="line">            handValue = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bet &lt; history[currentHandValue][<span class="number">0</span>] + history[currentHandValue][<span class="number">1</span>]) &#123;</span><br><span class="line">            handValue = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handValue = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preHandValue = currentHandValue;</span><br><span class="line">        currentHandValue = handValue;</span><br><span class="line">        <span class="keyword">return</span> Hand.getHand(handValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> hv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            sum += history[hv][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">boolean</span> win)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (win) &#123;</span><br><span class="line">            history[preHandValue][currentHandValue]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            history[preHandValue][(currentHandValue + <span class="number">1</span>) % <span class="number">3</span>]++;</span><br><span class="line">            history[preHandValue][(currentHandValue + <span class="number">2</span>) % <span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Player 类，表示进行猜拳的玩家</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> winCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loseCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gameCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name, Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Hand <span class="title">nextHand</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.nextHand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">win</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.study(<span class="keyword">true</span>);</span><br><span class="line">        winCount++;</span><br><span class="line">        gameCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">lose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.study(<span class="keyword">false</span>);</span><br><span class="line">        loseCount++;</span><br><span class="line">        gameCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">()</span></span>&#123;</span><br><span class="line">        gameCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Player&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", winCount="</span> + winCount +</span><br><span class="line">                <span class="string">", loseCount="</span> + loseCount +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> seed1 = <span class="number">314</span>;</span><br><span class="line">        <span class="keyword">int</span> seed2 = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">        Player p1 = <span class="keyword">new</span> Player(<span class="string">"Taro"</span>, <span class="keyword">new</span> WinningStrategy(seed1));</span><br><span class="line">        Player p2 = <span class="keyword">new</span> Player(<span class="string">"Hana"</span>, <span class="keyword">new</span> ProbStrategy(seed2));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            Hand hand1 = p1.nextHand();</span><br><span class="line">            Hand hand2 = p2.nextHand();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hand1.isStrongerThan(hand2))&#123;</span><br><span class="line">                p1.win();</span><br><span class="line">                p2.lose();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (hand1.isWeakerThan(hand2))&#123;</span><br><span class="line">                p1.lose();</span><br><span class="line">                p2.win();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p1.even();</span><br><span class="line">                p2.even();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"p1 = "</span> + p1);</span><br><span class="line">        System.out.println(<span class="string">"p2 = "</span> + p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">p1 = Player&#123;name=<span class="string">'Taro'</span>, winCount=3167, loseCount=3490&#125;</span><br><span class="line">p2 = Player&#123;name=<span class="string">'Hana'</span>, winCount=3490, loseCount=3167&#125;</span><br></pre></td></tr></table></figure>

<h2 id="策略模式中的角色"><a href="#策略模式中的角色" class="headerlink" title="策略模式中的角色"></a>策略模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Strategy</td>
<td>策略</td>
<td>负责决定实现策略所必须的接口</td>
</tr>
<tr>
<td>ConcreteStrategy</td>
<td>具体的策略</td>
<td>负责实现 Strategy 角色的接口</td>
</tr>
<tr>
<td>Context</td>
<td>上下文</td>
<td>负责使用 Strategy 角色</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/45054/">抽象工厂模式</a><br>使用策略模式可以整体地替换算法。使用抽象工厂模式则可以整体地替换具体工厂、零件和产品</li>
<li><a href="/2020/07/08/8687/">享元模式</a><br>有时会使用享元模式让多个地方可以共用 ConcreteStrategy 角色</li>
<li><a href="/2020/07/08/387/">状态模式</a><br>策略模式和状态模式都可以替换被委托对象，但两者的目的不同。<br>策略模式中，ConcreteStrategy 角色是表示算法的类，可以替换被委托对象的类，也可以不替换。状态模式中，ConcreteState 角色是表示状态的类，每次状态变化时，被委托对象的类都必定被替换</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(21)：状态模式</title>
    <url>/2020/07/08/387/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>状态模式：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为</p>
<ul>
<li>优点<ul>
<li>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”</li>
<li>减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖</li>
<li>有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换</li>
</ul>
</li>
<li>缺点<ul>
<li>状态模式的使用必然会增加系统的类与对象的个数</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>State接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现State接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前是开始状态"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Start State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前是停止状态"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stop State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context 类，用于保存状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huben.pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> koishi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line"></span><br><span class="line">        StartState startState = <span class="keyword">new</span> StartState();</span><br><span class="line">        startState.handle(context);</span><br><span class="line">        System.out.println(context.getState().toString());</span><br><span class="line"></span><br><span class="line">        StopState stopState = <span class="keyword">new</span> StopState();</span><br><span class="line">        stopState.handle(context);</span><br><span class="line">        System.out.println(context.getState().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当前是开始状态</span><br><span class="line">Start State</span><br><span class="line">当前是停止状态</span><br><span class="line">Stop State</span><br></pre></td></tr></table></figure>

<h2 id="状态模式中的角色"><a href="#状态模式中的角色" class="headerlink" title="状态模式中的角色"></a>状态模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>State</td>
<td>状态</td>
<td>表示状态，定义了不同状态进行不同处理的接口</td>
</tr>
<tr>
<td>ConcreteState</td>
<td>具体的状态</td>
<td>负责实现 State 角色的接口</td>
</tr>
<tr>
<td>Context</td>
<td>上下文</td>
<td>持有表示当前状态的 State 角色</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/07/9773/">单例模式</a><br>单例模式常常会出现在 ConcreteState 角色中</li>
<li><a href="/2020/07/08/8687/">享元模式</a><br>在表示状态的类中并没有定义任何实例字段。因此可以使用享元模式在多个 Context 角色中共享 ConcreteState 角色</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(20)：解释器模式</title>
    <url>/2020/07/08/13236/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>解释器模式给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文</p>
<ul>
<li>优点<ul>
<li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li>
<li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易</li>
</ul>
</li>
<li>缺点<ul>
<li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦</li>
<li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护</li>
<li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Expression 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 Expression 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Expression exp1;</span><br><span class="line">    <span class="keyword">private</span> Expression exp2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression exp1, Expression exp2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exp1 = exp1;</span><br><span class="line">        <span class="keyword">this</span>.exp2 = exp2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exp1.interpret(context) &amp;&amp; exp2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Expression exp1;</span><br><span class="line">    <span class="keyword">private</span> Expression exp2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrExpression</span><span class="params">(Expression exp1, Expression exp2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exp1 = exp1;</span><br><span class="line">        <span class="keyword">this</span>.exp2 = exp2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exp1.interpret(context) || exp2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.contains(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Expression isMale = getMaleExpression();</span><br><span class="line">        Expression isMarriedWoman = getMarriedWomanExpression();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"John is male? "</span> + isMale.interpret(<span class="string">"John"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Julie is a married women? "</span></span><br><span class="line">                + isMarriedWoman.interpret(<span class="string">"Married Julie"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMaleExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Expression robert = <span class="keyword">new</span> TerminalExpression(<span class="string">"Robert"</span>);</span><br><span class="line">        Expression john = <span class="keyword">new</span> TerminalExpression(<span class="string">"John"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrExpression(robert,john);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMarriedWomanExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Expression julie = <span class="keyword">new</span> TerminalExpression(<span class="string">"Julie"</span>);</span><br><span class="line">        Expression married = <span class="keyword">new</span> TerminalExpression(<span class="string">"Married"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndExpression(julie, married);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">John is male? <span class="literal">true</span></span><br><span class="line">Julie is a married women? <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="解释器模式中的角色"><a href="#解释器模式中的角色" class="headerlink" title="解释器模式中的角色"></a>解释器模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Expression</td>
<td>表达式</td>
<td>定义语法树节点的接口</td>
</tr>
<tr>
<td>TerminalExpression</td>
<td>终结符表达式</td>
<td>表示终结符表达式</td>
</tr>
<tr>
<td>NonTerminalExpression</td>
<td>非终结符表达式</td>
<td>表示非终结符表达式</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/48350/">组合模式</a><br>NonTerminalExpression 角色多是递归结果，因此常使用组合模式来实现</li>
<li><a href="/2020/07/08/8687/">享元模式</a><br>有时会使用享元模式来共享 TerminalExpression 角色</li>
<li><a href="/2020/07/08/35613/">访问者模式</a><br>在推导出语法树后，有时会使用访问者模式来访问语法树的各个节点</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(19)：备忘录模式</title>
    <url>/2020/07/08/32110/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式</p>
<ul>
<li>优点<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则</li>
</ul>
</li>
<li>缺点<ul>
<li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Memento 类，表示状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; items;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money=money;</span><br><span class="line">        items=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;String&gt;) items.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gamer类，表示玩家</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gamer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] itemNames = &#123;<span class="string">"剑"</span>, <span class="string">"盾"</span>, <span class="string">"弓"</span>, <span class="string">"刀"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gamer</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dice = random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (dice) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                money += <span class="number">100</span>;</span><br><span class="line">                System.out.println(<span class="string">"所持的金钱增加了。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                money /= <span class="number">2</span>;</span><br><span class="line">                System.out.println(<span class="string">"所持的金钱减半了。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span> -&gt; &#123;</span><br><span class="line">                String i = getItem();</span><br><span class="line">                items.add(i);</span><br><span class="line">                System.out.println(<span class="string">"获得了装备："</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">"什么都没有发生。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itemNames[random.nextInt(itemNames.length)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Memento memento = <span class="keyword">new</span> Memento(money);</span><br><span class="line">        <span class="keyword">for</span> (String item : items) &#123;</span><br><span class="line">            memento.addItem(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = memento.getMoney();</span><br><span class="line">        <span class="keyword">this</span>.items = memento.getItems();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Gamer&#123;"</span> + <span class="string">"money="</span> + money + <span class="string">", items="</span> + items + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MementoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gamer gamer = <span class="keyword">new</span> Gamer(<span class="number">100</span>);</span><br><span class="line">        Memento memento=gamer.createMemento();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"===="</span>+i);</span><br><span class="line">            System.out.println(<span class="string">"当前状态: "</span>+gamer);</span><br><span class="line"></span><br><span class="line">            gamer.bet();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"所持金钱为: "</span>+gamer.getMoney()+<span class="string">"元。"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gamer.getMoney()&gt; memento.getMoney())&#123;</span><br><span class="line">                System.out.println(<span class="string">"保存状态"</span>);</span><br><span class="line">                memento=gamer.createMemento();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (gamer.getMoney()&lt;memento.getMoney()/<span class="number">2</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"恢复状态"</span>);</span><br><span class="line">                gamer.restoreMemento(memento);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">====0</span><br><span class="line">当前状态: Gamer&#123;money=100, items=[]&#125;</span><br><span class="line">什么都没有发生。</span><br><span class="line">所持金钱为: 100元。</span><br><span class="line">====1</span><br><span class="line">当前状态: Gamer&#123;money=100, items=[]&#125;</span><br><span class="line">获得了装备：盾</span><br><span class="line">所持金钱为: 100元。</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">====99</span><br><span class="line">当前状态: Gamer&#123;money=650, items=[盾, 弓, 剑, 剑, 弓, 剑, 剑, 盾]&#125;</span><br><span class="line">所持的金钱增加了。</span><br><span class="line">所持金钱为: 750元。</span><br></pre></td></tr></table></figure>

<h2 id="备忘录模式中的角色"><a href="#备忘录模式中的角色" class="headerlink" title="备忘录模式中的角色"></a>备忘录模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Orginator</td>
<td>生成者</td>
<td>在保存自己最新状态时生成 Memento 角色。把以前保存的 Memento 角色传给 Orginator 时，它会恢复至生成该 Memento 角色时的状态</td>
</tr>
<tr>
<td>Memento</td>
<td>备忘</td>
<td>将 Orginator 角色的内部信息整合在一起</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/55455/">原型模式</a><br>在备忘录模式中，为了能够实现快照和撤销的功能，保存了对象当前的状态。保存的信息只是在恢复状态时所需要的那部分信息<br>在原型模式中，会生成一个与当前实例完全相同的另一个实例，这两个实例的内容完全相同</li>
<li><a href="/2020/07/08/55222/">命令模式</a><br>在使用命令模式处理命令时，可以使用备忘录模式实现撤销功能</li>
<li><a href="/2020/07/08/387/">状态模式</a><br>在备忘录模式在是用实例表示状态，而在状态模式中是用类表示状态</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(18)：中介者模式</title>
    <url>/2020/07/08/44922/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>中介者模式定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用</p>
<ul>
<li>优点<ul>
<li>降低了对象之间的耦合性，使得对象易于独立地被复用</li>
<li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展</li>
</ul>
</li>
<li>缺点<ul>
<li>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Client 类，表示客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PcClient，表示电脑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PcClient</span> <span class="keyword">extends</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电脑收到消息: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电脑发送消息: "</span> + message);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PhoneClient，表示手机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneClient</span> <span class="keyword">extends</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"手机收到消息: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"手机发送消息: "</span> + message);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server，表示服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Client client)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(Client client, String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteServer，表示具体的服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Client&gt; clients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!clients.contains(client)) &#123;</span><br><span class="line">            clients.add(client);</span><br><span class="line">            client.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Client client, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Client c : clients) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!c.equals(client)) &#123;</span><br><span class="line">                c.receive(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> ConcreteServer();</span><br><span class="line">        Client client1 =<span class="keyword">new</span> PcClient();</span><br><span class="line">        Client client2 =<span class="keyword">new</span> PhoneClient();</span><br><span class="line">        server.register(client1);</span><br><span class="line">        server.register(client2);</span><br><span class="line"></span><br><span class="line">        client1.send(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">        client2.send(<span class="string">"World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">电脑发送消息: Hello</span><br><span class="line">手机收到消息: Hello</span><br><span class="line">---------------</span><br><span class="line">手机发送消息: World</span><br><span class="line">电脑收到消息: World</span><br></pre></td></tr></table></figure>

<h2 id="中介者模式中的角色"><a href="#中介者模式中的角色" class="headerlink" title="中介者模式中的角色"></a>中介者模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Mediator</td>
<td>中介者</td>
<td>定义与 Colleague 角色进行通信和做出决定的接口</td>
</tr>
<tr>
<td>ConcreteMediator</td>
<td>具体的中介者</td>
<td>实现 Mediator 所定义的接口</td>
</tr>
<tr>
<td>Colleague</td>
<td>同事</td>
<td>定义与 Mediator 角色进行通信的接口</td>
</tr>
<tr>
<td>ConcreteColleague</td>
<td>具体的同事</td>
<td>实现 Colleague 所定义的接口</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/52857/">外观模式</a><br>在中介者模式中，Mediator 角色与 Colleague 角色进行交互。在外观模式中，Facade 角色单方面地使用其他角色来对外提供接口</li>
<li><a href="/2020/07/08/44922/">观察者模式</a><br>有时会使用观察者模式来实现 Mediator 角色与 Colleague 之间的通信</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(17)：观察者模式</title>
    <url>/2020/07/08/38827/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式</p>
<ul>
<li>优点<ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系</li>
<li>目标与观察者之间建立了一套触发机制</li>
</ul>
</li>
<li>缺点：<ul>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Observer，表示观察者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator numberGenerator)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NumberGenerator，用于生成一个数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RandomNumberGenerator，用于生产随机数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomNumberGenerator</span> <span class="keyword">extends</span> <span class="title">NumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            number = random.nextInt(<span class="number">20</span>);</span><br><span class="line">            notifyObserver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DigitObserver，以数字显示观察到的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigitObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator numberGenerator)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DigitObserver: "</span> + numberGenerator.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GraphObserver，以***的形式显示观察到的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator numberGenerator)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"GraphObserver: "</span>);</span><br><span class="line">        <span class="keyword">int</span> count = numberGenerator.getNumber();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       NumberGenerator numberGenerator = <span class="keyword">new</span> RandomNumberGenerator();</span><br><span class="line">       numberGenerator.add(<span class="keyword">new</span> DigitObserver());</span><br><span class="line">       numberGenerator.add(<span class="keyword">new</span> GraphObserver());</span><br><span class="line"></span><br><span class="line">       numberGenerator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DigitObserver: <span class="number">3</span></span><br><span class="line">GraphObserver: ***</span><br><span class="line">DigitObserver: <span class="number">19</span></span><br><span class="line">GraphObserver: *******************</span><br><span class="line">DigitObserver: <span class="number">1</span></span><br><span class="line">GraphObserver: *</span><br><span class="line">DigitObserver: <span class="number">0</span></span><br><span class="line">GraphObserver: </span><br><span class="line">DigitObserver: <span class="number">6</span></span><br><span class="line">GraphObserver: ******</span><br></pre></td></tr></table></figure>

<h2 id="观察者模式中的角色"><a href="#观察者模式中的角色" class="headerlink" title="观察者模式中的角色"></a>观察者模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Subject</td>
<td>观察对象</td>
<td>定义了注册与删除观察者的接口，以及获取现在状态的方法</td>
</tr>
<tr>
<td>ConcreteSubject</td>
<td>具体的观察对象</td>
<td>实现 Subject 所定义的接口</td>
</tr>
<tr>
<td>Observer</td>
<td>观察者</td>
<td>负责接收来自 Subject 角色的状态变化的通知</td>
</tr>
<tr>
<td>ConcreteObserver</td>
<td>具体的观察者</td>
<td>实现 Observer 所定义的接口</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/44922/">中介者模式</a><br>在中介者模式中有时会使用观察者模式来实现 Mediator 角色与 Colleague 角色之间的通信</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(16)：迭代器模式</title>
    <url>/2020/07/08/14077/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迭代器模式提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示</p>
<ul>
<li>优点<ul>
<li>支持以不同的方式遍历一个聚合对象</li>
<li>迭代器简化了聚合类</li>
<li>在同一个聚合上可以有多个遍历</li>
<li>增加新的聚合类和迭代器类都很方便，无须修改原有代码</li>
</ul>
</li>
<li>缺点<ul>
<li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Aggregete 是所要遍历的集合的接口。实现了该接口的集合将成为一个可以保存多个元素的集合。该接口的 iterator 方法会生成一个用于遍历集合的迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 接口用于遍历集合中的元素，其作用相当于循环语句中的循环变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Book 是表示书的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BookShelf 是表示书架的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Book[] books;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookShelf</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books = <span class="keyword">new</span> Book[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBookAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> books[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books[last++] = book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookShelfIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BookShelfIterator 用于遍历书架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelfIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookShelf bookShelf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookShelfIterator</span><span class="params">(BookShelf bookShelf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookShelf = bookShelf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookShelf.getBookAt(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; bookShelf.getLength();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BookShelf bookShelf = <span class="keyword">new</span> BookShelf(<span class="number">4</span>);</span><br><span class="line">        bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Spring"</span>));</span><br><span class="line">        bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Summer"</span>));</span><br><span class="line">        bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Fall"</span>));</span><br><span class="line">        bookShelf.appendBook(<span class="keyword">new</span> Book(<span class="string">"Winter"</span>));</span><br><span class="line"></span><br><span class="line">        Iterator iterator = bookShelf.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Book book = (Book) iterator.next();</span><br><span class="line">            System.out.println(book.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Spring</span><br><span class="line">Summer</span><br><span class="line">Fall</span><br><span class="line">Winter</span><br></pre></td></tr></table></figure>

<h2 id="迭代器模式中的角色"><a href="#迭代器模式中的角色" class="headerlink" title="迭代器模式中的角色"></a>迭代器模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Iterator</td>
<td>迭代器</td>
<td>定义按顺序逐个遍历元素的接口</td>
</tr>
<tr>
<td>ConcreteIterator</td>
<td>具体的迭代器</td>
<td>实现 Iterator 所定义的接口</td>
</tr>
<tr>
<td>Aggregate</td>
<td>集合</td>
<td>定义创建 Iterator 角色的接口</td>
</tr>
<tr>
<td>ConcreteAggregate</td>
<td>具体的集合</td>
<td>实现 Aggregate 所定义的接口</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/13845/">工厂方法模式</a><br>在 iterator 方法中生成 Irerator 实例时可能会使用工厂方法模式</li>
<li><a href="/2020/07/08/48350/">组合模式</a><br>组合模式是具有递归模式的结构，在其中使用迭代器模式比较困难</li>
<li><a href="/2020/07/08/35613/">访问者模式</a><br>迭代器模式是从集合中一个一个地取出元素进行遍历，但是没有在 Iterator 接口中声明对取出的元素进行何种处理<br>访问者模式则是在遍历元素集合的过程中，对元素进行相同的处理</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(15)：访问者模式</title>
    <url>/2020/07/08/35613/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>访问者模式将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离</p>
<ul>
<li>优点<ul>
<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构</li>
<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一</li>
</ul>
</li>
<li>缺点<ul>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”</li>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Element 接口是接受访问者访问的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry 类和组合模式中的 Entry 类一样，表示目录和文件的抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getName() + <span class="string">" ("</span> + getSize() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>File 类和组合模式中的 File 类一样，表示文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Directory 类和组合模式中的 Directory 类一样，表示目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Entry&gt; directory = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> directory.stream().map(Entry::getSize).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        directory.add(entry);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Entry&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> directory.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Visitor 接口，表示访问者，它依赖于它所访问的数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EntryVisitor 类，它用于访问 Entry 并显示元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListVistor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String currentDir = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        System.out.println(currentDir + <span class="string">"/"</span> + file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span> </span>&#123;</span><br><span class="line">        System.out.println(currentDir + <span class="string">"/"</span> + directory);</span><br><span class="line">        String saveDir = currentDir;</span><br><span class="line">        currentDir = currentDir + <span class="string">"/"</span> + directory.getName();</span><br><span class="line">        Iterator&lt;Entry&gt; iterator = directory.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">             iterator.next().accept(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        currentDir=saveDir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Directory rootDir = <span class="keyword">new</span> Directory(<span class="string">"root"</span>);</span><br><span class="line">        Directory binDir = <span class="keyword">new</span> Directory(<span class="string">"bin"</span>);</span><br><span class="line">        Directory tmpDir = <span class="keyword">new</span> Directory(<span class="string">"tmp"</span>);</span><br><span class="line">        Directory usrDir = <span class="keyword">new</span> Directory(<span class="string">"usr"</span>);</span><br><span class="line"></span><br><span class="line">        rootDir.add(binDir).add(tmpDir).add(usrDir);</span><br><span class="line">        binDir.add(<span class="keyword">new</span> File(<span class="string">"vi"</span>, <span class="number">10000</span>))</span><br><span class="line">                .add(<span class="keyword">new</span> File(<span class="string">"latex"</span>, <span class="number">20000</span>));</span><br><span class="line">        tmpDir.add(<span class="keyword">new</span> File(<span class="string">"a.txt"</span>, <span class="number">123</span>));</span><br><span class="line">        rootDir.accept(<span class="keyword">new</span> ListVistor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/root (30123)</span><br><span class="line">/root/bin (30000)</span><br><span class="line">/root/bin/vi (10000)</span><br><span class="line">/root/bin/latex (20000)</span><br><span class="line">/root/tmp (123)</span><br><span class="line">/root/tmp/a.txt (123)</span><br><span class="line">/root/usr (0)</span><br></pre></td></tr></table></figure>

<h2 id="访问者模式中的角色"><a href="#访问者模式中的角色" class="headerlink" title="访问者模式中的角色"></a>访问者模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Visitor</td>
<td>访问者</td>
<td>负责对数据结构中每个具体的元素声明一个用于访问的方法</td>
</tr>
<tr>
<td>ConcreteVisitor</td>
<td>具体的访问者</td>
<td>负责实现 Visitor 角色定义的接口</td>
</tr>
<tr>
<td>Element</td>
<td>元素</td>
<td>表示 Visitor 角色访问的对象，它声明了接受访问者的方法</td>
</tr>
<tr>
<td>ConcreteElement</td>
<td>具体的元素</td>
<td>负责实现 Element 角色定义的接口</td>
</tr>
<tr>
<td>ObjectStructure</td>
<td>对象结构</td>
<td>负责处理 Element 角色的集合，ConcreteVisitor 为每个 Element 角色都准备了处理方法</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/48350/">组合模式</a><br>有时候访问者所访问的数据结构会使用组合模式</li>
<li><a href="/2020/07/08/14077/">迭代器模式</a><br>访问者模式用于对保存在数据结构中的元素进行某种特定的处理。迭代器模式用于遍历保存在数据结构中的元素</li>
<li><a href="/2020/07/08/13236/">解释器模式</a><br>在解释器模式中，有时会使用访问者模式</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(14)：命令模式</title>
    <url>/2020/07/08/55222/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>命令模式将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理</p>
<ul>
<li>优点<ul>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复</li>
</ul>
</li>
<li>缺点<ul>
<li>可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Command 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteCommand 类，具体的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Receiver 类，接受命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接收者的action方法被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Invoker 类，发动者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用者执行命令command"</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Command command = <span class="keyword">new</span> ConcreteCommand();</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(command);</span><br><span class="line">        System.out.println(<span class="string">"客户调用访问者的call方法"</span>);</span><br><span class="line">        invoker.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">客户调用访问者的call方法</span><br><span class="line">调用者执行命令<span class="built_in">command</span></span><br><span class="line">接收者的action方法被调用</span><br></pre></td></tr></table></figure>

<h2 id="命令模式中的角色"><a href="#命令模式中的角色" class="headerlink" title="命令模式中的角色"></a>命令模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Command</td>
<td>命令</td>
<td>定义命令的接口</td>
</tr>
<tr>
<td>ConcreteCommand</td>
<td>具体的命令</td>
<td>实现 Command 角色的接口</td>
</tr>
<tr>
<td>Receiver</td>
<td>接受者</td>
<td>Command 角色执行命令时的对象</td>
</tr>
<tr>
<td>Invoker</td>
<td>发动者</td>
<td>开始执行命令的角色</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/55455/">原型模式</a><br>有时会使用原型模式复制生成的命令</li>
<li><a href="/2020/07/08/48350/">组合模式</a><br>有时会使用组合模式实现宏命令</li>
<li><a href="/2020/07/08/32110/">备忘录模式</a><br>有时会使用备忘录模式来保存 Command 角色的历史记录</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(13)：模板方法模式</title>
    <url>/2020/07/08/10595/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模板方法模式的定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤</p>
<ul>
<li>优点<ul>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展</li>
<li>它在父类中提取了公共的部分代码，便于代码复用</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则</li>
</ul>
</li>
<li>缺点<ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>AbstractDisplay 类，可以看到，open、print、close 方法的实现都交给了子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDisplay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        open();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CharDisplay 打印字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharDisplay</span> <span class="keyword">extends</span> <span class="title">AbstractDisplay</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharDisplay</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"&lt;&lt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringDisplay 打印字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplay</span> <span class="keyword">extends</span> <span class="title">AbstractDisplay</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringDisplay</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">        <span class="keyword">this</span>.width = str.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"|"</span> + str + <span class="string">"|"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"+"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"-"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractDisplay display1 = <span class="keyword">new</span> CharDisplay(<span class="string">'H'</span>);</span><br><span class="line">        display1.display();</span><br><span class="line"></span><br><span class="line">        AbstractDisplay display2 = <span class="keyword">new</span> StringDisplay(<span class="string">"Hello, world!"</span>);</span><br><span class="line">        display2.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;&lt;HHHHH&gt;&gt;</span><br><span class="line">+-------------+</span><br><span class="line">|Hello, world!|</span><br><span class="line">|Hello, world!|</span><br><span class="line">|Hello, world!|</span><br><span class="line">|Hello, world!|</span><br><span class="line">|Hello, world!|</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<h2 id="模板方法模式中的角色"><a href="#模板方法模式中的角色" class="headerlink" title="模板方法模式中的角色"></a>模板方法模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>AbstractClass</td>
<td>抽象类</td>
<td>声明模板方法以及在模板方法中所用到的抽象方法</td>
</tr>
<tr>
<td>ConcreteClass</td>
<td>具体类</td>
<td>实现 AbstractClass 角色中定义的抽象方法</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/13845/">工厂方法模式</a><br>工厂方法模式是将模板方法模式用于生成实例的一个典型例子</li>
<li><a href="/2020/07/08/36459/">策略模式</a><br>在模板方法模式中，可以使用继承改变程序的行为。这是因为模板方法模式在父类中定义程序行为的框架，在子类中决定具体的处理<br>与此对应的是策略模式，它可以使用委托改变抽象的行为。与模板方法模式中改变部分程序行为不同的是，策略模式用于替换整个算法</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(12)：代理模式</title>
    <url>/2020/07/08/37911/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介</p>
<ul>
<li>优点<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li>
<li>代理对象可以扩展目标对象的功能</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li>
</ul>
</li>
<li>缺点<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢</li>
<li>增加了系统的复杂度</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Subject 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RealSubject 类，实际的主体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用真实主题方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Proxy 类，代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject==<span class="keyword">null</span>)&#123;</span><br><span class="line">            realSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主体前的预处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主体后的后续处理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">访问真实主体前的预处理</span><br><span class="line">调用真实主题方法</span><br><span class="line">访问真实主体后的后续处理</span><br></pre></td></tr></table></figure>

<h2 id="代理模式中的角色"><a href="#代理模式中的角色" class="headerlink" title="代理模式中的角色"></a>代理模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Subject</td>
<td>主题</td>
<td>定义了使 Proxy 和 RealSubject 角色之间具有一致性的接口</td>
</tr>
<tr>
<td>RealSubject</td>
<td>具体的主体</td>
<td>实现 Subject 角色的接口</td>
</tr>
<tr>
<td>Proxy</td>
<td>代理</td>
<td>使用 RealSubject 处理请求</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/37610/">适配器模式</a><br>适配器适配两种具有不同接口的对象，使它们可以一同工作<br>代理模式中，Proxy 和 RealSubject 的接口是相同的</li>
<li><a href="/2020/07/08/46491/">装饰模式</a><br>装饰模式目的在于增加新的功能，代理模式注重设置代理来减轻本人的负担</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(11)：享元模式</title>
    <url>/2020/07/08/8687/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>享元模式运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率</p>
<ul>
<li>优点<ul>
<li>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力</li>
</ul>
</li>
<li>缺点<ul>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Flyweigt 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteFlyweight 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        System.out.println(<span class="string">"具体享元 "</span> + key + <span class="string">" 被创建"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体享元 "</span> + <span class="keyword">this</span>.key + <span class="string">" 被调用"</span>);</span><br><span class="line">        System.out.println(<span class="string">"非享元信息是 "</span> + state.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnsharedConcreteFlyweight 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnsharedConcreteFlyweight</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlyweightFactory 类，创建享元对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Flyweight flyweight = flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span> (flyweight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"具体享元 "</span> + key + <span class="string">" 已存在，被成功获取"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f1 = factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f2 = factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f3 = factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f4 = factory.getFlyweight(<span class="string">"b"</span>);</span><br><span class="line">        Flyweight f5 = factory.getFlyweight(<span class="string">"b"</span>);</span><br><span class="line">        f1.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次使用a"</span>));</span><br><span class="line">        f2.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次使用a"</span>));</span><br><span class="line">        f3.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第3次使用a"</span>));</span><br><span class="line">        f4.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次使用b"</span>));</span><br><span class="line">        f5.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次使用b"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">具体享元 a 被创建</span><br><span class="line">具体享元 a 已存在，被成功获取</span><br><span class="line">具体享元 a 已存在，被成功获取</span><br><span class="line">具体享元 b 被创建</span><br><span class="line">具体享元 b 已存在，被成功获取</span><br><span class="line">具体享元 a 被调用</span><br><span class="line">非享元信息是 第1次s使用用a</span><br><span class="line">具体享元 a 被调用</span><br><span class="line">非享元信息是 第2次使用a</span><br><span class="line">具体享元 a 被调用</span><br><span class="line">非享元信息是 第3次使用a</span><br><span class="line">具体享元 b 被调用</span><br><span class="line">非享元信息是 第1次使用b</span><br><span class="line">具体享元 b 被调用</span><br><span class="line">非享元信息是 第2次使用b</span><br></pre></td></tr></table></figure>

<h2 id="享元模式中的角色"><a href="#享元模式中的角色" class="headerlink" title="享元模式中的角色"></a>享元模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Flyweight</td>
<td>享元</td>
<td>表示那些实例会被共享的类</td>
</tr>
<tr>
<td>FlyweightFactory</td>
<td>轻量级工厂</td>
<td>用于生成 Flyweight 角色</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/07/9773/">单例模式</a><br>有时 FlyweightFactory 角色会使用单例模式</li>
<li><a href="/2020/07/08/48350/">组合模式</a><br>有时可以使用享元模式共享组合模式中的 Leaf 角色</li>
<li><a href="/2020/07/08/37911">代理模式</a><br>如果生成实例的处理需要花费较长时间，那么使用享元模式可以提高程序的处理速度<br>代理模式则是通过设置代理提高程序的处理速度</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(10)：外观模式</title>
    <url>/2020/07/08/52857/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>外观模式是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性</p>
<ul>
<li>优点<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象</li>
</ul>
</li>
<li>缺点<ul>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>SubSystem1，子系统1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统1的method1被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubSystem2，子系统2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统2的method2被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubSystem3，子系统3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span>) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统3的method3被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Facade类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem1 subSystem1 = <span class="keyword">new</span> SubSystem1();</span><br><span class="line">    <span class="keyword">private</span> SubSystem2 subSystem2 = <span class="keyword">new</span> SubSystem2();</span><br><span class="line">    <span class="keyword">private</span> SubSystem3 subSystem3 = <span class="keyword">new</span> SubSystem3();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystem1.method1();</span><br><span class="line">        subSystem2.method2();</span><br><span class="line">        subSystem3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">子系统1的method1被调用</span><br><span class="line">子系统2的method2被调用</span><br><span class="line">子系统3的method3被调用</span><br></pre></td></tr></table></figure>

<h2 id="外观模式中的角色"><a href="#外观模式中的角色" class="headerlink" title="外观模式中的角色"></a>外观模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Facade</td>
<td>窗口</td>
<td>向系统外部提供高层接口</td>
</tr>
<tr>
<td>Component</td>
<td>组件</td>
<td>构成系统的其他角色</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/07/9773/">单例模式</a><br>有时候会使用单例模式创建 Facade 角色</li>
<li><a href="/2020/07/08/45054/">抽象工厂模式</a><br>可以将抽象工厂模式看成生成复杂实例时的外观模式</li>
<li><a href="/2020/07/08/44922/">中介者模式</a><br>在外观模式中，Facade 角色单方面使用其他角色来提供高层接口。在中介者模式中，Mediator 角色作为 Colleague 角色间的仲裁者负责调停</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(9)：组合模式</title>
    <url>/2020/07/08/48350/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>组合模式的定义又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性</p>
<ul>
<li><p>优点</p>
<ul>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系</li>
<li>不容易限制容器中的构件</li>
<li>不容易用继承的方法来增加构件的新功能</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Entry 类，表示目录和文件的抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printList(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getName()+<span class="string">" ("</span>+getSize()+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>File 类，表示文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        System.out.println(prefix + <span class="string">"/"</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Directory 类，表示目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Entry&gt; directory = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> directory.stream().map(Entry::getSize).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        directory.add(entry);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        System.out.println(prefix + <span class="string">"/"</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : directory) &#123;</span><br><span class="line">            entry.printList(prefix + <span class="string">"/"</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Directory rootDir = <span class="keyword">new</span> Directory(<span class="string">"root"</span>);</span><br><span class="line">        Directory binDir = <span class="keyword">new</span> Directory(<span class="string">"bin"</span>);</span><br><span class="line">        Directory tmpDir = <span class="keyword">new</span> Directory(<span class="string">"tmp"</span>);</span><br><span class="line">        Directory usrDir = <span class="keyword">new</span> Directory(<span class="string">"usr"</span>);</span><br><span class="line"></span><br><span class="line">        rootDir.add(binDir).add(tmpDir).add(usrDir);</span><br><span class="line">        binDir.add(<span class="keyword">new</span> File(<span class="string">"vi"</span>, <span class="number">10000</span>))</span><br><span class="line">                .add(<span class="keyword">new</span> File(<span class="string">"latex"</span>, <span class="number">20000</span>));</span><br><span class="line">        tmpDir.add(<span class="keyword">new</span> File(<span class="string">"a.txt"</span>, <span class="number">123</span>));</span><br><span class="line">        rootDir.printList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/root (30123)</span><br><span class="line">/root/bin (30000)</span><br><span class="line">/root/bin/vi (10000)</span><br><span class="line">/root/bin/latex (20000)</span><br><span class="line">/root/tmp (123)</span><br><span class="line">/root/tmp/a.txt (123)</span><br><span class="line">/root/usr (0)</span><br></pre></td></tr></table></figure>

<h2 id="组合模式中的角色"><a href="#组合模式中的角色" class="headerlink" title="组合模式中的角色"></a>组合模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Leaf</td>
<td>树叶</td>
<td>表示内容的角色</td>
</tr>
<tr>
<td>Composite</td>
<td>复合物</td>
<td>表示容器的角色</td>
</tr>
<tr>
<td>Component</td>
<td>组件</td>
<td>使 Leaf 和 Composite 角色具有一致性的角色</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/46491/">装饰模式</a><br>组合模式通过 Component 角色使容器(Composite) 和内容(Leaf) 具有一致性。装饰模式使装饰框和内容具有一致性</li>
<li><a href="/2020/07/08/55222/">命令模式</a><br>使用命令模式编写宏命令时使用了组合模式</li>
<li><a href="/2020/07/08/35613/">访问者模式</a><br>可以使用访问者模式访问组合模式中的递归结构</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(8)：装饰模式</title>
    <url>/2020/07/08/46491/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>装饰模式在不改变现有对象结构的情况下，动态地给对象增加一些职责（即增加其额外功能）</p>
<ul>
<li>优点<ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合</li>
</ul>
</li>
<li>缺点<ul>
<li>增加了许多子类，如果过度使用会使程序变得很复杂</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Display 类是可以显示多行字符串的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getCols</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getRows(); i++) &#123;</span><br><span class="line">            System.out.println(getRowText(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringDisplay 类用于显示单行字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplay</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringDisplay</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCols</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> string.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> row == <span class="number">0</span> ? string : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Border 类是装饰边框的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Border</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Display display;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Border</span><span class="params">(Display display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SideBorder 是一种具体的装饰边框，是 Border 类的子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SideBorder</span> <span class="keyword">extends</span> <span class="title">Border</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> borderChar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SideBorder</span><span class="params">(Display display, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(display);</span><br><span class="line">        <span class="keyword">this</span>.borderChar = ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCols</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> display.getCols() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> display.getRows();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> borderChar + display.getRowText(row) + borderChar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FullBorder 和 SideBorder 一样，也是 Border 类的子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullBorder</span> <span class="keyword">extends</span> <span class="title">Border</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FullBorder</span><span class="params">(Display display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(display);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCols</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> display.getCols() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> display.getRows() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span> || row == display.getRows() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"+"</span> + makeLine(<span class="string">'-'</span>, display.getCols()) + <span class="string">"+"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"|"</span> + display.getRowText(row - <span class="number">1</span>) + <span class="string">"|"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">makeLine</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ch).repeat(Math.max(<span class="number">0</span>, count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Display d1 = <span class="keyword">new</span> StringDisplay(<span class="string">"Hello world."</span>);</span><br><span class="line">        Display d2 = <span class="keyword">new</span> SideBorder(d1,<span class="string">'#'</span>);</span><br><span class="line">        Display d3 = <span class="keyword">new</span> FullBorder(d2);</span><br><span class="line"></span><br><span class="line">        d1.show();</span><br><span class="line">        d2.show();</span><br><span class="line">        d3.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello world.</span><br><span class="line"><span class="comment">#Hello world.#</span></span><br><span class="line">+--------------+</span><br><span class="line">|<span class="comment">#Hello world.#|</span></span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<h2 id="装饰模式中的角色"><a href="#装饰模式中的角色" class="headerlink" title="装饰模式中的角色"></a>装饰模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Component</td>
<td>组件</td>
<td>增加功能的核心角色</td>
</tr>
<tr>
<td>ConcreteComponent</td>
<td>实现 Component 角色所定义的接口</td>
<td></td>
</tr>
<tr>
<td>Decorator</td>
<td>装饰物</td>
<td>该角色具有与 Component 相同的接口，它内部保持了被装饰角色</td>
</tr>
<tr>
<td>ConcreteDecorator</td>
<td>具体的装饰物</td>
<td>具体的 Decorator 角色</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/37610/">适配器模式</a><br>装饰模式可以在不改变被装饰物的接口下为被装饰物添加新功能。适配器模式用于适配两个不同的接口</li>
<li><a href="/2020/07/08/36459/">策略模式</a><br>装饰模式可以添加被装饰物的功能。策略模式通过整体地替换算法来改变类的功能</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(7)：桥接模式</title>
    <url>/2020/07/08/55563/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>桥接模式将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</p>
<ul>
<li>优点<ul>
<li>抽象与实现分离，扩展能力强</li>
<li>实现细节对客户透明</li>
</ul>
</li>
<li>缺点<ul>
<li>增加系统的理解与设计难度</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>类的功能层次结构: Display 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DisplayImpl impl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Display</span><span class="params">(DisplayImpl impl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl=impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        impl.rawOpen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        impl.rawPrint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        impl.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span>  <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        open();</span><br><span class="line">        print();</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的功能层次结构: CountDisplay 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDisplay</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDisplay</span><span class="params">(DisplayImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiDisplay</span><span class="params">(<span class="keyword">int</span> times)</span></span>&#123;</span><br><span class="line">        open();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的实现层次结构: DisplayImpl 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的实现层次结构: DisplayImpl 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplayImpl</span> <span class="keyword">extends</span> <span class="title">DisplayImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringDisplayImpl</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">        <span class="keyword">this</span>.width = str.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"|"</span> + str + <span class="string">"|"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"+"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"-"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Display display1 = <span class="keyword">new</span> Display(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello world!"</span>));</span><br><span class="line">        CountDisplay display2 = <span class="keyword">new</span> CountDisplay(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello java!"</span>));</span><br><span class="line">        display1.display();</span><br><span class="line">        display2.multiDisplay(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+------------+</span><br><span class="line">|Hello world!|</span><br><span class="line">+------------+</span><br><span class="line">+-----------+</span><br><span class="line">|Hello java!|</span><br><span class="line">|Hello java!|</span><br><span class="line">|Hello java!|</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式中的角色"><a href="#桥接模式中的角色" class="headerlink" title="桥接模式中的角色"></a>桥接模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Abstraction</td>
<td>抽象化</td>
<td>使用 Implementor 角色的方法定义了基本的功能</td>
</tr>
<tr>
<td>RefinedAbstraction</td>
<td>改善后的抽象化</td>
<td>在 Abstraction 角色的基础上增加了新功能</td>
</tr>
<tr>
<td>Implementor</td>
<td>实现者</td>
<td>定义了用于实现 Abstarction 角色的接口的方法</td>
</tr>
<tr>
<td>ConcreteImplementor</td>
<td>具体实现者</td>
<td>实现在 Implementor 角色中定义的接口</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/45054/">抽象工厂模式</a><br>为了能够根据需求设计出良好的 ConcreteImplementor 角色，有时我们会使用抽象工厂模式</li>
<li><a href="/2020/07/08/37610/">适配器模式</a><br>使用桥接模式可以达到类的功能层次结构与类的实现层次结构分离的目的，并在此基础上使这些层次结构结合起来。而适配器模式则可以结合那些功能上相似但是接口不同的类</li>
<li><a href="/2020/07/08/10595/">模板方法模式</a><br>在模板方法模式中使用了类的实现层次结构，父类调用抽象方法，子类实现抽象方法</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(6)：适配器模式</title>
    <url>/2020/07/08/37610/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>适配器模式将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作</p>
<ul>
<li>优点<ul>
<li>可以让任何没有关联的类一起运行</li>
<li>提高了类的复用</li>
<li>增加了类的透明度</li>
<li>灵活性好</li>
</ul>
</li>
<li>缺点<ul>
<li>过多使用适配器会让系统非常零乱</li>
<li>只能适配一个适配者类</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Banner 类是现在的实际情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"("</span> + string + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*"</span> + string + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Print 接口是需求的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PrintBanner1 类适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner1</span> <span class="keyword">extends</span> <span class="title">Banner</span> <span class="keyword">implements</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner1</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        showWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        showWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PrintBanner2 对象适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner2</span>  <span class="keyword">implements</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Banner banner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintBanner2</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.banner = <span class="keyword">new</span> Banner(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        banner.showWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        banner.showWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintBanner1 banner1 = <span class="keyword">new</span> PrintBanner1(<span class="string">"hello"</span>);</span><br><span class="line">        banner1.printWeak();</span><br><span class="line">        banner1.printStrong();</span><br><span class="line"></span><br><span class="line">        PrintBanner2 banner2 = <span class="keyword">new</span> PrintBanner2(<span class="string">"world"</span>);</span><br><span class="line">        banner2.printWeak();</span><br><span class="line">        banner2.printStrong();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(hello)</span><br><span class="line">*hello*</span><br><span class="line">(world)</span><br><span class="line">*world*</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式中的角色"><a href="#适配器模式中的角色" class="headerlink" title="适配器模式中的角色"></a>适配器模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Target</td>
<td>对象</td>
<td>定义所需求的方法</td>
</tr>
<tr>
<td>Adaptee</td>
<td>被适配者</td>
<td>被适配者持有既定方法</td>
</tr>
<tr>
<td>Adapter</td>
<td>适配者</td>
<td>使用被 Adaptee 角色的方法来满足 Target 角色的需求</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/55563/">桥接模式</a><br>适配器模式用于连接接口不同的类，而桥接模式则用于连接类的功能层次结构与实现层次结构</li>
<li><a href="/2020/07/08/46491/">装饰模式</a><br>适配器模式用于填补不同接口之间的缝隙，而装饰模式则是在不改变接口的前提下增加功能</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(5)：建造者模式</title>
    <url>/2020/07/08/20259/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节</p>
<ul>
<li>优点<ul>
<li>建造者独立，易扩展</li>
<li>便于控制细节风险</li>
</ul>
</li>
<li>缺点<ul>
<li>产品必须有共同点，范围有限制</li>
<li>如内部变化复杂，会有很多建造类</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>创建产品类，包含多个组件的负责对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String part1;</span><br><span class="line">    <span class="keyword">private</span> String part2;</span><br><span class="line">    <span class="keyword">private</span> String part3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart1</span><span class="params">(String part1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.part1 = part1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart2</span><span class="params">(String part2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.part2 = part2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart3</span><span class="params">(String part3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.part3 = part3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product&#123;"</span> +</span><br><span class="line">                <span class="string">"part1='"</span> + part1 + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", part2='"</span> + part2 + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", part3='"</span> + part3 + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象建造者，包含创建产品各个子部件的抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPart3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体建造者，继承了抽象建造者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPart1(<span class="string">"build part1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPart2(<span class="string">"build part2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPart3(<span class="string">"build part3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建指挥者，调用建造在的方法完成负责对象的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildPart1();</span><br><span class="line">        builder.buildPart2();</span><br><span class="line">        builder.buildPart3();</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteBuilder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Product&#123;part1=<span class="string">'build part1'</span>, part2=<span class="string">'build part2'</span>, part3=<span class="string">'build part3'</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式中的角色"><a href="#建造者模式中的角色" class="headerlink" title="建造者模式中的角色"></a>建造者模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Product</td>
<td>产品</td>
<td>要建造的实例</td>
</tr>
<tr>
<td>Builder</td>
<td>建造者</td>
<td>定义用于生成实例的接口</td>
</tr>
<tr>
<td>ConcreteBuilder</td>
<td>具体的建造者</td>
<td>实现 Builder 角色的接口</td>
</tr>
<tr>
<td>Director</td>
<td>监工</td>
<td>使用 Builder 角色的接口来生成实例</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/45054/">抽象工厂模式</a><br>建造者模式和抽象工厂模式都用于生成复杂的实例</li>
<li><a href="/2020/07/08/48350/">组合模式</a><br>有些情况下建造者模式生成的实例构成了组合模式</li>
<li><a href="/2020/07/08/52857/">外观模式</a><br>在建造者模式中，Director 角色通过组合 Builder 角色的负责方法向外部提供可以简单生成实例的接口。外观模式中的 Facade 角色则是通过组合内部模块向外部提供可以简单调用的接口</li>
<li><a href="/2020/07/08/10595/">模板方法模式</a><br>在建造者模式中，DIrector 角色控制 Builder 角色。在模板方法模式中，父类控制子类</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(4)：原型模式</title>
    <url>/2020/07/08/55455/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
<ul>
<li>优点<ul>
<li>提升性能</li>
<li>避免构造函数的约束</li>
</ul>
</li>
<li>缺点<ul>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候</li>
<li>必须实现 <code>Cloneable</code> 接口</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>原型模式的克隆分为浅克隆和深克隆，java 中的 Object 类提供了浅克隆的 clone 方法，具体原型类只有实现 Cloneable 接口就可以实现对象的浅克隆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"koishi"</span>, <span class="number">18</span>);</span><br><span class="line">        Person person2 = person1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"person1 = "</span> + person1);</span><br><span class="line">        System.out.println(<span class="string">"person2 = "</span> + person2);</span><br><span class="line">        System.out.println(<span class="string">"person1 == person2: "</span>+(person1==person2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">person1 = Person&#123;name=<span class="string">'koishi'</span>, age=18&#125;</span><br><span class="line">person2 = Person&#123;name=<span class="string">'koishi'</span>, age=18&#125;</span><br><span class="line">person1 == person2: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="原型模式中的角色"><a href="#原型模式中的角色" class="headerlink" title="原型模式中的角色"></a>原型模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Prototype</td>
<td>原型</td>
<td>定义用于复制现有实例来生成新实例的方法</td>
</tr>
<tr>
<td>ConcretePrototype</td>
<td>具体的原型</td>
<td>实现复制现有实例来生成新实例的方法</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/08/46491/">装饰模式</a>以及<a href="/2020/07/08/48350/">组合模式</a><br>经常使用装饰模式和组合模式时，需要能够动态地创建复杂结构的实例。这时可以使用原型模式，以方便生成实例</li>
<li><a href="/2020/07/08/8687/">享元模式</a><br>使用原型模式可以生成一个与当前实例完全相同的实例。而使用享元模式可以在不同的地方使用同一个实例</li>
<li><a href="/2020/07/08/55222/">命令模式</a><br>想要负责命令模式中出现的命令时，可以使用原型模式</li>
<li><a href="/2020/07/08/32110/">备忘录模式</a><br>使用原型模式可以生成一个与当前实例完全相同的实例。而使用备忘录模式可以保存当前实例的状态，以实现快照和撤销功能</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(3)：抽象工厂模式</title>
    <url>/2020/07/08/45054/</url>
    <content><![CDATA[<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象</p>
<ul>
<li>优点：<ul>
<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象</li>
</ul>
</li>
<li>缺点<ul>
<li>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>创建鼠标和键盘的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">knock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建鼠标和键盘的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellMouse</span> <span class="keyword">implements</span> <span class="title">Mouse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"click Dell mouse"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpMouse</span> <span class="keyword">implements</span> <span class="title">Mouse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"click Hp mouse"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellKeyboard</span> <span class="keyword">implements</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"knock Dell keyboard"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpKeyboard</span> <span class="keyword">implements</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"knock Hp keyboard"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建电脑工厂生产鼠标和键盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Mouse <span class="title">createMouse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Keyboard <span class="title">createKeyboard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建电脑工厂的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mouse <span class="title">createMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DellMouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Keyboard <span class="title">createKeyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DellKeyboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mouse <span class="title">createMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpMouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Keyboard <span class="title">createKeyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpKeyboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DellFactory dellFactory = <span class="keyword">new</span> DellFactory();</span><br><span class="line">        dellFactory.createMouse().click();</span><br><span class="line">        dellFactory.createKeyboard().knock();</span><br><span class="line"></span><br><span class="line">        HpFactory hpFactory = <span class="keyword">new</span> HpFactory();</span><br><span class="line">        hpFactory.createMouse().click();</span><br><span class="line">        hpFactory.createKeyboard().knock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">click Dell mouse</span><br><span class="line">knock Dell keyboard</span><br><span class="line">click Hp mouse</span><br><span class="line">knock Hp keyboard</span><br></pre></td></tr></table></figure>

<h2 id="抽象工厂模式中的角色"><a href="#抽象工厂模式中的角色" class="headerlink" title="抽象工厂模式中的角色"></a>抽象工厂模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>AbstractProduct</td>
<td>抽象产品</td>
<td>定义 AbstractFactory 角色所生成的抽象产品的接口</td>
</tr>
<tr>
<td>AbstractFactory</td>
<td>抽象工厂</td>
<td>定义用于生成抽象产品的接口</td>
</tr>
<tr>
<td>ConcreteProduct</td>
<td>具体产品</td>
<td>实现 AbstractProduct 角色的接口</td>
</tr>
<tr>
<td>ConcreteFactory</td>
<td>具体工厂</td>
<td>实现 AbstractFactory 角色的接口</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/07/9773/">单例模式</a><br>有时抽象工厂模式中的具体工厂会使用单例模式</li>
<li><a href="/2020/07/08/13845/">工厂方法模式</a><br>有时抽象工厂模式中零件和产品的生成会使用工厂方法模式</li>
<li><a href="/2020/07/08/20259/">建造者模式</a><br>抽象工厂模式通过调用抽象产品的接口来组装抽象产品，生成具有负责结构的实例。建造者模式则是分阶段地制作实例</li>
<li><a href="/2020/07/08/48350/">组合模式</a><br>有时抽象工厂模式在制作产品时会使用组合模式</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(2)：工厂方法模式</title>
    <url>/2020/07/08/13845/</url>
    <content><![CDATA[<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂方法模式使其创建过程延迟到子类进行</p>
<ul>
<li>优点<ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口</li>
</ul>
</li>
<li>缺点<ul>
<li>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>创建抽象产品接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象工厂接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Shape <span class="title">getShape</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建具体产品类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw a circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw a square"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体工厂类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleFactory</span> <span class="keyword">implements</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareFactory</span> <span class="keyword">implements</span> <span class="title">ShapeFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeFactory shapeFactory = <span class="keyword">new</span> CircleFactory();</span><br><span class="line">        shapeFactory.getShape().draw();</span><br><span class="line"></span><br><span class="line">        ShapeFactory squareFactory = <span class="keyword">new</span> SquareFactory();</span><br><span class="line">        squareFactory.getShape().draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">draw a circle</span><br><span class="line">draw a square</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式中的角色"><a href="#工厂方法模式中的角色" class="headerlink" title="工厂方法模式中的角色"></a>工厂方法模式中的角色</h2><table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Product</td>
<td>产品</td>
<td>要建造的实例</td>
</tr>
<tr>
<td>Factory</td>
<td>工厂</td>
<td>负责生成 Product 角色</td>
</tr>
<tr>
<td>ConcreteProduct</td>
<td>具体的产品</td>
<td>具体的产品</td>
</tr>
<tr>
<td>ConcreteFactory</td>
<td>具体的工厂</td>
<td>负责生成具体的产品</td>
</tr>
</tbody></table>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><ul>
<li><a href="/2020/07/07/9773/">单例模式</a><br>在多数情况下工厂类(或具体的工厂类)可以使用单例模式创建</li>
<li><a href="/2020/07/08/48350/">组合模式</a><br>有时可以将组合模式用于 Product 角色(或是 ConcreteProduct 角色)</li>
<li><a href="/2020/07/08/10595/">模板方法模式</a><br>工厂方法模式是模板方法模式的典型应用</li>
<li><a href="/2020/07/08/14077/">迭代器模式</a><br>有时在迭代器模式中用到的 iterator 方法生成 Iterator 的实例时会使用工厂方法模式</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(1)：单例模式</title>
    <url>/2020/07/07/9773/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法</p>
<ul>
<li>优点：<ul>
<li>在内存中只有一个实例，减少了内存开销</li>
<li>避免对资源的多重占用，如写文件操作</li>
</ul>
</li>
<li>缺点<ul>
<li>没有接口，不能继承</li>
<li>与单一职责原则冲突，一个类应该只关心内部逻辑，而不应该关心外部如何实例化</li>
</ul>
</li>
</ul>
<h2 id="实现1：饿汉式（静态常量）"><a href="#实现1：饿汉式（静态常量）" class="headerlink" title="实现1：饿汉式（静态常量）"></a>实现1：饿汉式（静态常量）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种写法比较简单，在类装载的时候就完成了实例化。避免了线程同步问题</li>
<li>没有实现懒加载，如果没有用到这个实例则会造成内存的浪费</li>
</ul>
<h2 id="实现2：饿汉式（静态代码块）"><a href="#实现2：饿汉式（静态代码块）" class="headerlink" title="实现2：饿汉式（静态代码块）"></a>实现2：饿汉式（静态代码块）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton02 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点与第一种相同</li>
</ul>
<h2 id="实现3：懒汉式（线程不安全）"><a href="#实现3：懒汉式（线程不安全）" class="headerlink" title="实现3：懒汉式（线程不安全）"></a>实现3：懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton03 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton03();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种写法起到了懒加载的效果，但线程不安全</li>
</ul>
<h2 id="实现4：懒汉式（线程安全，同步方法）"><a href="#实现4：懒汉式（线程安全，同步方法）" class="headerlink" title="实现4：懒汉式（线程安全，同步方法）"></a>实现4：懒汉式（线程安全，同步方法）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton04 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton04 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton04();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决了线程不安全的问题</li>
<li>效率非常低，每次获取实例时都要进行同步，实际上只需要执行一次实例化代码就行了，后续获取实例时直接返回就行</li>
</ul>
<h2 id="实现5：双重检查"><a href="#实现5：双重检查" class="headerlink" title="实现5：双重检查"></a>实现5：双重检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton05 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton05 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton05<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton05();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程安全，懒加载，效率较高，推荐使用</li>
</ul>
<h2 id="实现6：静态内部类"><a href="#实现6：静态内部类" class="headerlink" title="实现6：静态内部类"></a>实现6：静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton06 instance = <span class="keyword">new</span> Singleton06();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton06 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态内部类在只会在第一次加载类的时候初始化，JVM帮我们保证了线程的安全</li>
<li>线程安全，懒加载，效率较高，推荐使用</li>
</ul>
<h2 id="实现7：枚举"><a href="#实现7：枚举" class="headerlink" title="实现7：枚举"></a>实现7：枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton07 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不仅避免了多线程同步问题，还能防止反序列化重新创建新的对象</li>
<li>推荐使用</li>
</ul>
<h2 id="单例模式中的角色"><a href="#单例模式中的角色" class="headerlink" title="单例模式中的角色"></a>单例模式中的角色</h2><ul>
<li>Singleton<br>在单例模式中，只有 Singleton 这一个角色。该角色中有一个返回唯一实例的静态方法。该方法总是会返回同一个实例</li>
</ul>
<h2 id="相关的设计模式"><a href="#相关的设计模式" class="headerlink" title="相关的设计模式"></a>相关的设计模式</h2><p>在以下模式中，多数情况下只会生成一个实例</p>
<ul>
<li><a href="/2020/07/08/45054/">抽象工厂模式</a></li>
<li><a href="/2020/07/08/55455/">原型模式</a></li>
<li><a href="/2020/07/08/20259/">建造者模式</a></li>
<li><a href="/2020/07/08/52857/">外观模式</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码分析(7)：ConfigurationClassBeanDefinitionReader 加载 bean 定义</title>
    <url>/2020/05/09/35542/</url>
    <content><![CDATA[<h2 id="ConfigurationClassBeanDefinitionReader-加载-bean-定义"><a href="#ConfigurationClassBeanDefinitionReader-加载-bean-定义" class="headerlink" title="ConfigurationClassBeanDefinitionReader 加载 bean 定义"></a>ConfigurationClassBeanDefinitionReader 加载 bean 定义</h2><p>遍历所有的 <code>ConfigurationClass</code>，加载 bean 定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</span><br><span class="line">    TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</span><br><span class="line">    <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">        loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="loadBeanDefinitionsForConfigurationClass"><a href="#loadBeanDefinitionsForConfigurationClass" class="headerlink" title="loadBeanDefinitionsForConfigurationClass"></a>loadBeanDefinitionsForConfigurationClass</h2><p>从 <code>ConfigurationClass</code> 中获取 bean 名字，如果发现是条件过滤的且注册器里有相关 bean 定义，就要删除。然后处理是被 <code>@Import</code> 进来的，处理 <code>@Bean</code> 注解的方法，处理 <code>ImportedResources</code> 和 <code>ImportBeanDefinitionRegistrar</code> 接口实现类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发现是条件过滤的且注册器里有相关bean定义，就要删除</span></span><br><span class="line">    <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">        String beanName = configClass.getBeanName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是@Import进来的</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">        registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理@Bean注解的方法</span></span><br><span class="line">    <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">        loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理ImportedResources和ImportBeanDefinitionRegistrar接口实现类</span></span><br><span class="line">    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码分析(6)：ConfigurationClassPraser 解析验证配置类</title>
    <url>/2020/05/09/21695/</url>
    <content><![CDATA[<h2 id="ConfigurationClassPraser-的-prase"><a href="#ConfigurationClassPraser-的-prase" class="headerlink" title="ConfigurationClassPraser 的 prase"></a>ConfigurationClassPraser 的 prase</h2><p><code>ConfigurationClassPraser</code> 的 <code>prase</code> 方法用于解析配置类。首先遍历传入的配置类集合，先判断是否是注解类型的，然后是有 <code>Class</code> 对象的，最后是只有名字的。然后根据获取相应的数据进行解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// 注解类型</span></span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                <span class="comment">// 有 class 对象</span></span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 只有 name</span></span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种 <code>prase</code> 方法的内部都是把 <code>beanName</code> 封装成 <code>ConfigurationClass</code> 对象的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 className 和 beanName 解析配置文件，需要去 URL 加载字节码，所以有读取元数据</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(@Nullable String className, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Assert.notNull(className, <span class="string">"No bean class name for configuration class bean definition"</span>);</span><br><span class="line">    MetadataReader reader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(reader, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 Class 对象，根据 Class 和 beanName 解析配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Class&lt;?&gt; clazz, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(clazz, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有注解元数据，根据注解元数据和 beanName 解析配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConfigurationClassPraser-的-processConfigurationClass"><a href="#ConfigurationClassPraser-的-processConfigurationClass" class="headerlink" title="ConfigurationClassPraser 的 processConfigurationClass"></a>ConfigurationClassPraser 的 processConfigurationClass</h2><p>首先会获取并判断有没有 <code>ConfigurationClass</code> 存在，如果有的话看新的是不是 <code>@Import</code> 注解进来的，如果不是直接把老的删了，如果是就看老的是不是 <code>@Import</code> 注解进来的，是的话就跟老的合并，不是的话就忽略新的直接返回。然后把 <code>ConfigurationClass</code> 包装下，里面有原始 <code>Class</code> 对象和元数据。然后在进行处理，这里有个循环，递归处理 <code>ConfigurationClass</code> 及其父类，返回的父类又会当做新的 <code>sourceClass</code> 传进去，知道最后是 java 内部的类为止，最后把 <code>ConfigurationClass</code> 放入集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 有条件注解不满足的返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表在存在的 ConfigurationClass</span></span><br><span class="line">    ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">            <span class="comment">// 如果老的和新的都是 @Import 的，就合并</span></span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除老的</span></span><br><span class="line">            <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">            <span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line">            <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 configClass 源类，包装原始的类和元数据</span></span><br><span class="line">    SourceClass sourceClass = asSourceClass(configClass, filter);</span><br><span class="line">    <span class="comment">// 处理配置类，如果有父类(不是 java 开头的类)继续处理，直到没有为止</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入集合</span></span><br><span class="line">    <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConfigurationClassPraser-的-doProcessConfigurationClass"><a href="#ConfigurationClassPraser-的-doProcessConfigurationClass" class="headerlink" title="ConfigurationClassPraser 的 doProcessConfigurationClass"></a>ConfigurationClassPraser 的 doProcessConfigurationClass</h2><p>方法比较复杂，部分后面会详细说明</p>
<h3 id="处理内部类"><a href="#处理内部类" class="headerlink" title="处理内部类"></a>处理内部类</h3><p>如果注解了 <code>@Component</code>，那么会处理内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理 @Component 注解</span></span><br><span class="line"><span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理内部类，解决循环 import</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass, filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理-PropertySource"><a href="#处理-PropertySource" class="headerlink" title="处理 @PropertySource"></a>处理 @PropertySource</h3><p>这个和我们的环境配置文件相关，暂时不是重点</p>
<h3 id="处理-ComponentScans"><a href="#处理-ComponentScans" class="headerlink" title="处理 @ComponentScans"></a>处理 @ComponentScans</h3><p>获取 <code>ComponentScan</code> 注解，然后解析成<code>bean</code>定义，最后递归处理配置类</p>
<h3 id="处理-Import"><a href="#处理-Import" class="headerlink" title="处理 @Import"></a>处理 @Import</h3><p>这里包括<code>Import，ImportSelector</code>注解和<code>ImportBeanDefinitionRegistrar</code>接口实现类，会将解析出来的都添加到<code>ConfigurationClass</code>里</p>
<h3 id="处理-Bean-注解的方法"><a href="#处理-Bean-注解的方法" class="headerlink" title="处理 @Bean 注解的方法"></a>处理 @Bean 注解的方法</h3><p>将 <code>bean</code> 注解的方法添加到 <code>ConfigurationClass</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理 @Bean 注解的方法</span></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">    <span class="comment">// 添加 bean 注解的方法到 configClass</span></span><br><span class="line">    configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理接口的默认实现方法"><a href="#处理接口的默认实现方法" class="headerlink" title="处理接口的默认实现方法"></a>处理接口的默认实现方法</h3><p>处理接口的默认实现方法，也是进行接口的递归检查</p>
<h3 id="处理父类"><a href="#处理父类" class="headerlink" title="处理父类"></a>处理父类</h3><p>有可能父类还有注解定义，所以要寻找父类，直到 <code>Java</code> 开头的父类，也就是要递归处理自定义的父类，把父类返回，然后外面继续处理父类</p>
<h2 id="ConfigurationClassPraser-的-validate"><a href="#ConfigurationClassPraser-的-validate" class="headerlink" title="ConfigurationClassPraser 的 validate"></a>ConfigurationClassPraser 的 validate</h2><p>这里涉及一个 CGLIB 动态代理的条件问题，CGLIB 的代理原理是继承目标类，覆盖相应的方法，可能开业一些方法拦截器，所以对类和方法是有要求的。这里遍历配置类进行验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有配置类进行验证</span></span><br><span class="line">    <span class="keyword">for</span> (ConfigurationClass configClass : <span class="keyword">this</span>.configurationClasses.keySet()) &#123;</span><br><span class="line">        configClass.validate(<span class="keyword">this</span>.problemReporter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConfigurationClass-的-validate"><a href="#ConfigurationClass-的-validate" class="headerlink" title="ConfigurationClass 的 validate"></a>ConfigurationClass 的 validate</h3><p>具体的验证由 <code>ConfigurationClass</code> 自身的方法完成的。验证元数据中有没有 <code>final</code> 修饰类，因为 <code>final</code> 修饰的类是不可被继承的，同时验证下所有的 bean 方法是可以覆盖的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(ProblemReporter problemReporter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是proxyBeanMethods=true，默认用CGLIB做代理，是继承的，所以不可以为final</span></span><br><span class="line">    Map&lt;String, Object&gt; attributes = <span class="keyword">this</span>.metadata.getAnnotationAttributes(Configuration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    <span class="keyword">if</span> (attributes != <span class="keyword">null</span> &amp;&amp; (Boolean) attributes.get(<span class="string">"proxyBeanMethods"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 配置类不能为final</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.metadata.isFinal()) &#123;</span><br><span class="line">            problemReporter.error(<span class="keyword">new</span> FinalConfigurationProblem());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bean方法必须可覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (BeanMethod beanMethod : <span class="keyword">this</span>.beanMethods) &#123;</span><br><span class="line">            beanMethod.validate(problemReporter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanMethod-的-validate"><a href="#BeanMethod-的-validate" class="headerlink" title="BeanMethod 的 validate"></a>BeanMethod 的 validate</h3><p>如果是静态方法的话没关系，否则要判断是否可覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(ProblemReporter problemReporter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getMetadata().isStatic()) &#123;</span><br><span class="line">        <span class="comment">// 静态方法属于类的，不管</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.configurationClass.getMetadata().isAnnotated(Configuration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">        <span class="comment">// bean方法必须可覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (!getMetadata().isOverridable()) &#123;</span><br><span class="line">            problemReporter.error(<span class="keyword">new</span> NonOverridableMethodError());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码分析(5)：ConfigurationClassPostProcessor 处理配置类</title>
    <url>/2020/05/08/40116/</url>
    <content><![CDATA[<h2 id="invokeBeanDefinitionRegistryPostProcessors-调用处理器方法"><a href="#invokeBeanDefinitionRegistryPostProcessors-调用处理器方法" class="headerlink" title="invokeBeanDefinitionRegistryPostProcessors 调用处理器方法"></a>invokeBeanDefinitionRegistryPostProcessors 调用处理器方法</h2><p>后置处理器创建出来了，然后遍历所有的处理器进行处理(自己扩展的和默认的 <code>ConfigurationClassPostProcessor</code>)，默认的处理器优先级定义为了最低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConfigurationClassPostProcessor-中的处理"><a href="#ConfigurationClassPostProcessor-中的处理" class="headerlink" title="ConfigurationClassPostProcessor 中的处理"></a>ConfigurationClassPostProcessor 中的处理</h2><p>先检查是否已经处理过，在调用 <code>processConfigBeanDefinitions</code> 处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">    <span class="comment">// 判断是否已经处理过了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加到 registriesPostProcessed，表示已经处理过了</span></span><br><span class="line">    <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processConfigBeanDefinitions-建立和基于注册表验证配置模型Configuration类"><a href="#processConfigBeanDefinitions-建立和基于注册表验证配置模型Configuration类" class="headerlink" title="processConfigBeanDefinitions 建立和基于注册表验证配置模型Configuration类"></a>processConfigBeanDefinitions 建立和基于注册表验证配置模型Configuration类</h3><p>首先取出并遍历所有 bean 定义名字，判断其是否有配置属性，没有的话再判断其是否为配置类，是的话将其封装成 <code>BeanDefinitionHolder</code> 添加到 <code>configCandidates</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 获取所有 bean 定义名字</span></span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">    BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">        <span class="comment">// 把 @Configuration 注解的 bean 定义添加到 configCandidates</span></span><br><span class="line">        configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有找到配置类时直接返回</span></span><br><span class="line"><span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ConfigurationClassUtils-checkConfigurationClassCandidate"><a href="#ConfigurationClassUtils-checkConfigurationClassCandidate" class="headerlink" title="ConfigurationClassUtils.checkConfigurationClassCandidate"></a>ConfigurationClassUtils.checkConfigurationClassCandidate</h4><p>首先获取 bean 的全限定名，然后判断是否为注解类型，是的话就取出注解元数据，否则判断是否存在 <code>BeanClass</code>，有的话取它的元数据，否则用 URL 去加载类名对应的类，取出元数据。然后获取元数据上的 <code>@Configuration</code> 注解的属性，默认 <code>proxyBeanMethods=true</code>，后面会使用 <code>CGLIB</code> 动态代理增强，所有要设置一个 <code>full</code> 的属性，否则就设置 <code>lite</code> 属性。最后如果设置了 <code>Order</code> 注解就设置序号属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkConfigurationClassCandidate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取bean全限定名</span></span><br><span class="line">    String className = beanDef.getBeanClassName();</span><br><span class="line">    <span class="keyword">if</span> (className == <span class="keyword">null</span> || beanDef.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AnnotationMetadata metadata;</span><br><span class="line">    <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AnnotatedBeanDefinition &amp;&amp;</span><br><span class="line">            className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) &#123;</span><br><span class="line">        <span class="comment">// Can reuse the pre-parsed metadata from the given BeanDefinition...</span></span><br><span class="line">        <span class="comment">// 是注解类型，元数据类名跟bean类名一样</span></span><br><span class="line">        metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) &#123;</span><br><span class="line">        <span class="comment">// Check already loaded Class if present...</span></span><br><span class="line">        <span class="comment">// since we possibly can't even load the class file for this Class.</span></span><br><span class="line">        <span class="comment">// 存在BeanClass就取出来</span></span><br><span class="line">        Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();</span><br><span class="line">        <span class="keyword">if</span> (BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanClass</span>) ||</span></span><br><span class="line"><span class="class">                <span class="title">BeanPostProcessor</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanClass</span>) ||</span></span><br><span class="line"><span class="class">                <span class="title">AopInfrastructureBean</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanClass</span>) ||</span></span><br><span class="line"><span class="class">                <span class="title">EventListenerFactory</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanClass</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        metadata = AnnotationMetadata.introspect(beanClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">            metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Could not find class file for introspecting configuration annotations: "</span> +</span><br><span class="line">                        className, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取@Configuration注解的属性</span></span><br><span class="line">    Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">"proxyBeanMethods"</span>))) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="keyword">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It's a full or lite configuration candidate... Let's determine the order value, if any.</span></span><br><span class="line">    Integer order = getOrder(metadata);</span><br><span class="line">    <span class="comment">// 如果有排序，设置序号属性</span></span><br><span class="line">    <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isConfigurationCandidate-是否是配置候选类"><a href="#isConfigurationCandidate-是否是配置候选类" class="headerlink" title="isConfigurationCandidate 是否是配置候选类"></a>isConfigurationCandidate 是否是配置候选类</h4><p>加了 <code>@Configuration</code> 注解肯定是配置类，但不加也可以是配置类，有 <code>@Component</code>、<code>@ComponentScan</code>、<code>Import</code>，<code>@ImportResource</code> 任意一个注解，或者有 <code>@Bean</code> 注解的方法都可以是。只是加了<code>Configuration</code>注解后，里面有个默认 <code>proxyBeanMethods=true</code> 的属性，可以使用动态代理做增强的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    candidateIndicators.add(Component<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    candidateIndicators.add(ComponentScan<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    candidateIndicators.add(Import<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    candidateIndicators.add(ImportResource<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非接口直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找@Component、@ComponentScan、@Import，@ImportResource注解</span></span><br><span class="line">    <span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line">        <span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找@Bena注解</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Failed to introspect @Bean methods on class ["</span> + metadata.getClassName() + <span class="string">"]: "</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接上面 <code>checkConfigurationClassCandidate</code> 方法，把 <code>configCandidates</code> 排序，然后设置bean 名字生成器，一般都是默认的，然后获取环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 @Order 指定的值排序</span></span><br><span class="line">configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">    <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否有自定义的 bean name 生成器</span></span><br><span class="line">SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">    sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">        BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">                AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">        <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">            <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取环境</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建配置类解析器，开始解析。首先把配置类集合转成 <code>LinkedHashSet</code>，并创建一个 <code>ConfigurationClass</code> 的 <code>HashSet</code>存放已经解析好的配置类。然后解析配置类，解析完会进行验证，因为里面可能会进行 CGLIB 的动态代理。然后返回解析好的 <code>ConfigurationClass</code> 集合，删除已经解析过的，对解析出来的 <code>ConfigurationClass</code> 集合进行 bean 定义的加载。因为之前解析时可能会有 <code>@Component</code>、<code>@ComponentScan</code>、<code>Import</code>，<code>@ImportResource</code> 属性，所以此时会有新的 bean 定义。然后把已解析过的放入集合 <code>alreadyParsed</code>  中，然后清空 <code>candidates</code>。判断加载后的 bean 定义数量是否增加，有的话再去判断是否是配置类，是的话放到 <code>candidates</code> 中，然后继续解析，一直循环到没有新的为止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建配置类解析器解析每个 @Configuration 类</span></span><br><span class="line">ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">        <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成 LinkedHashSet</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line"><span class="comment">// 解析好了的配置类</span></span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 解析配置类集合</span></span><br><span class="line">    parser.parse(candidates);</span><br><span class="line">    <span class="comment">// 验证如果要 CGLIB 代理的话条件是否满足</span></span><br><span class="line">    parser.validate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析好了的 ConfigurationClass 集合</span></span><br><span class="line">    Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">    <span class="comment">// 删除已经解析的</span></span><br><span class="line">    configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">    <span class="comment">// 创建配置类 bean 定义读取器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载 bean 定义</span></span><br><span class="line">    <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">    <span class="comment">// 添加到已处理的集合</span></span><br><span class="line">    alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完清空</span></span><br><span class="line">    candidates.clear();</span><br><span class="line">    <span class="comment">// 如果有加载到新的 bean 定义，再继续加载</span></span><br><span class="line">    <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">        <span class="comment">// 总的名字</span></span><br><span class="line">        String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">        <span class="comment">// 处理过的的名字</span></span><br><span class="line">        Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">        Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">            <span class="comment">// 只处理新的</span></span><br><span class="line">            <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                        !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                    candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        candidateNames = newCandidateNames;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!candidates.isEmpty());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码分析(4)：invokeBeanFactoryPostProcessors</title>
    <url>/2020/05/08/31338/</url>
    <content><![CDATA[<h2 id="PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><a href="#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors" class="headerlink" title="PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors"></a>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors</h2><p>大致的执行流程：</p>
<ul>
<li>执行自定义扩展 <code>BeanDefinitionRegistryPostProcessor</code> 的方法</li>
<li>根据 bean 定义名字创建有优先级别的 <code>BeanDefinitionRegistryPostProcessor</code> 实例</li>
<li>进行优先级排序，并进行 <code>BeanDefinitionRegistryPostProcessor</code> 后置处理器处理</li>
<li><code>ConfigureClassPostProcessor</code> 的处理</li>
</ul>
<p><code>invokeBeanFactoryPostProcessors</code> 的核心代码委托给了 <code>PostProcessorRegistrationDelegate</code>。这个方法很长，所以进行分段分析。首先会定义一个集合，表示处理过的处理器名字集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示处理过的处理器名字集合</span></span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="定义处理器集合"><a href="#定义处理器集合" class="headerlink" title="定义处理器集合"></a>定义处理器集合</h3><p>定义两个处理器集合，一个是 <code>BeanFactoryPostProcessor</code> 类型的，一个是 <code>BeanDefinitionRegistryPostProcessor</code> 类型的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了两个处理器集合</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="执行扩展的-BeanFactoryPostProcessor"><a href="#执行扩展的-BeanFactoryPostProcessor" class="headerlink" title="执行扩展的 BeanFactoryPostProcessor"></a>执行扩展的 BeanFactoryPostProcessor</h3><p>这里的 <code>beanFactoryPostProcessors</code> 是外面传进来的，默认是空的，除非你自己扩展了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先处理 BeanDefinitionRegistryPostProcessor，因为这里可以自定义扩展，增加 bean 定义</span></span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">        BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        registryProcessors.add(registryProcessor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        regularPostProcessors.add(postProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如需要自己扩展时需先创建一个类实现 <code>BeanDefinitionRegistryPostProcessor</code>，并在注册配置类后执行 <code>context.addBeanFactoryPostProcessor()</code> 把它添加到后置处理器集合中，再执行 <code>refresh()</code> 刷新上下文</p>
<h3 id="创建-BeanDefinitionRegistryPostProcessor-类型的处理器"><a href="#创建-BeanDefinitionRegistryPostProcessor-类型的处理器" class="headerlink" title="创建 BeanDefinitionRegistryPostProcessor 类型的处理器"></a>创建 BeanDefinitionRegistryPostProcessor 类型的处理器</h3><p>这个也就是获取创建的时候内部添加的 <code>BeanDefinitionRegistryPostProcessor</code> 后置处理器，其实就是从 bean 工厂的 <code>beanDefinitionNames</code> 里获取相应的名字，然后先创建 <code>PriorityOrdered</code> 优先排序的处理器，放入 <code>currentRegistryProcessors</code> 集合里。名字放入最开始的 <code>processedBeans</code> 中，表示处理过了</p>
<p>如果没有自定义扩展，那么就是获取  <code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code>，对应的类是 <code>ConfigurationClassPostProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取创建的时候内部添加的 BeanDefinitionRegistryPostProcessor 后置处理器</span></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">// 先创建 PriorityOrdered 优先排序的处理器，放入 currentRegistryProcessors 集合里</span></span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="comment">// 名字放入最开始的 processedBeans 中表示处理过了</span></span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如需要自己扩展时需先创建一个类实现 <code>BeanDefinitionRegistryPostProcessor</code> 和 <code>PriorityOrdered</code>，并在上面自己扩展的 <code>BeanFactoryPostProcessor</code> 的 <code>postProcessBeanDefinitionRegistry</code> 方法中调用 <code>registry.registerBeanDefinition</code> 注册该类的 bean 定义</p>
<h3 id="将创建出来的处理器排序，准备处理"><a href="#将创建出来的处理器排序，准备处理" class="headerlink" title="将创建出来的处理器排序，准备处理"></a>将创建出来的处理器排序，准备处理</h3><p>前面我们已经将 <code>BeanDefinitionRegistryPostProcessor</code> 类型，且是 <code>PriorityOrdered</code> 优先级的创建出来了，里面还能自己扩展，然后要进行排序，因为有多个，这样可以调整顺序，很灵活，内部的 <code>ConfigurationClassPostProcessor</code> 默认是优先级最低的 <code>Ordered.LOWEST_PRECEDENCE</code></p>
<p>这里还会进行已注册的处理器合并，一个是我们自己创建添加进去的，一个是扩展方法注册 bean 定义进去的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序，有自定义的处理器可以控制执行顺序</span></span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"><span class="comment">// 合并自定义的和 spring 内部的</span></span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// 处理 bean 定义注册后置处理器</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码分析(3)：AnnotationConfigApplicationContext 注册配置类与刷新</title>
    <url>/2020/05/07/46014/</url>
    <content><![CDATA[<h2 id="register-componentClasses-注册配置类"><a href="#register-componentClasses-注册配置类" class="headerlink" title="register(componentClasses) 注册配置类"></a>register(componentClasses) 注册配置类</h2><p>前面注解读取器和类扫描器创建完成了，接下来就是对我们传入的配置类进行解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(componentClasses, <span class="string">"At least one component class must be specified"</span>);</span><br><span class="line">    <span class="keyword">this</span>.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnnotatedBeanDefinitionReader-的-register-componentClasses"><a href="#AnnotatedBeanDefinitionReader-的-register-componentClasses" class="headerlink" title="AnnotatedBeanDefinitionReader 的 register(componentClasses)"></a>AnnotatedBeanDefinitionReader 的 register(componentClasses)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">        registerBean(componentClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(beanClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnnotatedBeanDefinitionReader-的-doRegisterBean-注册配置类"><a href="#AnnotatedBeanDefinitionReader-的-doRegisterBean-注册配置类" class="headerlink" title="AnnotatedBeanDefinitionReader 的 doRegisterBean 注册配置类"></a>AnnotatedBeanDefinitionReader 的 doRegisterBean 注册配置类</h3><p>这里完成了一个配置类的注册。首先根据配置类创建一个通用注解 bean 定义；然后进行条件判断，从 bean 定义解析范围，并设置范围；然后获得 bean 的名字，处理通用注解，如 <code>@Lazy</code>、<code>@Primary</code>、<code>@DependsOn</code>等；如果有自定义 <code>BeanDefinitionCustomizer</code> 的话就会进行回调。最后将 bean 名字和 bean 定义封装成 <code>BeanDefinitionHolder</code>，方便处理，同时会根据注解的代理信息看是否要进行代理，最后注册到注册器里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                                @Nullable BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 AnnotatedGenericBeanDefinition 对象</span></span><br><span class="line">    AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abd.setInstanceSupplier(supplier);</span><br><span class="line">    ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">    <span class="comment">// 获取 bean 的名字</span></span><br><span class="line">    String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">    <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Primary<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">                abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Lazy<span class="class">.<span class="keyword">class</span> </span>== qualifier) &#123;</span><br><span class="line">                abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有自定义 BeanDefinitionCustomizer 的话就会进行回调</span></span><br><span class="line">    <span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">            customizer.customize(abd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 bean 名字和 bean 定义封装成 BeanDefinitionHolder</span></span><br><span class="line">    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="refresh-刷新"><a href="#refresh-刷新" class="headerlink" title="refresh 刷新"></a>refresh 刷新</h2><p>最为核心的方法，是整个 spring 的加载流程</p>
<h3 id="prepareRefresh-预处理"><a href="#prepareRefresh-预处理" class="headerlink" title="prepareRefresh 预处理"></a>prepareRefresh 预处理</h3><p>设置一些参数和监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录启动时间</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 设置关闭为 false、开启为 true</span></span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空函数，留给子类覆盖，用户可通过重写此方法进行个性化的属性处理和设置</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证所有所需的属性文件是否都已放入环境中</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 ApplicationEvent 集合，因为此时 ApplicationMulticaster 还没创建好</span></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="obtainFreshBeanFactory-获得BeanFactory"><a href="#obtainFreshBeanFactory-获得BeanFactory" class="headerlink" title="obtainFreshBeanFactory 获得BeanFactory"></a>obtainFreshBeanFactory 获得BeanFactory</h3><p>进行刷新标志的位置，然后返回 <code>DefaultListableBeanFactory</code> 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 BeanFactory，并进行 xml 文件读取，并将得到的 BeanFactory 记录在当前实体的属性中</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 返回当前实体的 beanFactory 属性</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="refreshBeanFactory"><a href="#refreshBeanFactory" class="headerlink" title="refreshBeanFactory"></a>refreshBeanFactory</h3><p>原子操作，支持单线程刷新，设置一个序列化 id</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="prepareBeanFactory-预处理-BeanFactory"><a href="#prepareBeanFactory-预处理-BeanFactory" class="headerlink" title="prepareBeanFactory 预处理 BeanFactory"></a>prepareBeanFactory 预处理 BeanFactory</h3><p>对 <code>BeanFactory</code> 进行预处理，如设置加载器、表达式解释器、添加 <code>BeanPostProcessor</code> 后置处理器 <code>ApplicationContextAwareProcessor</code>，此时才是第一个后置处理器，然后忽略一些接口，然后是一些依赖对象设置，然后添加了 <code>ApplicationListenerDetector</code> 后置处理器，最后注册一些单例，如环境、系统属性等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 beanFactory 的 classLoader 为当前 context 的 classLoader</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="comment">// 设置 beanFactory 的表达式语言处理器</span></span><br><span class="line">    <span class="comment">// spring3 开始增加了表达式语言的支持，默认可使用 #&#123;xx&#125; 的形式来调用相关属性值</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    <span class="comment">// 设置 beanFactory 的属性编辑器</span></span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 beanFactory 添加一个后处理器 BeanPostProcessor</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 设置几个忽略自动装配的依赖的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为在spring中增加了 ApplicationContextAwareProcessor(它是 BeanProcessor 类型)</span></span><br><span class="line">    <span class="comment">// 在其 postProcessBeforeInitialization() 中间接调用的 Aware 类已不再是普通的bean</span></span><br><span class="line">    <span class="comment">// 而是 EnvironmentAware、EmbeddedValueResolverAware...ApplicationContextAware</span></span><br><span class="line">    <span class="comment">// 故需要在spring做bean的依赖注入时忽略这些类型的 bean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 凡注册到 Spring 容器内的bean，实现了 EnvironmentAware 接口重写 setEnvironment 方法后</span></span><br><span class="line">    <span class="comment">// 在工程启动时可以获取 application.properties 的配置文件配置的属性值</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置几个自动装配的特殊规则</span></span><br><span class="line">    <span class="comment">// 注入了依赖解析后，注入 bean 的属性时，一旦检测到属性为某种特殊的类型时，便会将相应的实例注入进去</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 BeanFactory 的后处理器 BeanPostProcessor</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里增加了对 AspectJ 的支持</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// 增加 LoadTimeWeaverAwareProcessor</span></span><br><span class="line">        <span class="comment">// 因为 prepareBeanFactory() 是在容器初始化时调用</span></span><br><span class="line">        <span class="comment">// 即只有注册了 LoadTimeWeaverAwareProcessor 才会激活 AspectJ 的功能</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册默认的系统环境 beans，且是以单例模式进行注册</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="invokeBeanFactoryPostProcessors-调用-BeanFactory-后置处理器"><a href="#invokeBeanFactoryPostProcessors-调用-BeanFactory-后置处理器" class="headerlink" title="invokeBeanFactoryPostProcessors 调用 BeanFactory 后置处理器"></a>invokeBeanFactoryPostProcessors 调用 BeanFactory 后置处理器</h3><p>这个是关键，开始要执行后置处理器，来处理我们的 bean 定义了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码分析(2)：BeanDefinition</title>
    <url>/2020/05/07/4689/</url>
    <content><![CDATA[<h2 id="Bean-定义"><a href="#Bean-定义" class="headerlink" title="Bean 定义"></a>Bean 定义</h2><p>我们会频繁地与 bean 打交道，所以先要知道什么是 bean 定义、定义了什么。以下是一些相关的接口和类</p>
<h3 id="BeanMetadataElement-元数据接口"><a href="#BeanMetadataElement-元数据接口" class="headerlink" title="BeanMetadataElement 元数据接口"></a>BeanMetadataElement 元数据接口</h3><p>首先我们要能获得元数据，也就是这个 bean 是来自哪个对象的，就可以获得一些相关的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanMetadataAttribute-元数据属性"><a href="#BeanMetadataAttribute-元数据属性" class="headerlink" title="BeanMetadataAttribute 元数据属性"></a>BeanMetadataAttribute 元数据属性</h3><p>实现了元数据接口，增加了属性的名字和值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMetadataAttribute</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性值</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 的来源</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Object source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的AttributeValue实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanMetadataAttribute</span><span class="params">(String name, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(name, <span class="string">"Name must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AttributeAccessor-属性访问器"><a href="#AttributeAccessor-属性访问器" class="headerlink" title="AttributeAccessor 属性访问器"></a>AttributeAccessor 属性访问器</h3><p>该接口定义的属性的操作：增删改查、获取所有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeAccessor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, @Nullable Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">Object <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">   String[] attributeNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AttributeAccessorSupport-属性访问抽象实现类"><a href="#AttributeAccessorSupport-属性访问抽象实现类" class="headerlink" title="AttributeAccessorSupport 属性访问抽象实现类"></a>AttributeAccessorSupport 属性访问抽象实现类</h3><p>这个是对 <code>AttributeAccessor</code> 接口的抽象实现，它定义了一个 map 来存放名字和属性的映射关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AttributeAccessorSupport</span> <span class="keyword">implements</span> <span class="title">AttributeAccessor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 名字和属性的对应</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(name, <span class="string">"Name must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(name, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAttribute(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(name, <span class="string">"Name must not be null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attributes.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(name, <span class="string">"Name must not be null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attributes.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(name, <span class="string">"Name must not be null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attributes.containsKey(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] attributeNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(<span class="keyword">this</span>.attributes.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性的复制</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">copyAttributesFrom</span><span class="params">(AttributeAccessor source)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(source, <span class="string">"Source must not be null"</span>);</span><br><span class="line">        String[] attributeNames = source.attributeNames();</span><br><span class="line">        <span class="keyword">for</span> (String attributeName : attributeNames) &#123;</span><br><span class="line">            setAttribute(attributeName, source.getAttribute(attributeName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanMetadataAttributeAccessor-元数据属性访问器"><a href="#BeanMetadataAttributeAccessor-元数据属性访问器" class="headerlink" title="BeanMetadataAttributeAccessor 元数据属性访问器"></a>BeanMetadataAttributeAccessor 元数据属性访问器</h3><p>既能获取元数据，也能提供属性访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMetadataAttributeAccessor</span> <span class="keyword">extends</span> <span class="title">AttributeAccessorSupport</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bean 的元数据对象</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Object source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSource</span><span class="params">(@Nullable Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加进来的就是 BeanMetadataAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMetadataAttribute</span><span class="params">(BeanMetadataAttribute attribute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setAttribute(attribute.getName(), attribute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得之后都会转成 BeanMetadataAttribute</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanMetadataAttribute <span class="title">getMetadataAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (BeanMetadataAttribute) <span class="keyword">super</span>.getAttribute(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setAttribute(name, <span class="keyword">new</span> BeanMetadataAttribute(name, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        BeanMetadataAttribute attribute = (BeanMetadataAttribute) <span class="keyword">super</span>.getAttribute(name);</span><br><span class="line">        <span class="keyword">return</span> (attribute != <span class="keyword">null</span> ? attribute.getValue() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        BeanMetadataAttribute attribute = (BeanMetadataAttribute) <span class="keyword">super</span>.removeAttribute(name);</span><br><span class="line">        <span class="keyword">return</span> (attribute != <span class="keyword">null</span> ? attribute.getValue() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p><code>BeanDefinition</code> 是 spring 对 bean 的抽象。它定义了这个 bean 的来源、属性的操作还有一些其它的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例字符串 singleton</span></span><br><span class="line">    String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原型字符串 prototype</span></span><br><span class="line">    String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 bean 名字</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置范围</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable String scope)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置是否懒加载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置需要预加载的依赖的类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置是否适合给其他类做自动装配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置是否优先自动装配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 FactoryBean 的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取构造函数的参数</span></span><br><span class="line">    <span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInitMethodName</span><span class="params">(@Nullable String initMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置销毁时的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDestroyMethodName</span><span class="params">(@Nullable String destroyMethodName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanDefinition-的实现"><a href="#BeanDefinition-的实现" class="headerlink" title="BeanDefinition 的实现"></a>BeanDefinition 的实现</h2><p>以下是一些 <code>BeanDefinition</code> 的实现类</p>
<h3 id="AbstractBeanDefinition-抽象实现"><a href="#AbstractBeanDefinition-抽象实现" class="headerlink" title="AbstractBeanDefinition 抽象实现"></a>AbstractBeanDefinition 抽象实现</h3><p>它继承了上面的 bean 元数据访问器 <code>BeanMetadataAttributeAccessor</code> 并且实现了 bean 定义接口 <code>BeanDefinition</code>，这样的话使得 bean 的元数据和定义接口联系起来了，也就是数据和操作结合了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BeanDefinition</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this.beanClasses 是对象，可以是 String 也可以是 Class</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object beanClassObject = <span class="keyword">this</span>.beanClass;</span><br><span class="line">        <span class="keyword">if</span> (beanClassObject <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Class&lt;?&gt;) beanClassObject).getName();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) beanClassObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以传 Class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClass</span><span class="params">(@Nullable Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 beanClass 是否是个 Class 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.beanClass <span class="keyword">instanceof</span> Class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义了一个克隆的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractBeanDefinition <span class="title">cloneBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GenericBeanDefinition-标准-bean-定义"><a href="#GenericBeanDefinition-标准-bean-定义" class="headerlink" title="GenericBeanDefinition 标准 bean 定义"></a>GenericBeanDefinition 标准 bean 定义</h3><p>增加了一个父类名字，实现了抽象克隆方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericBeanDefinition</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> String parentName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">cloneBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericBeanDefinition(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnnotatedBeanDefinition-注解-bean-定义"><a href="#AnnotatedBeanDefinition-注解-bean-定义" class="headerlink" title="AnnotatedBeanDefinition 注解 bean 定义"></a>AnnotatedBeanDefinition 注解 bean 定义</h3><p>加了两个新方法，用于获取注解的元数据和工厂方法的元数据，这些数据在进行解析处理的时候需要用到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="function">AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">MethodMetadata <span class="title">getFactoryMethodMetadata</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnnotatedGenericBeanDefinition-标准注解-bean-定义"><a href="#AnnotatedGenericBeanDefinition-标准注解-bean-定义" class="headerlink" title="AnnotatedGenericBeanDefinition 标准注解 bean 定义"></a>AnnotatedGenericBeanDefinition 标准注解 bean 定义</h3><p>将通用 bean 定义 <code>GenericBeanDefinition</code> 和注解 bean 定义 <code>AnnotatedBeanDefinition</code> 拼起来了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedGenericBeanDefinition</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">GenericBeanDefinition</span> <span class="keyword">implements</span> <span class="title">AnnotatedBeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解元数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法源数据</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> MethodMetadata factoryMethodMetadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过beanClass来获取元数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedGenericBeanDefinition</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">        setBeanClass(beanClass);</span><br><span class="line">        <span class="keyword">this</span>.metadata = AnnotationMetadata.introspect(beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过注解元数据来获取beanClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedGenericBeanDefinition</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(metadata, <span class="string">"AnnotationMetadata must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (metadata <span class="keyword">instanceof</span> StandardAnnotationMetadata) &#123;</span><br><span class="line">            setBeanClass(((StandardAnnotationMetadata) metadata).getIntrospectedClass());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setBeanClassName(metadata.getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.metadata = metadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过注解元数据和方法元数据创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedGenericBeanDefinition</span><span class="params">(AnnotationMetadata metadata, MethodMetadata factoryMethodMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(metadata);</span><br><span class="line">        Assert.notNull(factoryMethodMetadata, <span class="string">"MethodMetadata must not be null"</span>);</span><br><span class="line">        setFactoryMethodName(factoryMethodMetadata.getMethodName());</span><br><span class="line">        <span class="keyword">this</span>.factoryMethodMetadata = factoryMethodMetadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.metadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MethodMetadata <span class="title">getFactoryMethodMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.factoryMethodMetadata;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RootBeanDefinition-合并-bean-定义"><a href="#RootBeanDefinition-合并-bean-定义" class="headerlink" title="RootBeanDefinition 合并 bean 定义"></a>RootBeanDefinition 合并 bean 定义</h3><p>这个主要是将很多其他类型的 <code>BeanDefinition</code> 在运行时合并起来，具体的用法后面会说，现在只要知道基本内部的定义都是用这个的</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码分析(1)：AnnotationConfigApplicationContext</title>
    <url>/2020/05/07/12312/</url>
    <content><![CDATA[<h2 id="简单注解配置"><a href="#简单注解配置" class="headerlink" title="简单注解配置"></a>简单注解配置</h2><p>首先创建一个配置类 <code>MyConfig</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写一个测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context =</span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AnnotationConfigApplicationContext-注解配置上下文"><a href="#AnnotationConfigApplicationContext-注解配置上下文" class="headerlink" title="AnnotationConfigApplicationContext 注解配置上下文"></a>AnnotationConfigApplicationContext 注解配置上下文</h2><p>看名字可以知道它是注解配置的上下文，也就是一个环境，可以处理我们传进去的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// 注册传入的配置类</span></span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">// 最为核心的方法，spring的加载流程</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在父类 <code>GenericApplicationContext</code>中创建了一个 <code>DefaultListableBeanFactory</code>，也就是后面一直要用到的 <strong>bean 工厂</strong>，里面放着所有与 bean 相关的东西，比如 bean 的定义、bean 的后置处理器等</p>
<p>然后再创建了 <code>AnnotatedBeanDefinitionReader</code>(注解 bean 定义读取器) 和 <code>ClassPathBeanDefinitionScanner</code>(bean 定义的扫描器)。这里要注意 <code>ClassPathBeanDefinitionScanner</code> 其实是提供给用户的，并不是他内部使用，内部后面会再创建一个来用</p>
<h2 id="AnnotatedBeanDefinitionReader-读取器"><a href="#AnnotatedBeanDefinitionReader-读取器" class="headerlink" title="AnnotatedBeanDefinitionReader 读取器"></a>AnnotatedBeanDefinitionReader 读取器</h2><p>这个构造方法传入的是一个 <code>BeanDefinitionRegistry</code>，就是可以注册 bean 定义的，内部注册就需要用到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getOrCreateEnvironment-获取或创建环境"><a href="#getOrCreateEnvironment-获取或创建环境" class="headerlink" title="getOrCreateEnvironment 获取或创建环境"></a>getOrCreateEnvironment 获取或创建环境</h3><p>如果 <code>BeanDefinitionRegistry</code> 是 <code>EnvironmentCapable</code> 的话就直接获取，否则创建一个标准环境，其实就是获取一些系统的变量。比如可以配置 dev、test、prod 环境等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Environment <span class="title">getOrCreateEnvironment</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> EnvironmentCapable) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((EnvironmentCapable) registry).getEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnnotatedBeanDefinitionReader-构造方法"><a href="#AnnotatedBeanDefinitionReader-构造方法" class="headerlink" title="AnnotatedBeanDefinitionReader 构造方法"></a>AnnotatedBeanDefinitionReader 构造方法</h3><p>对 <code>BeanDefinitionRegistry</code> 进行了保存，把 <code>environment</code> 封装进了 <code>ConditionEvaluator</code>，<code>ConditionEvaluator</code> 可以理解为一个条件过滤器，与 <code>@Conditional</code> 有关，如果有了这个注解，就先判断条件是否成立，不成立的话有些操作就不做了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">    Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>这三个属性后面还会用到，bean 的名字生成器 <code>BeanNameGenerator</code>，可以自定义怎么生成 bean 的名字，默认是简单类名首字母小写；范围注解解析器 <code>ScopeMetadataResolver</code>，解析 bean 的范围；条件评估器 <code>ConditionEvaluator</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanNameGenerator beanNameGenerator = AnnotationBeanNameGenerator.INSTANCE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ScopeMetadataResolver scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConditionEvaluator conditionEvaluator;</span><br></pre></td></tr></table></figure>

<h3 id="AnnotationConfigUtils-registerAnnotationConfigProcessors-this-registry-注册注解配置处理器"><a href="#AnnotationConfigUtils-registerAnnotationConfigProcessors-this-registry-注册注解配置处理器" class="headerlink" title="AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry) 注册注解配置处理器"></a>AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry) 注册注解配置处理器</h3><p>这个一看方法就知道要加一些处理器，来处理我们的注解，也就是说，spring 有些内部的处理器需要注册进来，这里可以想 spring 应该是为了统一处理处理器，所以也是按注册，处理这样的流程来，无论是自己内部的，还是用户自定义的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    registerAnnotationConfigProcessors(registry, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程就是获取 <code>DefaultListableBeanFactory</code>，然后注册 <code>AnnotationAwareOrderComparator</code> 顺序比较器，用于排序，<code>ContextAnnotationAutowireCandidateResolver</code> 自动装配解析器，解析自动装配相关配置用。然后创建一些后置处理器 bean 定义，内部一般用 <code>RootBeanDefinition</code> 来定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 beanFactory</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 BeanDefinitionHolder 集合</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConfigurationClassPostProcessor 后置处理器</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AutowiredAnnotationBeanPostProcessor 自动装配注解处理器</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                    AnnotationConfigUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()))</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EventListenerMethodProcessor 时间监听方法处理器</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DefaultEventListenerFactory 默认事件监听器工厂</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnnotationConfigUtils-的-registerPostProcessor-注册后置处理器"><a href="#AnnotationConfigUtils-的-registerPostProcessor-注册后置处理器" class="headerlink" title="AnnotationConfigUtils 的 registerPostProcessor 注册后置处理器"></a>AnnotationConfigUtils 的 registerPostProcessor 注册后置处理器</h3><p>注册后置处理器，其实是注册对应的 bean 定义，对应一些内部处理的 bean 定义，会设置角色属性 <code>setRole</code>，然后向 <code>registry</code> 里注册 beanName 和 bean 定义，最后封装成 <code>BeanDefinitionHolder</code> 返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinitionHolder <span class="title">registerPostProcessor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(beanName, definition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(definition, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GenericApplicationContext-的-registerBeanDefinition-注册-bean-定义"><a href="#GenericApplicationContext-的-registerBeanDefinition-注册-bean-定义" class="headerlink" title="GenericApplicationContext 的 registerBeanDefinition 注册 bean 定义"></a>GenericApplicationContext 的 registerBeanDefinition 注册 bean 定义</h3><p>可以看到，这里出现了 <code>beanFactory</code>，就是开始获得的 <code>DefaultListableBeanFactory</code>，注册 bean 定义时传入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DefaultListableBeanFactory-的-registerBeanDefinition-注册-bean-定义"><a href="#DefaultListableBeanFactory-的-registerBeanDefinition-注册-bean-定义" class="headerlink" title="DefaultListableBeanFactory 的 registerBeanDefinition 注册 bean 定义"></a>DefaultListableBeanFactory 的 registerBeanDefinition 注册 bean 定义</h3><p>其他非核心的暂时略过了，剩下就两行，最终是把 bean 放入 ConcurrentHashMap 中，名字放入 ArrayList 中。放在 map 里是为了后面可以方便映射获取，名字在 list 中则是为了方便获取遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition); <span class="comment">// 名字和bean定义对应</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName); <span class="comment">// 名字</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="ClassPathBeanDefinitionScanner-扫描类定义"><a href="#ClassPathBeanDefinitionScanner-扫描类定义" class="headerlink" title="ClassPathBeanDefinitionScanner 扫描类定义"></a>ClassPathBeanDefinitionScanner 扫描类定义</h2><p>这个类用于扫描注解，如 <code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>，当然创建的时候它并没有干什么事，只是做了基本的配置，如注册过滤器、设置 <code>ResourceLoader</code>、创建元数据缓存 <code>CachingMetadataReaderFactory</code> 等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters, Environment environment, @Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.registry = registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">        registerDefaultFilters();</span><br><span class="line">    &#125;</span><br><span class="line">    setEnvironment(environment);</span><br><span class="line">    setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="registerDefaultFilters-注册默认过滤器"><a href="#registerDefaultFilters-注册默认过滤器" class="headerlink" title="registerDefaultFilters 注册默认过滤器"></a>registerDefaultFilters 注册默认过滤器</h3><p>主要是 <code>@Component</code>，还有其它的一些 java 扩展</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    ClassLoader cl = ClassPathScanningCandidateComponentProvider<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">                ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">        logger.trace(<span class="string">"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">                ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">        logger.trace(<span class="string">"JSR-330 'javax.inject.Named' annotation found and supported for component scanning"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setResourceLoader-设置资源加载器"><a href="#setResourceLoader-设置资源加载器" class="headerlink" title="setResourceLoader 设置资源加载器"></a>setResourceLoader 设置资源加载器</h3><p>这里创建了 <code>ResourcePatternResolver</code>用于解析 URL 资源、创建了 <code>CachingMetadataReaderFactory</code> 用于做字节码文件元数据的缓存、创建了 <code>CandidateComponentsIndex</code>，这是 spring 内部定义的组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(@Nullable ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);</span><br><span class="line">    <span class="keyword">this</span>.metadataReaderFactory = <span class="keyword">new</span> CachingMetadataReaderFactory(resourceLoader);</span><br><span class="line">    <span class="keyword">this</span>.componentsIndex = CandidateComponentsIndexLoader.loadIndex(<span class="keyword">this</span>.resourcePatternResolver.getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自此 <code>AnnotationConfigApplicationContext</code> 创建完成了，主要创建了读取器和扫描器，读取器中注册了注解后置处理器的 bean 定义，特别是 <code>ConfigurationClassPostProcessor</code>，它是用来解析我们的配置类的。而扫描器不是内部用的，而是给我们用户使用的，内部用他还会创建一个</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的正则表达式</title>
    <url>/2020/05/02/44074/</url>
    <content><![CDATA[<h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</span><br></pre></td></tr></table></figure>

<p>只允许英文字母、数字、下划线、英文句号、以及中划线组成</p>
<img src="/2020/05/02/44074/mail1.svg" class="">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</span><br></pre></td></tr></table></figure>

<p>名称允许汉字、字母、数字，域名只允许英文域名</p>
<img src="/2020/05/02/44074/mail2.svg" class="">

<h2 id="电话"><a href="#电话" class="headerlink" title="电话"></a>电话</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^1(3|4|5|6|7|8|9)\d&#123;9&#125;$</span><br></pre></td></tr></table></figure>

<p>手机号</p>
<img src="/2020/05/02/44074/phone1.svg" class="">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-|\s)?\d&#123;8&#125;</span><br></pre></td></tr></table></figure>

<p>固定电话</p>
<img src="/2020/05/02/44074/phone2.svg" class="">

<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^((http:\&#x2F;\&#x2F;)|(https:\&#x2F;\&#x2F;))?([a-zA-Z0-9]([a-zA-Z0-9\-]&#123;0,61&#125;[a-zA-Z0-9])?\.)+[a-zA-Z]&#123;2,6&#125;(\&#x2F;)</span><br></pre></td></tr></table></figure>

<img src="/2020/05/02/44074/domain.svg" class="">

<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|[01]?\d?\d))</span><br></pre></td></tr></table></figure>

<img src="/2020/05/02/44074/ip.svg" class="">

<h2 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br></pre></td></tr></table></figure>

<img src="/2020/05/02/44074/char.svg" class="">

<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^-?[1-9]\d*$</span><br></pre></td></tr></table></figure>

<p>整数</p>
<img src="/2020/05/02/44074/num1.svg" class="">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br></pre></td></tr></table></figure>

<p>浮点数</p>
<img src="/2020/05/02/44074/num2.svg" class="">
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式详解</title>
    <url>/2020/05/01/19648/</url>
    <content><![CDATA[<p><strong>正则表达式</strong>(regular expression)描述了一种字符串匹配的模式(pattern)，可以用来：</p>
<ul>
<li>检查一个字符串是否含有某种子字符串</li>
<li>将匹配的子字符串替换</li>
</ul>
<p>正则表达式是由普通字符（例如数字、字母或下划线）以及特殊字符（称为 <strong>元字符</strong>）组成的文字模式。描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配</p>
<h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成</p>
<p>例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母 <code>t</code> 开始，接着是 <code>h</code> ，再接着是 <code>e</code></p>
<blockquote>
<p><strong>the</strong> =&gt; The fat cat sat on <strong>the</strong> mat.</p>
</blockquote>
<p>正则表达式 <code>123</code> 匹配字符串 <code>123</code>。它逐个字符的与输入的正则表达式做比较</p>
<p>正则表达式是大小写敏感的，所以 <code>The</code> 不会匹配 <code>the</code></p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式主要依赖于元字符。元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>匹配除换行符 <code>\n</code> 之外的任何单字符</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>字符种类。匹配方括号中不包含的字符</td>
</tr>
<tr>
<td><code>[^ ]</code></td>
<td>否定字符种类。匹配方括号中不包含的字符</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前面的子表达式一次或多次</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</td>
</tr>
<tr>
<td><code>{}</code></td>
<td>标记限定符表达式的开始和结束位置</td>
</tr>
<tr>
<td><code>()</code></td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用</td>
</tr>
<tr>
<td><code>|</code></td>
<td>或运算符，匹配符号前或后的字符</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符，用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>匹配输入字符串的开始位置</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配输入字符串的结尾位置</td>
</tr>
</tbody></table>
<h3 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符 ."></a>点运算符 <code>.</code></h3><p><code>.</code> 是元字符中最简单的例子。<code>.</code> 匹配任意单个字符，但不匹配换行符。例如，表达式 <code>.ar</code> 匹配一个任意字符后面跟着是 <code>a</code> 和 <code>r</code> 的字符串</p>
<blockquote>
<p><strong>.ar</strong> =&gt; The <strong>car</strong> parked in the <strong>gar</strong>age.</p>
</blockquote>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符集也叫做字符类。方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。在方括号中的字符集不关心顺序。例如，表达式 <code>[Tt]he</code>  匹配  <code>the</code>  和  <code>The</code></p>
<blockquote>
<p><strong>[Tt]he</strong> =&gt; <strong>The</strong> car parked in <strong>the</strong> garage.</p>
</blockquote>
<p>方括号内的句号就表示句号。表达式  <code>ar[.]</code>  匹配  <code>ar.</code> 字符串</p>
<blockquote>
<p><strong>ar[.]</strong> =&gt; A garage is a good place to park a c<strong>ar.</strong></p>
</blockquote>
<h4 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h4><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。例如，表达式 <code>[^c]ar</code> 匹配一个后面跟着 <code>ar</code> 的除了 <code>c</code> 的任意字符</p>
<blockquote>
<p><strong>[^c]ar</strong> =&gt; The car <strong>par</strong>ked in the <strong>gar</strong>age.</p>
</blockquote>
<h3 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h3><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。这些元字符在不同的情况下有着不同的意思</p>
<h4 id="星号"><a href="#星号" class="headerlink" title="星号 *"></a>星号 <code>*</code></h4><p><code>*</code> 表示匹配上一个匹配规则的零次或多次。例如，表达式 <code>a*</code> 匹配0或多个以a开头的字符。表达式 <code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串</p>
<blockquote>
<p><strong>[a-z]*</strong> =&gt; T<strong>he car parked in the garage</strong> #21.</p>
</blockquote>
<p><code>*</code> 字符和 <code>.</code> 字符搭配可以匹配所有的字符 <code>.*</code>。<code>*</code> 和表示匹配空格的符号 <code>\s</code> 连起来用，如表达式 <code>\s*cat\s*</code> 匹配0或更多个空格开头和0或更多个空格结尾的cat字符串</p>
<blockquote>
<p><strong>\s*cat\s*</strong> =&gt; The fat <strong>cat</strong> sat on the con<strong>cat</strong>enation.</p>
</blockquote>
<h4 id="加号"><a href="#加号" class="headerlink" title="加号 +"></a>加号 <code>+</code></h4><p><code>+</code> 表示匹配上一个字符的一次或多次。例如表达式 <code>c.+t</code>  匹配以首字母 <code>c</code> 开头以 <code>t</code> 结尾，中间跟着至少一个字符的字符串</p>
<blockquote>
<p><strong>c.+t</strong> =&gt; The fat <strong>cat sat on the mat</strong>.</p>
</blockquote>
<h4 id="问号"><a href="#问号" class="headerlink" title="问号 ?"></a>问号 <code>?</code></h4><p><code>?</code> 标记前面的字符为可选，该符号匹配前一个字符的零次或一次。例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code></p>
<blockquote>
<p><strong>[T]he</strong> =&gt; <strong>The</strong> car is parked in the garage.<br><strong>[T]?he</strong> =&gt; <strong>The</strong> car is parked in t<strong>he</strong> garage.</p>
</blockquote>
<h3 id="花括号"><a href="#花括号" class="headerlink" title="花括号 {}"></a>花括号 <code>{}</code></h3><p>在正则表达式中 <code>{}</code> 是一个量词，常用来一个或一组字符重复出现的次数。例如， 表达式 <code>[0-9]{2,3}</code> 匹配最少2位最多3位 <code>0~9</code> 的数字</p>
<blockquote>
<p><strong>[0-9]{2,3}</strong> =&gt; The number was 9.<strong>999</strong>7 but we rounded it off to <strong>10</strong>.0.</p>
</blockquote>
<p>可以省略第二个参数。例如，<code>[0-9]{2,}</code> 匹配至少2位 <code>0~9</code> 的数字</p>
<blockquote>
<p><strong>[0-9]{2,}</strong> =&gt; The number was 9.<strong>9997</strong> but we rounded it off to <strong>10</strong>.0.</p>
</blockquote>
<p>如果逗号也省略掉则表示重复固定的次数。例如，<code>[0-9]{3}</code> 匹配3位数字</p>
<blockquote>
<p><strong>[0-9]{3}</strong> =&gt; The number was 9.<strong>999</strong>7 but we rounded it off to 10.0.</p>
</blockquote>
<h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组 (...)"></a>字符组 <code>(...)</code></h3><p>字符组是一组写在圆括号中的子模式 <code>(...)</code>。例如之前把一个量词放在一个字符之后，它会重复前一个字符。 但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。例如，表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code></p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code></p>
<blockquote>
<p><strong>(c|g|p)ar</strong> =&gt; The <strong>car</strong> is <strong>par</strong>ked in the <strong>gar</strong>age.</p>
</blockquote>
<h3 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符 |"></a>或运算符 <code>|</code></h3><p>或运算符就表示或，用作判断条件</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code></p>
<blockquote>
<p><strong>(T|t)he|car</strong> =&gt; <strong>The car</strong> is parked in <strong>the</strong> garage.</p>
</blockquote>
<h3 id="转义特殊字符"><a href="#转义特殊字符" class="headerlink" title="转义特殊字符 \"></a>转义特殊字符 <code>\</code></h3><p>反斜线 <code>\</code> 在表达式中用于转义紧跟其后的字符。这将允许你使用保留字符 <code>{ } [ ] / \ + * . $ ^ | ?</code> 来作为匹配字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code></p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code> 是选择性匹配 <code>.</code></p>
<blockquote>
<p><strong>(f|c|m)at.?</strong> =&gt; The <strong>fat cat</strong> sat on the <strong>mat.</strong></p>
</blockquote>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到定位符。<code>^</code> 指定开头，<code>$</code> 指定结尾</p>
<h4 id="插入符号"><a href="#插入符号" class="headerlink" title="插入符号 ^"></a>插入符号 <code>^</code></h4><p>插入符号 <code>^</code> 用于检查匹配字符是否是输入字符串的第一个字符</p>
<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头</p>
<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串</p>
<blockquote>
<p><strong>(T|t)he</strong> =&gt; <strong>The</strong> car is parked in <strong>the</strong> garage.<br><strong>^(T|t)he</strong> =&gt; <strong>The</strong> car is parked in the garage.</p>
</blockquote>
<h4 id="美元符号"><a href="#美元符号" class="headerlink" title="美元符号 $"></a>美元符号 <code>$</code></h4><p>美元符号 <code>$</code> 用于检查匹配字符是否是输入字符串的最后一个字符</p>
<p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串</p>
<blockquote>
<p><strong>(at.)</strong> =&gt; The fat c<strong>at. sat.</strong> on the m<strong>at.</strong><br><strong>(at.)$</strong> =&gt; The fat cat. sat. on the m<strong>at.</strong></p>
</blockquote>
<h2 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h2><p>正则表达式为常用的字符集和常用的正则表达式提供了简写。这包括所有大写和小写字母、所有数字、所有标点符号和没有显式指定为元字符的所有可打印和不可打印字符</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td>匹配一个数字字符。等价于 <code>[0-9]</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配一个非数字字符。等价于 <code>[^0-9]</code></td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配字母、数字、下划线。等价于 <code>[A-Za-z0-9_]</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配非字母、数字、下划线。等价于 <code>[^A-Za-z0-9_]</code></td>
</tr>
<tr>
<td><code>\cx</code></td>
<td>匹配由x指明的控制字符。例如， <code>\cM</code> 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>匹配一个换页符。等价于 <code>\x0c</code> 和 <code>\cL</code></td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配一个换行符。等价于 <code>\x0a</code> 和 <code>\cJ</code></td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配一个回车符。等价于 <code>\x0d</code> 和 <code>\cM</code></td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配一个制表符。等价于 <code>\x09</code> 和 <code>\cI</code></td>
</tr>
<tr>
<td><code>\v</code></td>
<td>匹配一个垂直制表符。等价于 <code>\x0b</code> 和 <code>\cK</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个字边界，即字与空格间的位置</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>非字边界匹配</td>
</tr>
</tbody></table>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>是特殊类型的 非捕获组 (用于匹配模式，但不包括在匹配列表中)。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。 例如我们想获取输入字符串 $4.44 and $10.88 中带有前缀 $ 的所有数字。我们可以使用这个正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>，表示: 获取包含 . 字符且前缀为 $ 的所有数字。 以下是正则表达式中使用的断言:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>(exp)</code></td>
<td>匹配 exp 并获取这一匹配</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>匹配 exp 但不获取匹配结果</td>
</tr>
<tr>
<td><code>(?=exp)</code></td>
<td>零宽度正预测先行断言，匹配后面跟的是exp的位置</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>零宽度负预测先行断言，匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>零宽度正回顾后发断言，匹配前面是exp的位置</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>零宽度负回顾后发断言，匹配前面不是exp的位置</td>
</tr>
</tbody></table>
<h3 id="正向先行断言"><a href="#正向先行断言" class="headerlink" title="正向先行断言 ?=..."></a>正向先行断言 <code>?=...</code></h3><p>正向先行断言表示第一部分表达式之后必须跟着 <code>?=...</code> 定义的表达式</p>
<p>返回结果只包含满足匹配条件的第一部分表达式。定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code></p>
<p>正先行断言的内容写在括号中的等号后面。例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code></p>
<blockquote>
<p><strong>(T|t)he(?=\sfat)</strong> =&gt; <strong>The</strong> fat cat sat on the mat.</p>
</blockquote>
<h3 id="负向先行断言"><a href="#负向先行断言" class="headerlink" title="负向先行断言 ?!..."></a>负向先行断言 <code>?!...</code></h3><p>负向先行断言用于筛选所有匹配结果，筛选条件为其后不跟随着断言中定义的格式。<code>正先行断言</code> 定义和 <code>负向先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code></p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code></p>
<blockquote>
<p><strong>(T|t)he(?!\sfat)</strong> =&gt; The fat cat sat on <strong>the</strong> mat.</p>
</blockquote>
<h3 id="正向后发断言-lt"><a href="#正向后发断言-lt" class="headerlink" title="正向后发断言 ?&lt;=..."></a>正向后发断言 <code>?&lt;=...</code></h3><p>正向后发断言 记作 <code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code></p>
<blockquote>
<p><strong>(?&lt;=(T|t)he\s)(fat|mat)</strong> =&gt; The <strong>fat</strong> cat sat on the <strong>mat</strong>.</p>
</blockquote>
<h3 id="负向后发断言-lt"><a href="#负向后发断言-lt" class="headerlink" title="负向后发断言 ?&lt;!..."></a>负向后发断言 <code>?&lt;!...</code></h3><p>负向后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code></p>
<blockquote>
<p><strong>(?&lt;!(T|t)he\s)(cat)</strong> =&gt; The cat sat on <strong>cat</strong>.</p>
</blockquote>
<h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。这些标志可以任意的组合使用，它也是整个正则表达式的一部分</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>g</td>
<td>全局搜索</td>
</tr>
<tr>
<td>m</td>
<td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始</td>
</tr>
</tbody></table>
<h3 id="忽略大小写（Case-Insensitive）"><a href="#忽略大小写（Case-Insensitive）" class="headerlink" title="忽略大小写（Case Insensitive）"></a>忽略大小写（Case Insensitive）</h3><p>修饰符 <code>i</code> 用于忽略大小写。例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code></p>
<blockquote>
<p><strong>The</strong> =&gt; <strong>The</strong> fat cat sat on the mat.<br><strong>/The/gi</strong> =&gt; <strong>The</strong> fat cat sat on <strong>the</strong> mat.</p>
</blockquote>
<h3 id="全局搜索（Global-search）"><a href="#全局搜索（Global-search）" class="headerlink" title="全局搜索（Global search）"></a>全局搜索（Global search）</h3><p>修饰符 <code>g</code> 用于执行全局搜索匹配，即不仅仅返回第一个匹配的，而是返回全部。例如，表达式 <code>/.(at)/g</code> 表示搜索任意字符（除了换行）+ <code>at</code>，并返回全部结果</p>
<blockquote>
<p><strong>/.(at)/</strong> =&gt; The <strong>fat</strong> cat sat on the mat.<br><strong>/.(at)/g</strong> =&gt; The <strong>fat cat sat</strong> on the <strong>mat</strong>.</p>
</blockquote>
<h3 id="多行修饰符（Multiline）"><a href="#多行修饰符（Multiline）" class="headerlink" title="多行修饰符（Multiline）"></a>多行修饰符（Multiline）</h3><p>修饰符 <code>m</code> 用于执行多行匹配</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code></p>
<p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾</p>
<blockquote>
<p><strong>/.at(.)?$/</strong> =&gt; The fat<br>cat sat<br>on the <strong>mat.</strong><br><strong>/.at(.)?$/gm</strong> =&gt; The <strong>fat</strong><br>cat <strong>sat</strong><br>on the <strong>mat.</strong></p>
</blockquote>
<h2 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h2><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式</p>
<blockquote>
<p><strong>/(.*at)/</strong> =&gt; <strong>The fat cat sat on the mat</strong>.<br><strong>/(.*?at)/</strong> =&gt; <strong>The fat</strong> cat sat on the mat.</p>
</blockquote>
<h2 id="其它元字符"><a href="#其它元字符" class="headerlink" title="其它元字符"></a>其它元字符</h2><table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\xn</code></td>
<td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，<code>\x41</code> 匹配 <code>A</code>。<code>\x041</code> 则等价于 <code>\x04</code> + <code>1</code>。正则表达式中可以使用 ASCII 编码</td>
</tr>
<tr>
<td><code>\num</code></td>
<td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，<code>(.)\1</code> 匹配两个连续的相同字符</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值</td>
</tr>
<tr>
<td><code>\nm</code></td>
<td>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm</td>
</tr>
<tr>
<td><code>\nml</code></td>
<td>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml</td>
</tr>
<tr>
<td><code>\un</code></td>
<td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础知识(4)：发布订阅</title>
    <url>/2020/04/06/24826/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Redis消息订阅发布是进程间的一种消息通信模式，发送者pub发送消息，订阅者sub接收消息</p>
<p>需要先订阅后发布，才能接收到消息。在订阅时，相当于创建了可供发布的频道</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SUBSCRIBE</strong> channel [channel …]</td>
<td>订阅一个或多个频道</td>
</tr>
<tr>
<td><strong>UNSUBSCRIBE</strong> channel [channel …]</td>
<td>退阅一个或多个频道</td>
</tr>
<tr>
<td><strong>PUBLISH</strong> channel message</td>
<td>发布一条消息到频道</td>
</tr>
<tr>
<td><strong>PSUBSCRIBE</strong> channel [channel …]</td>
<td>订阅一个或多个给定模式的频道</td>
</tr>
<tr>
<td><strong>PUNSUBSCRIBE</strong> channel [channel …]</td>
<td>退阅一个或多个给定模式的频道</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础知识(3)：持久化</title>
    <url>/2020/04/05/18962/</url>
    <content><![CDATA[<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis 作为内存数据库，为了防止因服务器断电或系统宕机而引起的数据丢失问题，Redis 自带了持久化功能，将内存中的数据同步到磁盘中来保持持久化</p>
<p>Redis 支持两种持久化方式：<strong>RDB</strong>(Redis DataBase) 和 <strong>AOF</strong>(Append Only File)</p>
<h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><p>在指定的时间间隔内将内存的数据集快照写入磁盘，待服务重启时，将快照文件读取到内存中</p>
<p>Redis 会单独创建 (fork) 一个子线程来进行持久化，主线程是不会进行任何 IO 操作的，确保了 Redis 极高的性能</p>
<p>在进行持久化的过程中，会先将数据写入一个临时文件中，待持久化过程结束时，才会用这个临时文件替换上次持久化好的文件。正是这种特性，我们可以随时进行备份，因为快照文件总是完整可用的</p>
<p><strong>触发方式</strong>：可以通过 redis命令 或者配置 redis.conf 文件来指定redis持久化的时机。</p>
<ol>
<li><p>使用命令</p>
<ul>
<li><strong>save</strong> 立即进行持久化，其它全部阻塞</li>
<li><strong>bgsave</strong> 后台异步进行快照操作，同时还可以响应客户端的请求</li>
<li><strong>flushall</strong> 清空命令也会触发持久化操作，但 dump.rdb 文件是空的</li>
<li><strong>shutdown</strong> 关闭数据库命令也会触发持久化操作</li>
</ul>
</li>
<li><p>使用配置文件</p>
<p>在 redis.conf 文件中的 SNAPSHOTTING 配置部分 save &lt;seconds&gt; &lt;changes&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在 seconds 秒内有 changes 次更新操作，就进行一次持久化</span><br><span class="line"># 当配置为 save &quot;&quot; 时，代表禁用RDB持久化</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>配置好持久化文件名和目录后，当触发持久化时，持久化文件存储到配置好的位置。同时当启动 Redis 时，会检测持久化文件是否存在，如果存在则会将其加载到内存</p>
<p>当 dump.rdb 存在异常，数据恢复将报错。此时可使用 redis-check-rdb –fix &lt;filename&gt; 对持久化文件进行修复，然后重启 Redis 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定本地数据库文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 指定本地数据文件存放目录</span><br><span class="line">dir .&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul>
<li>持久化过程中，主进程不进行任何 IO 操作，对于大规模的数据恢复，具有极高的性能</li>
<li>最后一次持久化的数据可能因 Redis 意外宕机而丢失最后一次快照后的所有修改数据</li>
<li>Fork 时，内存数据被克隆，大致2倍的膨胀性，会对服务器造成一丁点压力，影响性能</li>
<li>总之，RDB 适用于大规模数据恢复，且对数据的完整性、一致性要求不是很严格</li>
</ul>
<h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p> 将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍</p>
<p>默认的AOF持久化策略是每秒钟 fsync 一次（fsync 是指把缓存中的写指令记录到磁盘中），因为在这种情况下，Redis 仍然可以保持很好的处理性能，即使 Redis 故障，也只会丢失最近1秒钟的数据</p>
<p><strong>触发方式</strong>：可以通过配置 redis.conf 文件来指定 Redis 持久化的时机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认 AOF 持久化方式是关闭的，将参数设置为 yes 即可开启</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line">## 指定更新条件</span><br><span class="line"># appendfsync always # 每次数据更改都会立刻调用 fsync() 方法写入磁盘</span><br><span class="line">appendfsync everysec # 每秒同步一次</span><br><span class="line"># appendfsync no     # 永不</span><br></pre></td></tr></table></figure>

<p>配置好持久化文件名和目录后，当触发持久化时，持久化文件存储到配置好的位置。同时当启动 Redis 时，会检测持久化文件是否存在，如果存在则会将其加载到内存</p>
<p>当同时开启 RDB 和 AOF 两种持久化时，会优先加载 AOD 持久化文件进行数据恢复</p>
<p>当 appendonly.aof 存在异常，数据恢复将报错。此时可使用 redis-check-aof –fix &lt;filename&gt; 对持久化文件进行修复，然后重启 Redis 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定更新文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Rewrite机制"><a href="#Rewrite机制" class="headerlink" title="Rewrite机制"></a>Rewrite机制</h4><p>AOF 采用文件追加的方式，将导致文件越来越大，故新增重写机制。当 AOF 文件大小超过所设置的阈值时，Redis 将启动 AOF 内容压缩，只保留可以恢复数据的最小指令集</p>
<p>在进行 AOF 重写时，Redis 将 fork 出一条新进程来将文件重写，整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作</p>
<h4 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h4><ul>
<li><p>使用 AOF 会让 Redis 更加耐久，一旦出现故障，最多丢失1秒的数据</p>
</li>
<li><p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松</p>
</li>
<li><p>相同数据集的数据，AOF文件远大于RBD文件，且恢复速度慢于RBD</p>
</li>
<li><p>AOF运行效率慢于RBD，每秒同步策略效率较好，不同步效率和RDB相同</p>
</li>
<li><p>AOF在rewrite过程中将新数据写到新文件中造成的阻塞是不可避免的</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础知识(2)：事务</title>
    <url>/2020/04/04/9773/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>事务可以一次执行多个命令，且有以下两个保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务在的所有命令都会序列化、按顺序执行。事务在执行的过程在，不会被其他客户端发来的命令请求打断</li>
<li>事务是一个原子操作：事务中的命令要么全部执行，要么全部不执行</li>
</ul>
<p>Redis 事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MULTI</strong></td>
<td>开启一个事务，执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中</td>
</tr>
<tr>
<td><strong>EXEC</strong></td>
<td>执行队列中的所有命令</td>
</tr>
<tr>
<td><strong>DISCARD</strong></td>
<td>清空事务队列， 并放弃执行事务</td>
</tr>
<tr>
<td><strong>WATCH</strong></td>
<td>监视键值对，当事务提交 <strong>EXEC</strong> 时发现监视的对象发生变化时，事务将被取消</td>
</tr>
<tr>
<td><strong>UNWATCH</strong></td>
<td>取消 <strong>watch</strong> 对所有 key 的监控</td>
</tr>
</tbody></table>
<h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><p>Redis 中没有事务隔离级别的概念。批量操作在执行 <strong>EXEC</strong> 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到</p>
<h2 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h2><p>使用事务时可能会遇上以下两种错误：</p>
<ol>
<li>调用 <strong>EXEC</strong> 之前的错误</li>
<li>调用 <strong>EXEC</strong> 之后的错误</li>
</ol>
<p>调用 <strong>EXEC</strong> 之前的错误，有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，Redis 都会进行记录，在客户端调用 <strong>EXEC</strong> 时，Redis 会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，Redis 会忽略那些入队失败的命令，只执行那些入队成功的命令）</p>
<p>对于 调用 <strong>EXEC</strong> 之后的错误 ，Redis 则采取了完全不同的策略，即 Redis 不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是 Redis 自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行</p>
<p>所以说：<strong>Redis 的事务不保证原子性</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础知识(1)：数据类型</title>
    <url>/2020/04/03/47456/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis支持五种数据类型：string(字符串)，hash(哈希)，list(列表)，set(集合) 及 zset(有序集合)。以及三种特殊的数据类型：bitmaps，hyperloglogs 和 geospatial(地理位置)</p>
<p>通用命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>EXISTS</strong> key [key …]</td>
<td>返回 key 是否存在</td>
</tr>
<tr>
<td><strong>DEL</strong> key [key …]</td>
<td>删除指定的 key</td>
</tr>
<tr>
<td><strong>KEYS</strong> pattern</td>
<td>查找所有符合给定 pattern 的 key</td>
</tr>
<tr>
<td><strong>TYPE</strong> key</td>
<td>返回 key 所存储的 value 的数据类型</td>
</tr>
<tr>
<td><strong>EXPIRE</strong> key seconds</td>
<td>设置 key 的过期时间</td>
</tr>
<tr>
<td><strong>TTL</strong> key</td>
<td>返回 key 的过期时间</td>
</tr>
</tbody></table>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string是最简单Redis类型。如果你只用这种类型，Redis就像一个可以持久化的memcached服务器</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SET</strong> key value [<strong>EX</strong> seconds] [<strong>PX</strong> milliseconds] [<strong>NX</strong> | <strong>XX</strong>]</td>
<td>将键 key 设定为指定的“字符串”值</td>
</tr>
<tr>
<td><strong>GET</strong> key</td>
<td>返回 key 的 value</td>
</tr>
<tr>
<td><strong>STRLEN</strong> key</td>
<td>返回 key 的 string 类型 value 的长度</td>
</tr>
<tr>
<td><strong>INCR</strong> key</td>
<td>对存储在指定 key 的数值执行原子的加1操作</td>
</tr>
<tr>
<td><strong>INCRBY</strong> key increment</td>
<td>将 key 对应的数字加 increment</td>
</tr>
<tr>
<td><strong>DECR</strong> key</td>
<td>对 key 对应的数字做减1操作</td>
</tr>
<tr>
<td><strong>DECRBY</strong> key decrement</td>
<td>将 key 对应的数字减 decrement</td>
</tr>
<tr>
<td><strong>MSET</strong> key value [key value …]</td>
<td>返回所有指定的 key 的 value</td>
</tr>
<tr>
<td><strong>MGET</strong> key [key …]</td>
<td>对应给定的 keys 到他们相应的 values 上</td>
</tr>
<tr>
<td><strong>GETRANGE</strong> key start end</td>
<td>返回 key 对应的字符串 value 的子串</td>
</tr>
<tr>
<td><strong>SETRANGE</strong> key offset value</td>
<td>覆盖 key 对应的 string 的一部分</td>
</tr>
</tbody></table>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Redis 的 list 基于链表实现。这意味着即使在一个 list 中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。但链表型 list 的元素定位会比较慢</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LINDEX</strong> key index</td>
<td>返回 list 元素 index 位置的值</td>
</tr>
<tr>
<td><strong>LPUSH</strong> key value [value …]</td>
<td>将所有指定的值插入到 key 对应的 list 的头部</td>
</tr>
<tr>
<td><strong>RPUSH</strong> key value [value …]</td>
<td>将所有指定的值插入到 key 对应的 list 的尾部</td>
</tr>
<tr>
<td><strong>LRANGE</strong> key start end</td>
<td>返回 key 对应的 list 里指定范围内的元素</td>
</tr>
<tr>
<td><strong>LPOP</strong> key</td>
<td>移除并且返回 key 对应的 list 的第一个元素</td>
</tr>
<tr>
<td><strong>RPOP</strong> key</td>
<td>移除并且返回 key 对应的 list 的最后一个元素</td>
</tr>
<tr>
<td><strong>LLEN</strong> key</td>
<td>返回存储在 key 对应的 list 的长度</td>
</tr>
<tr>
<td><strong>LREM</strong> key count value</td>
<td>从 key 对应的 list 里移除前 count 次出现的值为 value 的元素</td>
</tr>
<tr>
<td><strong>LTRIM</strong> key start end</td>
<td>移除 key 对应的 list 里指定范围外的元素</td>
</tr>
<tr>
<td><strong>RPOPLPUSH</strong> source destination</td>
<td>原子性地 <strong>RPOP</strong> source 并 <strong>LPUSH</strong> 到 destination</td>
</tr>
<tr>
<td><strong>LSET</strong> key index value</td>
<td>设置 key 对应的 list 元素 index 位置的值为 value</td>
</tr>
<tr>
<td><strong>LINSERT</strong> key <strong>BEFORE</strong>|<strong>AFTER</strong> pivot value</td>
<td>把 value 插入 key 对应的 list 中在基准值 pivot 的前面或后面</td>
</tr>
</tbody></table>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p> Set 是 String 的无序排列，集合中的元素没有先后顺序</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SADD</strong> key value [value …]</td>
<td>添加所有指定的值到 key 对应的 set 中</td>
</tr>
<tr>
<td><strong>SMEMBERS</strong> key</td>
<td>返回 key 对应的 set 中所有的元素</td>
</tr>
<tr>
<td><strong>SISMEMBER</strong> key member</td>
<td>返回 member 是否是 key 对应的 set 中的成员</td>
</tr>
<tr>
<td><strong>SCARD</strong>  key</td>
<td>返回 key 对应的 set 中元素的个数</td>
</tr>
<tr>
<td><strong>SREM</strong> key member [member …]</td>
<td>从 key 对应的 set 中移除指定的元素</td>
</tr>
<tr>
<td><strong>SRANDMEMBER</strong> key [count]</td>
<td>随机返回 key 对应的 set 中的 count 个元素</td>
</tr>
<tr>
<td><strong>SPOP</strong> key [count]</td>
<td>随机删除 key 对应的 set 中的 count 个元素</td>
</tr>
<tr>
<td><strong>SMOVE</strong> source destination member</td>
<td>将 member 从 source 移动到 destination 中</td>
</tr>
<tr>
<td><strong>SDIFF</strong> key [key …]</td>
<td>返回 key 对应的 set 与给定 set 的差集</td>
</tr>
<tr>
<td><strong>SINTER</strong> key [key …]</td>
<td>返回 key 对应的 set 与给定 set 的交集</td>
</tr>
<tr>
<td><strong>SUNION</strong> key [key …]</td>
<td>返回 key 对应的 set 与给定 set 的并集</td>
</tr>
</tbody></table>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>Hash 便于表示对象，实际上，你可以放入一个 hash 的域数量实际上没有限制（除了可用内存以外）。所以你可以在你的应用中以不同的方式使用 hash</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HSET</strong> key field value</td>
<td>设置 key 对应的 hash 中指定字段的值</td>
</tr>
<tr>
<td><strong>HGET</strong> key field</td>
<td>返回 key 对应的 hash 中指定字段的值</td>
</tr>
<tr>
<td><strong>HMSET</strong> key field value [field value …]</td>
<td>设置 key 对应的 hash 中多个字段的值</td>
</tr>
<tr>
<td><strong>HMGET</strong> key field [field …]</td>
<td>返回 key 对应的 hash 中多个字段的值</td>
</tr>
<tr>
<td><strong>HGETALL</strong> key</td>
<td>返回 key 对应的 hash 中所有字段和值</td>
</tr>
<tr>
<td><strong>HDEL</strong> key field [field …]</td>
<td>从 key 对应的 hash 中移除指定的字段</td>
</tr>
<tr>
<td><strong>HLEN</strong> key</td>
<td>返回 key 对应的 hash 中字段的数量</td>
</tr>
<tr>
<td><strong>HEXISTS</strong> key field</td>
<td>返回 key 对应的 hash 里面 field 是否存在</td>
</tr>
<tr>
<td><strong>HKEYS</strong> key</td>
<td>返回 key 对应的 hash 里面中所有字段</td>
</tr>
<tr>
<td><strong>HVALS</strong> key</td>
<td>返回 key 对应的 hash 里面中所有值</td>
</tr>
<tr>
<td><strong>HINCRBY</strong> key field increment</td>
<td>增加 key 对应的 hash 中指定字段的数值</td>
</tr>
</tbody></table>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>在 set 的基础上每个元素都会关联一个值，通过这个值为集合中的成员进行从小到大的排序</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ZADD</strong> key [<strong>NX</strong> | <strong>XX</strong>] [<strong>CH</strong>] [<strong>INCR</strong>] score member [score member …]</td>
<td>将所有指定元素添加到 key 对应的 zset 中</td>
</tr>
<tr>
<td><strong>ZRANGE</strong> key start stop [<strong>WITHSCORES</strong>]</td>
<td>返回 key 对应的 zset 中的指定范围的元素</td>
</tr>
<tr>
<td><strong>ZREVRANGE</strong> key start stop [<strong>WITHSCORES</strong>]</td>
<td>返回 key 对应的 zset 中的指定范围的元素</td>
</tr>
<tr>
<td><strong>ZRANGEBYSCORE</strong> key min max [<strong>WITHSCORES</strong>] [<strong>LIMIT</strong> offset count]</td>
<td>返回 key 对应的 zset 中 score 值在 min 和 max 之间的所有元素</td>
</tr>
<tr>
<td><strong>ZREM</strong> key member [member …]</td>
<td>从 key 对应的 zset 中移除指定的元素</td>
</tr>
<tr>
<td><strong>ZCARD</strong>  key</td>
<td>返回 key 对应的 zset 中元素的个数</td>
</tr>
<tr>
<td><strong>ZCOUNT</strong> key min max</td>
<td>返回 key 对应的 zset 中 score 值在 min 和 max 之间的成员个数</td>
</tr>
</tbody></table>
<h3 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h3><p>将指定的地理空间位置（纬度、经度、名称）添加到指定的 key 中。这些数据将会存储到 zset</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GEOADD</strong> key longitude latitude member [longitude latitude member …]</td>
<td>将指定的地理空间位置（纬度、经度、名称）添加到指定的 key 中</td>
</tr>
<tr>
<td><strong>GEODIST</strong> key member1 member2 [<strong>unit</strong>]</td>
<td>返回两个给定位置之间的距离</td>
</tr>
<tr>
<td><strong>GEOHASH</strong> key member [member …]</td>
<td>返回一个或多个位置元素的 <strong>Geohash</strong> 表示</td>
</tr>
<tr>
<td><strong>GEOPOS</strong> key member [member …]</td>
<td>从 key 里返回所有给定位置元素的位置</td>
</tr>
<tr>
<td><strong>GEORADIUS</strong> key longitude latitude radius <strong>m</strong>|<strong>km</strong>|<strong>ft</strong>|<strong>mi</strong> [<strong>WITHCOORD</strong>] [<strong>WITHDIST</strong>] [<strong>WITHHASH</strong>] [<strong>COUNT</strong> count]</td>
<td>找出给定的经纬度指定范围内的元素</td>
</tr>
<tr>
<td><strong>GEORADIUSBYMEMBER</strong> key member radius <strong>m</strong>|<strong>km</strong>|<strong>ft</strong>|<strong>mi</strong> [<strong>WITHCOORD</strong>] [<strong>WITHDIST</strong>] [<strong>WITHHASH</strong>] [<strong>COUNT</strong> count]</td>
<td>找出给定的位置元素指定范围内的元素</td>
</tr>
</tbody></table>
<h3 id="hyperloglogs"><a href="#hyperloglogs" class="headerlink" title="hyperloglogs"></a>hyperloglogs</h3><p>用于基数统计</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PFADD</strong> key element [element …]</td>
<td>将所有指定元素添加到 key 对应的 hyperloglogs 中</td>
</tr>
<tr>
<td><strong>PFCOUNT</strong> key [key …]</td>
<td>返回 key 对应的 hyperloglogs 中元素的个数</td>
</tr>
<tr>
<td><strong>PFMERGE</strong> destkey sourcekey [sourcekey …]</td>
<td>将多个 hyperloglogs 合并为一个</td>
</tr>
</tbody></table>
<h3 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h3><p>位图是在 string 类型上定义的一组面向位的操作</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SETBIT</strong> key offset value</td>
<td>设置 key 对应的 string 在 offset 处的 bit 值</td>
</tr>
<tr>
<td><strong>GETBIT</strong> key offset</td>
<td>返回 key 对应的 string 在 offset 处的 bit 值</td>
</tr>
<tr>
<td><strong>BITCOUNT</strong> key [start end]</td>
<td>统计字符串指定范围内被设置为1的 bit 数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程(4)：线程常用方法</title>
    <url>/2020/03/28/4101/</url>
    <content><![CDATA[<h2 id="唤醒与等待"><a href="#唤醒与等待" class="headerlink" title="唤醒与等待"></a>唤醒与等待</h2><p>帮助线程传递线程关心的时间状态的方法有这些：</p>
<ul>
<li><strong>notify()</strong>：唤醒在此对象监视器上等待的单个线程。</li>
<li><strong>notifyAll()</strong>：唤醒在此对象监视器上等待的所有线程</li>
<li><strong>wait(long time)</strong>：当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量</li>
<li><strong>wait(long time, int nanos)</strong>：当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量</li>
</ul>
<p>这四个方法都是 <strong>Object</strong> 的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，他们等待来自该信号（通知）。线程通过执行对象上的 wait() 方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的 notify() 方法为止。如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作</p>
<h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2><p>线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时候，会将CPU资源交给其他线程，以便能轮换执行，当休眠一定时间后，线程会苏醒，进入准备状态等待执行。</p>
<p>线程休眠的方法是 <strong>Thread.sleep(long millis)</strong> 和 <strong>Thread.sleep(long millis, int nanos)</strong>，均为静态方法，那调用sleep休眠的哪个线程呢？简单说，哪个线程调用sleep，就休眠哪个线程</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行</p>
<p>使用 <strong>setPriority(int priority)</strong> 方法可显式指定优先级。线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5，</p>
<p>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同</p>
<h2 id="让步"><a href="#让步" class="headerlink" title="让步"></a>让步</h2><p>线程的让步就是使当前运行的线程让出CPU资源，但是具体让给谁不确定，仅仅是让出，线程状态回到可运行状态</p>
<p>线程的让步使用 <strong>Thread.yield()</strong> 方法，yield() 为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程</p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行</p>
<p>合并的方法为 <strong>join()</strong>，为非静态方法，定义如下：</p>
<ul>
<li>void join()：等待该线程终止</li>
<li>void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒</li>
<li>void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程与普通线程写法上基本相同，调用线程对象的方法 <strong>setDaemon(true)</strong>，则可以将其设置为守护线程。守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等</p>
<p><strong>setDaemon</strong> 方法将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。该方法必须在启动线程前调用。该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程(3)：线程的同步与锁</title>
    <url>/2020/03/27/43302/</url>
    <content><![CDATA[<h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><p>线程同步是为了防止多个线程访问同一个数据对象，对数据造成破坏</p>
<p>如下：两个线程thread1和thread2都操作同一个Data对象，并修改对象上的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread-1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread-2"</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data.setX(<span class="number">30</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" :当前data对象的x值 = "</span> + data.getX());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x -= x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>Thread-2 :当前data对象的x值 = 40<br>Thread-1 :当前data对象的x值 = 40<br>Thread-2 :当前data对象的x值 = -20<br>Thread-1 :当前data对象的x值 = -50<br>Thread-2 :当前data对象的x值 = -80<br>Thread-1 :当前data对象的x值 = -80</p>
</blockquote>
<p>这样的输出值明显是不合理的。原因是两个线程不加控制的访问 Data 对象并修改其数据。如果要保持结果的合理性，需要对Foo的访问加以限制，每次只能有一个线程在访问。这样就能保证Foo对象中数据的合理性了。在具体的Java代码中需要完成以下两个操作：</p>
<ul>
<li>把竞争访问的资源类 Data 变量 x 标识为 private</li>
<li>同步修改变量的代码，使用 synchronized 关键字同步方法或代码</li>
</ul>
<h2 id="同步与锁定"><a href="#同步与锁定" class="headerlink" title="同步与锁定"></a>同步与锁定</h2><p>Java 中每个对象都有一个内置锁，当程序运行到非静态的 synchronized 同步方法上时，自动获取与正在执行代码类的当前实例（this）有关的锁，获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。当程序运行到 synchronized 同步方法或代码块时才对象锁才会起作用</p>
<p>一个对象只能有一个锁。如果一个线程获得该锁，就没有其它线程可以获得锁，直到第一个线程释放锁。这也意味着其它任何线程都不能进入该对象上的 synchronized 方法或代码块，直到该锁被释放。释放锁是指持锁线程退出了 synchronized 方法或代码块</p>
<p>关于锁和同步，有以下几个要点：</p>
<ul>
<li>只能同步方法，不能同步变量或类</li>
<li>每个对象只有一把锁，当提到同步时，应该明确在什么上同步，在那个对象上同步</li>
<li>没有必要同步类中所有的方法，类可同时用于同步和非同步方法</li>
<li>如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法</li>
<li>线程中的非同步方法可以被多个线程自由访问，不受锁的限制</li>
<li>调用 Thread.sleep() 后，睡眠的线程不会释放锁</li>
<li>线程可同时获取多把锁，如在一个对象的同步方法里面调用另一个对象的同步方法，则获取了两个对象的锁</li>
<li>同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)</li>
</ul>
<h2 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h2><p>如果线程进入同步方法时其锁已被占用，则线程在该对象上被阻塞。实际上，线程进入该对象的一种池中，必须在那里等待，知道锁被释放，该线程再次变为运行状态</p>
<p>当考虑阻塞时，一定要注意哪个对象正被用于锁定：</p>
<ul>
<li>调用同一个对象的非静态同步方法的线程将彼此阻塞。如果是不同的对象，则每个线程有自己的对象的锁，线程间彼此不干预</li>
<li>调用同一个对象的非态同步方法的线程将彼此阻塞，它们都是锁定在相同的 Class 对象上</li>
<li>静态同步方法和非静态同步方法不会彼此阻塞，因为静态方法锁定在 Class 对象上，非静态方法锁定在该类的对象上</li>
<li>对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞</li>
</ul>
<h2 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h2><p>当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”。即使是线程安全类，也应该特别小心，因为操作的线程是间仍然不一定安全。</p>
<p>举个例子，比如一个集合是线程安全的，有两个线程在操作同一个集合对象，当第一个线程查询集合非空后，删除集合中所有元素的时候。第二个线程也来执行与第一个线程相同的操作，也许在第一个线程查询后，第二个线程也查询出集合非空，但是当第一个执行清除后，第二个再执行删除显然是不对的，因为此时集合已经为空了</p>
<h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>锁对Java程序来说，是很复杂的，也很难发现问题。当两个线程被阻塞，每个线程在等待另一个线程时就发生死锁</p>
<p>如下，假设 read() 方法由一个线程启动，write() 方法由另外一个线程启动。读线程将拥有 r1 锁，写线程将拥有 r2 锁，两者都坚持等待的话就出现死锁。实际上，只有在代码内的某个点，CPU必须从读线程切换到写线程，才可能发生这个情况，死锁发生概率很小。但是无论这个概率有多小，一旦发生死锁，程序就死掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadlockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Resource r1 = <span class="keyword">new</span> Resource();</span><br><span class="line">    <span class="keyword">private</span> Resource r2 = <span class="keyword">new</span> Resource();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r1) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (r2) &#123;</span><br><span class="line">                <span class="keyword">return</span> r2.value + r1.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r2) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (r1) &#123;</span><br><span class="line">                r1.value = a;</span><br><span class="line">                r2.value = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏</li>
<li>线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法</li>
<li>对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁</li>
<li>对于同步，要时刻清醒在哪个对象上同步，这是关键</li>
<li>编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源</li>
<li>当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞</li>
<li>死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。但是一旦程序发生死锁，程序将死掉</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程(2)：线程的状态</title>
    <url>/2020/03/27/17671/</url>
    <content><![CDATA[<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ol>
<li><strong>初始状态(NEW)</strong><br>线程对象已经创建，但还没有执行 start() 方法</li>
<li><strong>运行状态(RUNNABLE)</strong><br>Java中把就绪(ready)和运行中(running)两种状态统称为“运行”</li>
<li><strong>阻塞状态(BLOCKED)</strong><br>表示线程阻塞于锁</li>
<li><strong>等待状态(WAITING)</strong><br>进入该状态的线程需要等待其他线程做出一些特定动作(通知或中断)</li>
<li><strong>定时等待状态(TIMED_WAITING)</strong><br>该状态不同于WAITING，它可以在指定的时间后自行返回</li>
<li><strong>终止状态(TERMINATED)</strong><br>表示该线程已经执行完毕</li>
</ol>
<img src="/2020/03/27/17671/status.png" class="">

<h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h3><p>实现Runnable接口和继承Thread可以得到一个线程类，新建一个实例，线程就进入了初始状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">// thread被初始化，还没有调用start()方法启动，此时状态为 NEW</span></span><br><span class="line">System.out.pringln(thread.getState());</span><br></pre></td></tr></table></figure>

<h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>线程对象调用start()方法启动后，该状态的线程位于可运行线程池中，等待被调度程序选中，获取CPU的使用权，此时处于<strong>就绪状态(READY)</strong>。就绪状态的线程在获得CPU时间片后变为<strong>运行中状态(RUNNING)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// thread已经调用start()方法启动，此时状态为 RUNNABLE</span></span><br><span class="line">System.out.println(thread.getState());</span><br></pre></td></tr></table></figure>

<h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>这个状态，一般是线程等待获取一个锁，来继续执行下一步的操作，比较经典的就是<code>synchronized</code>关键字，这个关键字修饰的代码块或者方法，均需要获取到对应的锁，在未获取之前，其线程的状态就一直未BLOCKED，如果线程长时间处于这种状态下，我们就是当心看是否出现死锁的问题了。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadBlocked</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(lock);</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(lock);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等一会再检查状态</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// thread1占用同步锁，thread2状态为 BLOCKED</span></span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">byte</span>[] lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h3><p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态</p>
<p>一个线程会进入这个状态，一定是执行了如下的代码</p>
<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()</li>
</ul>
<p>当一个线程执行了Object.wait()的时候，它一定在等待另一个线程执行Object.notify()或者Object.notifyAll()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaiting1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] LOCK = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread(LOCK);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 此时thread休眠，状态为 WAITING</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            LOCK.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时thread被唤醒，状态为 RUNNABLE</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">byte</span>[] lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// wait并允许其他线程同步lock</span></span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者一个线程thread，其在主线程中被执行了thread.join()的时候，主线程即会等待该线程执行完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaiting2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread1 thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        MyThread2 thread2 = <span class="keyword">new</span> MyThread2(thread1);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// thread2中有个thread.join()，会等待该线程执行完</span></span><br><span class="line">        <span class="comment">// 此时thread2状态为 WAITING</span></span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程执行了 LockSupport.park() 的时候，其在等待执行 LockSupport.unpark(thread)。当该线程处于这种等待的时候，其状态即为 WAITING。需要关注的是，这边的等待是没有时间限制的，当发现有这种状态的线程的时候，若其长时间处于这种状态，也需要关注下程序内部有无逻辑异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaiting3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等一会再检查状态</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// thread状态为 WAITING</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h3><p>这个状态和 <strong>WAITING</strong> 状态的区别就是，这个状态的等待是有一定时效的，即可以理解为 <strong>WAITING</strong> 状态等待的时间是永久的，即必须等到某个条件符合才能继续往下走，否则线程不会被唤醒。但是 <strong>TIMED_WAITING</strong> 在等待一段时间之后，会唤醒线程去重新获取锁。当执行如下代码的时候，对应的线程会进入到 <strong>TIMED_WAITING</strong> 状态</p>
<ul>
<li>Thread.sleep(long)</li>
<li>Object.wait(long)</li>
<li>Thread.join(long)</li>
<li>LockSupport.parkNanos()</li>
<li>LockSupport.parkUntil()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTimedWaiting1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// thread中调用了 Thread.sleep(10000)</span></span><br><span class="line">        <span class="comment">// 此时thread状态为 TIMED_WAITING</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTimedWaiting2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread2(lock);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// thread中调用了 lock.wait(1000)</span></span><br><span class="line">        <span class="comment">// 此时thread状态为 TIMED_WAITING</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(Object lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock=lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 此处1s之后线程醒来，会重新尝试去获取锁</span></span><br><span class="line">                <span class="comment">// 如果拿不到，后面的代码也不执行</span></span><br><span class="line">                lock.wait(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>当线程的 run() 方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止，就不能再运行<br>如果在终止的线程上调用 start() 方法时会抛出<code>java.lang.IllegalThreadStateException</code>异常</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程(1)：概念</title>
    <url>/2020/03/27/46089/</url>
    <content><![CDATA[<h2 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h2><ul>
<li><strong>程序</strong>是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念</li>
<li><strong>进程</strong>是执行程序的一次执行过程，它是一个动态的概念，是系统资源分配的单位</li>
<li>在一个进程中可以包含一个或若干个<strong>线程</strong>，线程是CPU调度和执行的单位，每个进程都有自己独立的一块内存空间</li>
<li>线程总是属于某个进程，进程中的多个线程共享进程的内存</li>
<li>多线程大多是模拟出来的，即在同一个时间点，CPU只能执行一个代码，因为切换的很快，就会有同时执行的错觉</li>
</ul>
<h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><ul>
<li>线程就是独立的执行路径</li>
<li>在程序执行时，即使没有自己创建线程，后台也会有多个线程，如主线程，GC线程</li>
<li>main() 称为主线程，是程序的入口，用于执行整个程序</li>
<li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度。调度器是和操作系统紧密相关的，先后顺序是不能人为干预的</li>
<li>对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制</li>
<li>线程会带来额外的开销，如CPU调度时间，并非控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li>
</ul>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><blockquote>
<ol>
<li>自定义线程继承 <strong>Thread</strong> 类</li>
<li>重写 <strong>run()</strong> 方法，编写线程执行体</li>
<li>创建线程对象，调用 <strong>start()</strong> 方法启动线程</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程==="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程1===="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><blockquote>
<ol>
<li>自定义类实现 <strong>Runnable</strong> 接口</li>
<li>实现 <strong>run()</strong> 方法，编写线程执行体</li>
<li>创建线程对象，调用 <strong>start()</strong> 方法启动线程</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程==="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程1===="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更推荐使用，避免单继承的局限性，灵活方便</p>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><blockquote>
<ol>
<li>实现 <strong>Callable</strong> 接口</li>
<li>实现 <strong>call()</strong> 方法，编写线程执行体，该方法有返回值</li>
<li>使用 <strong>FutureTask</strong> 类来包装 <strong>Callable</strong> 对象，并通过其创建并启动新线程</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable1());</span><br><span class="line">        <span class="keyword">new</span> Thread(task, <span class="string">"子线程"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"===="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"子线程的返回值"</span> + task.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"===="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一些常见问题"><a href="#一些常见问题" class="headerlink" title="一些常见问题"></a>一些常见问题</h2><ol>
<li>一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定</li>
<li>线程都可以设置名字，也可以获取线程的名字，包括主线程</li>
<li>获取当前线程的对象的方法是：Thread.currentThread()</li>
<li>一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证</li>
<li>当线程目标run()方法结束时该线程完成</li>
<li>一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动</li>
<li>线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程</li>
<li>众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的</li>
<li>尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列唱呢个一个队列的事实</li>
<li>尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：LinkedList</title>
    <url>/2020/03/23/50293/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LinkedList是一个以双向链表实现的List，它除了作为List使用，还可以作为队列或者栈来使用</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>AbstractSequentialList&lt;E&gt;</strong>：供List 接口的基本实现，以最大程度地减少实现由“顺序访问”数据存储（例如链表）支持的接口所需的工作</li>
<li>实现了<strong>List&lt;E&gt;</strong>：提供了基础的添加、删除、遍历等操作</li>
<li>实现了<strong>Deque&lt;E&gt;</strong>：定义了访问双端队列两端的元素的方法</li>
<li>实现了<strong>Cloneable</strong>：可以被克隆</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表首节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 典型的双链表结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个Collection</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>addFirst(E e)</strong> 在队首添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在队首添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 创建新阶节点，新节点的next是首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 让新节点作为新的首节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 判断是不是第一个添加的元素</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 是就把last也置为新节点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则把原首节点的prev指针置为新节点</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>addLast(E e)</strong> 在队尾添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建新阶节点，新节点的prev是尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断是不是第一个添加的元素</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 是就把first也置为新节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则把原首节点的next指针置为新节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add(int index, E element)</strong> 指定位置添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 如果添加位置在队列尾节点</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到待添加节点的前置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 在其前置节点和后继节点之间创建一个新节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 判断是不是第一个添加的元素</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 是就把first也置为新节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则把pred的next指针置为新节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找index位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据index是在前半段还是后半段决定从前遍历还是从后遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 从前向后遍历</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从后向前遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>removeFirst()</strong> 删除首节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 如果没有元素抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>removeLast()</strong> 删除尾节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 如果没有元素抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(int index)</strong> 删除指定位置元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">// 待删除节点的后置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 待删除节点的前置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除的是首节点，首节点设为next</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// prev的后置节点置为next</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//删除的是尾节点，尾节点设为prev</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// next的前置节点设为prev</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object o)</strong> 移除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>LinkedList是一个以双链表实现的List</li>
<li>LinkedList还是一个双端队列，具有队列、双端队列、栈的特性</li>
<li>LinkedList在队列首尾添加、删除元素非常高效，时间复杂度为$O(1)$</li>
<li>LinkedList在中间添加、删除元素比较低效，时间复杂度为$O(n)$</li>
<li>LinkedList不支持随机访问，所以访问非队列首尾的元素比较低效</li>
<li>LinkedList在功能上等于ArrayList + ArrayDeque</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：PriorityQueue</title>
    <url>/2020/03/22/26333/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PriorityQueue，优先级队列，是0个或多个元素的集合，集合中的每个元素都有一个权重值，每次出队都弹出优先级最大或最小的元素。</p>
<p>一般来说，优先级队列使用堆来实现</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>AbstractQueue&lt;K,V&gt;</strong>：提供实现Queue接口的最小化实现</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用initialCapacity和comparator初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个Collection</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">        initElementsFromCollection(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">        initFromPriorityQueue(pq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">        initFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个PriorityQueue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">    initFromPriorityQueue(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个SortedSet</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(SortedSet&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>add(E e)</strong>和<strong>offer(E e)</strong> 入队</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add和offer是一致的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不能添加null</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 去size</span></span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="comment">// 元素到达最大容量时扩容</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 元素插入时的调整</span></span><br><span class="line">    siftUp(i, e);</span><br><span class="line">    <span class="comment">// 元素个数加一</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自底向上调整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有比较器，使用不同的方法</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x, queue, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x, queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] es)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到父节点的位置</span></span><br><span class="line">        <span class="comment">// 因为元素是从0开始的，所以减1之后再除以2</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 父节点的值</span></span><br><span class="line">        Object e = es[parent];</span><br><span class="line">        <span class="comment">// 比较插入的元素与父节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果比父节点大，则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则交换位置</span></span><br><span class="line">        es[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后找到应该插入的位置，放入元素</span></span><br><span class="line">    es[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> k, T x, Object[] es, Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到父节点的位置</span></span><br><span class="line">        <span class="comment">// 因为元素是从0开始的，所以减1之后再除以2</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 父节点的值</span></span><br><span class="line">        Object e = es[parent];</span><br><span class="line">        <span class="comment">// 比较插入的元素与父节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果比父节点大，则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则交换位置</span></span><br><span class="line">        es[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后找到应该插入的位置，放入元素</span></span><br><span class="line">    es[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grow(int minCapacity)</strong> 扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// 旧容量小于64时，容量翻倍</span></span><br><span class="line">    <span class="comment">// 旧容量大于等于64，容量只增加旧容量的一半</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 如果扩容后的容量大于临界值，则调用hugeCapacity方法进行大容量分配</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 创建出一个新容量大小的新数组并把旧数组元素拷贝过去</span></span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// minCapacity小于0则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//如果想要的容量大于MAX_ARRAY_SIZE，则分配Integer.MAX_VALUE，否则分配MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object o)</strong> 删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找元素o在数组中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 没有找到返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到了删除这个元素</span></span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 元素个数减1</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i)</span><br><span class="line">        <span class="comment">// 如果要删除的是最后一个元素</span></span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 需要移动的元素</span></span><br><span class="line">        E moved = (E) es[s];</span><br><span class="line">        es[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 先自顶向下调整</span></span><br><span class="line">        siftDown(i, moved);</span><br><span class="line">        <span class="keyword">if</span> (es[i] == moved) &#123;</span><br><span class="line">            <span class="comment">// 如果</span></span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (es[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自顶向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有比较器，使用不同的方法</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x, queue, size, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x, queue, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] es, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">    <span class="comment">// 找到最后一个有字节点的元素</span></span><br><span class="line">    <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 左节点位置</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左节点的值</span></span><br><span class="line">        Object c = es[child];</span><br><span class="line">        <span class="comment">// 右节点位置</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果左节点大于右节点，则将c复制为右孩子的值，这里也就是找出左右孩子哪个最小</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) es[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = es[child = right];</span><br><span class="line">        <span class="comment">// 如果队尾元素比根元素孩子都要小，则不需"下移"，结束</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 队尾元素比根元素孩子都大，则需要"下移"</span></span><br><span class="line">        <span class="comment">// 交换跟元素和孩子c的位置</span></span><br><span class="line">        es[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到队尾元素x的合适位置k之后进行赋值</span></span><br><span class="line">    es[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> k, T x, Object[] es, <span class="keyword">int</span> n, Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到最后一个有字节点的元素</span></span><br><span class="line">    <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 左节点位置</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左节点的值</span></span><br><span class="line">        Object c = es[child];</span><br><span class="line">        <span class="comment">// 右节点位置</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果左节点大于右节点，则将c复制为右孩子的值，这里也就是找出左右孩子哪个最小</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) es[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = es[child = right];</span><br><span class="line">        <span class="comment">// 如果队尾元素比根元素孩子都要小，则不需"下移"，结束</span></span><br><span class="line">        <span class="keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 队尾元素比根元素孩子都大，则需要"下移"</span></span><br><span class="line">        <span class="comment">// 交换跟元素和孩子c的位置</span></span><br><span class="line">        es[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到队尾元素x的合适位置k之后进行赋值</span></span><br><span class="line">    es[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>poll()</strong> 出队</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> E result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((result = (E) ((es = queue)[<span class="number">0</span>])) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">final</span> E x = (E) es[(n = --size)];</span><br><span class="line">        es[n] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 出队后的调整</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; cmp;</span><br><span class="line">            <span class="keyword">if</span> ((cmp = comparator) == <span class="keyword">null</span>)</span><br><span class="line">                siftDownComparable(<span class="number">0</span>, x, es, n);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftDownUsingComparator(<span class="number">0</span>, x, es, n, cmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>PriorityQueue是一个小顶堆</li>
<li>PriorityQueue是非线程安全的</li>
<li>PriorityQueue不是有序的，只有堆顶存储着最小的元素</li>
<li>入队就是堆的插入元素的实现</li>
<li>出队就是堆的删除元素的实现</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：CopyOnWriteArraySet</title>
    <url>/2020/03/22/36265/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CopyOnWriteArraySet底层是使用CopyOnWriteArrayList存储元素</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>AbstractSet&lt;E&gt;</strong>：提供实现Set接口的最小化实现</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用CopyOnWriteArrayList存储元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化al</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将集合c中的元素初始化到CopyOnWriteArraySet中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArraySet<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) CopyOnWriteArraySet&lt;E&gt; cc =</span><br><span class="line">            (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;(cc.al);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果c不是CopyOnWriteArraySet类型，说明有重复元素</span></span><br><span class="line">        <span class="comment">// 调用CopyOnWriteArrayList的addAllAbsent()方法初始化</span></span><br><span class="line">        <span class="comment">// 它会把重复元素排除掉</span></span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">        al.addAllAbsent(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>CopyOnWriteArraySet的方法基本是都是调用CopyOnWriteArrayList的方法实现的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>CopyOnWriteArraySet是用CopyOnWriteArrayList实现的</li>
<li>CopyOnWriteArraySet是有序的，因为底层其实是数组</li>
<li>CopyOnWriteArraySet是并发安全的，而且实现了读写分离</li>
<li>CopyOnWriteArraySet通过调用CopyOnWriteArrayList的addIfAbsent()方法来保证元素不重复</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：TreeSet</title>
    <url>/2020/03/22/28688/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TreeSet是底层采用TreeMap实现的一种Set，所以它是有序的、非线程安全的</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>AbstractSet&lt;E&gt;</strong>：提供实现Set接口的最小化实现</li>
<li>实现了<strong>NavigableSet&lt;E&gt;</strong>：具有了针对给定搜索目标返回最接近匹配项的导航方法</li>
<li>实现了<strong>Cloneable</strong>：可以被克隆</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素存储在NavigableMap中，注意它不一定就是TreeMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟元素, 用来作为value存储在map中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接使用传进来的NavigableMap存储元素</span></span><br><span class="line"><span class="comment">// 这里不是深拷贝,如果外面的map有增删元素也会反映到这里</span></span><br><span class="line"><span class="comment">// 这是个非public构造方法</span></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用TreeMap初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用带comparator的TreeMap初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将集合c中的所有元素添加的TreeSet中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将SortedSet中的所有元素添加到TreeSet中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>add(E e)</strong> 添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用TreeMap的put方法，把元素本身作为key，PRESENT作为value</span></span><br><span class="line">    <span class="comment">// 也就是说这个map中所有的value都是一样的</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object o)</strong> 移除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用TreeMap的remove()方法</span></span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>contains(Object o)</strong> 查询元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用map的containsKey()方法</span></span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>iterator()</strong> 遍历元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接返回map的navigableKeySet迭代器</span></span><br><span class="line">    <span class="keyword">return</span> map.navigableKeySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>TreeSet底层使用NavigableMap存储元素</li>
<li>TreeSet是有序的、非线程安全的</li>
<li>TreeSet实现了NavigableSet接口，而NavigableSet继承自SortedSet接口</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：LinkedHashSet</title>
    <url>/2020/03/22/42122/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HashSet中的元素是无序的，而LinkedHashSet中的元素是有序的</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>HashSet&lt;E&gt;</strong>：LinkedHashSet基本都是调用HashSet的方法</li>
<li>实现了<strong>Set&lt;E&gt;</strong>：具有Set的所有功能</li>
<li>实现了<strong>Cloneable</strong>：可以被克隆</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这4个构造方法都是调用HashSet中的<code>super(initialCapacity, loadFactor, true)</code>方法，这个方法使用LinkedHashMap来初始化HashSet中的Map</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>LinkedHashSet没有再重写add、remove、contains等方法，都是直接使用HashSet中的实现</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>LinkedHashSet的底层使用LinkedHashMap存储元素</li>
<li>LinkedHashSet是有序的，它是按照插入的顺序排序的</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：HashSet</title>
    <url>/2020/03/22/32132/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HashSet是依赖于HashMap的Set接口的实现，实际上是个HashMap的实例</p>
<p>HashSet的特点是不保证set的迭代顺序，特别是它不保证该顺序恒久不变，允许使用null 元素</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>AbstractSet&lt;E&gt;</strong>：提供实现Set接口的最小化实现</li>
<li>实现了<strong>Set&lt;E&gt;</strong>：具有Set的所有功能</li>
<li>实现了<strong>Cloneable</strong>：可以被克隆</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部使用HashMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟对象，用来作为value放到map中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要是用于LinkedHashSet</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>add(E e)</strong> 添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用HashMap的put方法，把元素本身作为key，PRESENT作为value</span></span><br><span class="line">    <span class="comment">// 也就是说这个map中所有的value都是一样的</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object o)</strong> 移除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用HashMap的remove()方法</span></span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>contains(Object o)</strong> 查询元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set没有get()方法，要一个检查元素是否存在使用contains()，直接调用map的containsKey()方法</span></span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>iterator()</strong> 遍历元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接返回map的keySet迭代器</span></span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>HashSet内部使用HashMap的key存储元素，以此来保证元素不重复</li>
<li>HashSet是无序的，因为HashMap的key是无序的</li>
<li>HashSet中允许有一个null元素，因为HashMap允许key为null</li>
<li>HashSet是非线程安全的</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：ConcurrentSkipListMap</title>
    <url>/2020/03/22/17546/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>跳表是一个随机化的数据结构，实际上就是一种可以二分查找的有序链表</p>
<p>跳表在原有的有序链表上增加了多级索引，通过索引来实现快速查找</p>
<p>调表不仅能提供搜索性能，同时也可提高插入和删除操作的性能</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentNavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现了<strong>ConcurrentNavigableMap&lt;K,V&gt;</strong>：同步的NavigableMap</li>
<li>实现了<strong>Cloneable</strong>：可以被克隆</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据节点，典型的单链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">// currently, never detached</span></span><br><span class="line">    V val;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 索引节点，存储着对应的node值，及向下和向右的索引指针</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">    Index&lt;K,V&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = m.comparator();</span><br><span class="line">    buildFromSorted(m); <span class="comment">// initializes transients</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不能存储值为null的元素</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Index&lt;K,V&gt; h; Node&lt;K,V&gt; b;</span><br><span class="line">        VarHandle.acquireFence();</span><br><span class="line">        <span class="keyword">int</span> levels = <span class="number">0</span>;                    <span class="comment">// number of levels descended</span></span><br><span class="line">        <span class="keyword">if</span> ((h = head) == <span class="keyword">null</span>) &#123;          <span class="comment">// try to initialize</span></span><br><span class="line">            Node&lt;K,V&gt; base = <span class="keyword">new</span> Node&lt;K,V&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            h = <span class="keyword">new</span> Index&lt;K,V&gt;(base, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            b = (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, h)) ? base : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r, d;;) &#123; <span class="comment">// count while descending</span></span><br><span class="line">                <span class="keyword">while</span> ((r = q.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; p; K k;</span><br><span class="line">                    <span class="keyword">if</span> ((p = r.node) == <span class="keyword">null</span> || (k = p.key) == <span class="keyword">null</span> ||</span><br><span class="line">                        p.val == <span class="keyword">null</span>)</span><br><span class="line">                        RIGHT.compareAndSet(q, r, r.right);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>)</span><br><span class="line">                        q = r;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((d = q.down) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ++levels;</span><br><span class="line">                    q = d;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    b = q.node;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; z = <span class="keyword">null</span>;              <span class="comment">// new node, if inserted</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;                       <span class="comment">// find insertion point</span></span><br><span class="line">                Node&lt;K,V&gt; n, p; K k; V v; <span class="keyword">int</span> c;</span><br><span class="line">                <span class="keyword">if</span> ((n = b.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b.key == <span class="keyword">null</span>)       <span class="comment">// if empty, type check key now</span></span><br><span class="line">                        cpr(cmp, key, key);</span><br><span class="line">                    c = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((k = n.key) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// can't append; restart</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((v = n.val) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlinkNode(b, n);</span><br><span class="line">                    c = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((c = cpr(cmp, key, k)) &gt; <span class="number">0</span>)</span><br><span class="line">                    b = n;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         (onlyIfAbsent || VAL.compareAndSet(n, v, value)))</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    NEXT.compareAndSet(b, n,</span><br><span class="line">                                       p = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n))) &#123;</span><br><span class="line">                    z = p;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (z != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> lr = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">                <span class="keyword">if</span> ((lr &amp; <span class="number">0x3</span>) == <span class="number">0</span>) &#123;       <span class="comment">// add indices with 1/4 prob</span></span><br><span class="line">                    <span class="keyword">int</span> hr = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">                    <span class="keyword">long</span> rnd = ((<span class="keyword">long</span>)hr &lt;&lt; <span class="number">32</span>) | ((<span class="keyword">long</span>)lr &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">                    <span class="keyword">int</span> skips = levels;      <span class="comment">// levels to descend before add</span></span><br><span class="line">                    Index&lt;K,V&gt; x = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;               <span class="comment">// create at most 62 indices</span></span><br><span class="line">                        x = <span class="keyword">new</span> Index&lt;K,V&gt;(z, x, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (rnd &gt;= <span class="number">0L</span> || --skips &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            rnd &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (addIndices(h, skips, x, cmp) &amp;&amp; skips &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        head == h) &#123;         <span class="comment">// try to add new level</span></span><br><span class="line">                        Index&lt;K,V&gt; hx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, x, <span class="keyword">null</span>);</span><br><span class="line">                        Index&lt;K,V&gt; nh = <span class="keyword">new</span> Index&lt;K,V&gt;(h.node, h, hx);</span><br><span class="line">                        HEAD.compareAndSet(<span class="keyword">this</span>, h, nh);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (z.val == <span class="keyword">null</span>)       <span class="comment">// deleted while adding indices</span></span><br><span class="line">                        findPredecessor(key, cmp); <span class="comment">// clean</span></span><br><span class="line">                &#125;</span><br><span class="line">                addCount(<span class="number">1L</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识：锁</title>
    <url>/2020/03/21/1211/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下图是锁的总体分类：</p>
<img src="/2020/03/21/1211/lock1.png" class="">

<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>乐观锁和悲观锁是一种广义的概念，它们体现了看待线程同步的不同角度</p>
<p>悲观锁认为在自己使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确定数据不会被别的线程修改。这样别的线程再要拿数据是时候就会被挡住，直到悲观锁释放，向获取数据的线程先去获取锁，再获取数据</p>
<p>乐观锁认为自己再使用数据的时候不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果没有更新，当前线程将自己修改的数据成功写入；如果数据已经被其其它线程更新，则根据不同的实现方式执行不同的操作(例如重试或报错)</p>
<p><strong>悲观锁阻塞事务，乐观锁回滚重试。</strong>它们各有优缺点，没有好坏之分，只有适应场景的不同：悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确；乐观锁适合读操作多的场景，不加锁的特点能够大幅提升性能</p>
<p>下面是悲观锁和乐观锁的调用方式示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 悲观锁的调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// 操作同步资源</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乐观锁的调用方式</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">atomicInteger.incrementAndGet();</span><br></pre></td></tr></table></figure>

<p>可以看到，悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接操作同步资源。为何乐观锁能不锁定同步资源也能正确地实现线程同步呢？因为乐观锁的主要实现方式是CAS</p>
<h3 id="乐观锁的基础：CAS"><a href="#乐观锁的基础：CAS" class="headerlink" title="乐观锁的基础：CAS"></a>乐观锁的基础：CAS</h3><p>CAS(Compare-and-Swap)，即比较并替换，是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步</p>
<ul>
<li>比较：读取到一个值A，在将其更新为B之前，检查原值是否为A</li>
<li>替换：如果是，更新A为B，介绍。否则，不会进行更新</li>
</ul>
<p>这两步操作都是原子操作，可以认为是瞬间完成，在CPU看来就是一步操作</p>
<p>有了cas，就可以实现一个乐观锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享数据</span></span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldData = data;</span><br><span class="line">        <span class="keyword">int</span> newData = doSomething(oldData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟CAS更新操作</span></span><br><span class="line">        <span class="keyword">if</span> (data == oldData) &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，上面的代码根本不是原子性的，只是展示了一下CAS的流程。因为真正的CAS利用了CPU指令，Java中也是通过native方法实现的CAS:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected, Object x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>从乐观锁的整个流程中可以看出，其实并没有加锁和解锁的操作，因此乐观锁策略也被称作无锁编程。换句话说，乐观锁其实并不是 “锁”，它仅仅是一个循环重试的CAS算法而已</p>
<h2 id="自旋锁和适应性自旋锁"><a href="#自旋锁和适应性自旋锁" class="headerlink" title="自旋锁和适应性自旋锁"></a>自旋锁和适应性自旋锁</h2><p>阻塞或唤醒一个Java线程需要操作系统切换CPU来完成，这种状态切换需要耗费处理器时间。如果同步代码块中的操作过于简单，状态切换消耗的时间可能比用户代码执行的时间还要长</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复线程的花费可能让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁</p>
<p>而为了让当前线程 “稍等一下”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁</p>
<img src="/2020/03/21/1211/lock2.png" class="">

<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程</p>
<p>自适应锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源</p>
<h2 id="无锁、偏向锁、轻量级锁和重量级锁"><a href="#无锁、偏向锁、轻量级锁和重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁和重量级锁"></a>无锁、偏向锁、轻量级锁和重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态</p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</p>
<p>下面是ReentrantLock的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可知，ReentranrLock有一个内部类Sync，添加和释放锁的大部分操作都是在Sync中完成的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可显式指定使用公平锁</p>
<p>下面是公平锁和非公平锁的加锁方式的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，两者的唯一区别就是在于公平锁在获取同步状态时多了一个判限制条件：hasQueuedPredecessors()，该方法主要做一件事情：判断当前线程是否位于同步队列的第一个，如果是则返回true，否则返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = h.next) == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>; <span class="comment">// traverse in case of concurrent cancellation</span></span><br><span class="line">            <span class="keyword">for</span> (Node p = tail; p != h &amp;&amp; p != <span class="keyword">null</span>; p = p.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s.thread != Thread.currentThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况</p>
<h2 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1执行..."</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，类中的两个方法都是被synchronized修饰的，doSomething()方法调用doOthers()方法。因为synchronized是可重入的，所以同一个线程在调用doOthers()可以直接获得当前对象的锁，进入doOthers()进行操作</p>
<p>如果是一个非可重入锁，那么线程在调用doOthers()之前需要把执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已经被当前线程持有，且无法释放，就会出现死锁</p>
<p> Java 中的锁基本都是可重入锁，不可重入锁的意义不是很大</p>
<h2 id="共享锁和独享锁"><a href="#共享锁和独享锁" class="headerlink" title="共享锁和独享锁"></a>共享锁和独享锁</h2><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是独享锁</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：ConcurrentHashMap</title>
    <url>/2020/03/21/18323/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ConcurrentHashMap是HashMap的线程安全版本，内部也是使用数组+链表+红黑树的结构来存储元素</p>
<p>相比于同样线程安全的Hashtable来说，效率等各方面都有极大地提高</p>
<h2 id="各种锁简介"><a href="#各种锁简介" class="headerlink" title="各种锁简介"></a>各种锁简介</h2><p>这里简单介绍一下各种锁，关于锁的详细介绍可查看：<a href="/2020/03/21/1211/">Java基础知识：锁</a></p>
<ol>
<li><p>synchronized</p>
<p>java中的关键字，内部实现为监视器锁，主要是通过对象监视器在对象头中的字段来表明的</p>
<p>synchronized从旧版本到现在已经做了很多优化了，在运行时会有三种存在方式：</p>
<ul>
<li><p>偏向锁，是指一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价</p>
</li>
<li><p>轻量级锁，是指当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，这个线程会通过自旋的方式尝试获取锁，不会阻塞，提高性能</p>
</li>
<li><p>重量级锁，是指当锁是轻量级锁时，当自旋的线程自旋了一定的次数后，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级锁会使其他线程阻塞，性能降低</p>
</li>
</ul>
</li>
<li><p>CAS</p>
<p>CAS，Compare And Swap，它是一种乐观锁，认为对于同一个数据的并发操作不一定会发生修改，在更新数据的时候，尝试去更新数据，如果失败就不断尝试</p>
</li>
<li><p>volatile</p>
<p>java中的关键字，当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p>
</li>
<li><p>自旋锁</p>
<p>尝试获取锁的线程不会阻塞，而是循环的方式不断尝试，这样的好处是减少线程的上下文切换带来的开锁，提高性能，缺点是循环会消耗CPU</p>
</li>
<li><p>分段锁</p>
<p>是一种锁的设计思路，它细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了</p>
</li>
<li><p>可重入锁</p>
<p>指一个线程获取锁之后再尝试获取锁时会自动获取锁，可重入锁的优点是避免死锁。synchronized也是可重入锁</p>
</li>
</ol>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>AbstractMap&lt;K,V&gt;</strong>：提供Map的基本实现</li>
<li>实现了<strong>ConcurrentMap&lt;K,V&gt;</strong>：提供线程安全性和原子性保证</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大的表容量1&lt;&lt;30</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的表初始容量，必须是2的幂次方，最小是1，最大为MAXIMUM_CAPACITY</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大的数组大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表默认的并发级别，未使用，为兼容以前的版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认加载因子，在构造方法中重写此值只影响初始表容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表转红黑树的阈值8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树转链表的阈值6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当桶的个数达到64的时候才进行树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小的表容量，其中的箱子可以treeified。(否则，如果一个bin中有太多节点，则会调整表的大小。)</span></span><br><span class="line"><span class="comment">// 该值应该至少为4 * TREEIFY_THRESHOLD，以避免调整大小和treeification阈值之间的冲突</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于生成戳记的位的数目，单位为sizeCtl</span></span><br><span class="line"><span class="comment">// 32位数组必须至少为6</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以帮助调整大小的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用sizeCtl记录尺寸戳的位偏移</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点哈希字段的编码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// forwarding nodes的哈希</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 树根节点的哈希</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// ReservationNode的hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// 普通节点哈希的可用位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpu的数量，以限制某些大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认为null，初始化发生在第一次插入操作</span></span><br><span class="line"><span class="comment">// 默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 默认为null，扩容时新生成的数组，其大小为原数组的两倍</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义</span></span><br><span class="line"><span class="comment">// 当为负数时：-1代表正在初始化，-N代表有N-1个线程正在进行扩容</span></span><br><span class="line"><span class="comment">// 当为0时：代表当时的table还没有被初始化</span></span><br><span class="line"><span class="comment">// 当为正数时：表示初始化或者下一次进行扩容的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储结构的基本单元，继承自HashMap中的Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个特殊的节点，用于存放nextTable的引用，hash值为-1</span></span><br><span class="line"><span class="comment">// 只有table发生扩容的时候，ForwardingNode才会发挥作用</span></span><br><span class="line"><span class="comment">// 作为一个占位符放在table中表示当前节点为null或则已经被移动</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自Node，但是数据结构换成了二叉树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装TreeNode的容器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, LOAD_FACTOR, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>put(K key, V value)</strong> 添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key和value都不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 两次计算hash，减少hash冲突</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 要插入的元素所在桶的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 死循环，配合CAS使用。如果CAS失败则会重新取整个桶进行下面的流程</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果桶未初始化或个数为0，则初始化桶</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果要插入的元素所在的桶还没有元素</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="comment">// 如果使用CAS插入元素时，发现已经有元素了，则进入下一次循环，重新操作</span></span><br><span class="line">                <span class="comment">// 如果使用CAS插入元素成功，则break跳出循环，流程结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 如果要插入的元素所在的桶的第一个元素的hash是MOVED</span></span><br><span class="line">            <span class="comment">// 说明当前f是ForwardingNode节点，意味有其它线程正在扩容，则一起进行扩容操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="keyword">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果这个桶不为空且不在迁移元素，则锁住这个桶（分段锁）</span></span><br><span class="line">            <span class="comment">// 并查找要插入的元素是否在这个桶中</span></span><br><span class="line">            <span class="comment">// 存在，则替换值（onlyIfAbsent=false）</span></span><br><span class="line">            <span class="comment">// 不存在，则插入到链表结尾或插入树中</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树）</span></span><br><span class="line">                    <span class="comment">// 那就是桶中的元素使用的是链表方式存储</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 桶中元素个数赋值为1</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历整个桶，每次结束binCount加1</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">// 如果找到了这个元素，则赋值了新值（onlyIfAbsent=false）</span></span><br><span class="line">                                <span class="comment">// 并退出循环</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 如果到链表尾部还没有找到元素</span></span><br><span class="line">                                <span class="comment">// 就把它插入到链表结尾并退出循环</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 如果第一个元素是树节点</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">// 桶中元素个数赋值为2</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插入方法插入元素</span></span><br><span class="line">                        <span class="comment">// 如果成功插入则返回null</span></span><br><span class="line">                        <span class="comment">// 否则返回寻找到的节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果找到了这个元素，则赋值了新值（onlyIfAbsent=false）</span></span><br><span class="line">                            <span class="comment">// 并退出循环</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果binCount不为0，说明成功插入了元素或者寻找到了元素</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表元素个数达到了8，则尝试树化</span></span><br><span class="line">                <span class="comment">// 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数</span></span><br><span class="line">                <span class="comment">// 所以不会重复树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 如果要插入的元素已经存在，则返回旧值</span></span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="comment">// 退出外层大循环，流程结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功插入元素，元素个数加1（是否要扩容在这个里面）</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="comment">// 成功插入元素返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>initTable()</strong> 初始化哈希表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// table为空时才能进入初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// sizeCtl小于0表示其他线程已经在初始化或扩容，挂起当前线程</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果把sizeCtl原子更新为-1成功，则当前线程进入初始化</span></span><br><span class="line">            <span class="comment">// 如果原子更新失败则说明有其它线程先一步进入初始化了，则进入下一次循环</span></span><br><span class="line">            <span class="comment">// 如果下一次循环时还没初始化完毕，则sizeCtl&lt;0进入上面if的逻辑让出CPU</span></span><br><span class="line">            <span class="comment">// 如果下一次循环更新完毕了，则table.length!=0，退出循环</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次检查table是否为空，防止ABA问题</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果sc为0则使用默认值16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">// 新建数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 赋值给table桶数组</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 设置sc为数组长度的0.75倍</span></span><br><span class="line">                    <span class="comment">// n - (n &gt;&gt;&gt; 2) = n - n/4 = 0.75n</span></span><br><span class="line">                    <span class="comment">// 可见这里装载因子和扩容门槛都是写死了的</span></span><br><span class="line">                    <span class="comment">// 这也正是没有threshold和loadFactor属性的原因</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 把sc赋值给sizeCtl，这时存储的是扩容门槛</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>addCount(long x, int check)</strong> 判断是否需要扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] cs; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 这里使用的思想跟LongAdder类是一模一样的（后面会讲）</span></span><br><span class="line">    <span class="comment">// 把数组的大小存储根据不同的线程存储到不同的段上（也是分段锁的思想）</span></span><br><span class="line">    <span class="comment">// 并且有一个baseCount，优先更新baseCount，如果失败了再更新不同线程对应的段</span></span><br><span class="line">    <span class="comment">// 这样可以保证尽量小的减少冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上</span></span><br><span class="line">    <span class="keyword">if</span> ((cs = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSetLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell c; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果as为空或者长度为0</span></span><br><span class="line">        <span class="comment">// 或者当前线程所在的段为null</span></span><br><span class="line">        <span class="comment">// 或者在当前线程的段上加数量失败</span></span><br><span class="line">        <span class="keyword">if</span> (cs == <span class="keyword">null</span> || (m = cs.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (c = cs[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">// 强制增加数量（无论如何数量是一定要加上的，并不是简单地自旋）</span></span><br><span class="line">            <span class="comment">// 不同线程对应不同的段都更新失败了</span></span><br><span class="line">            <span class="comment">// 说明已经发生冲突了，那么就对counterCells进行扩容</span></span><br><span class="line">            <span class="comment">// 以减少多个线程hash到同一个段的概率</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 计算元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 如果元素个数达到了扩容门槛，则进行扩容</span></span><br><span class="line">        <span class="comment">// 注意，正常情况下sizeCtl存储的是扩容门槛，即容量的0.75倍</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// rs是扩容时的一个邮戳标识</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT;</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// sc&lt;0说明正在扩容中</span></span><br><span class="line">                <span class="keyword">if</span> (sc == rs + MAX_RESIZERS || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    (nt = nextTable) == <span class="keyword">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 扩容已经完成了，退出循环</span></span><br><span class="line">                    <span class="comment">// 正常应该只会触发nextTable==null这个条件，其它条件没看出来何时触发</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 扩容未完成，则当前线程加入迁移元素中</span></span><br><span class="line">                    <span class="comment">// 并把扩容线程数加1</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, rs + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 这里是触发扩容的那个线程进入的地方</span></span><br><span class="line">                <span class="comment">// sizeCtl的高16位存储着rs这个扩容邮戳</span></span><br><span class="line">                <span class="comment">// sizeCtl的低16位存储着扩容线程数加1，即(1+nThreads)</span></span><br><span class="line">                <span class="comment">// 所以官方说的扩容时sizeCtl的值为 -(1+nThreads)是错误的</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进入迁移元素</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 重新计算元素个数</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f)</strong> 协助扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 如果桶数组不为空，并且当前桶第一个元素为ForwardingNode类型，并且nextTab不为空</span></span><br><span class="line">    <span class="comment">// 说明当前桶已经迁移完毕了，才去帮忙迁移其它桶的元素</span></span><br><span class="line">    <span class="comment">// 扩容时会把旧桶的第一个元素置为ForwardingNode，并让其nextTab指向新桶数组</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length) &lt;&lt; RESIZE_STAMP_SHIFT;</span><br><span class="line">        <span class="comment">// sizeCtl&lt;0，说明正在扩容</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc == rs + MAX_RESIZERS || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 扩容线程数加1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 当前线程帮忙迁移元素</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</strong> 迁移元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="comment">// 如果nextTab为空，说明还没开始迁移</span></span><br><span class="line">        <span class="comment">// 就新建一个新桶数组</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">// 新桶数组是原桶的两倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新桶数组大小</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 新建一个ForwardingNode类型的节点，并把新桶数组存储在里面</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// 整个while循环就是在算i的值，过程太复杂，不用太关心</span></span><br><span class="line">        <span class="comment">// i的值会从n-1依次递减，感兴趣的可以打下断点就知道了</span></span><br><span class="line">        <span class="comment">// 其中n是旧桶数组的大小，也就是说i从15开始一直减到1这样去迁移元素</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">// 如果一次遍历完成了</span></span><br><span class="line">            <span class="comment">// 也就是整个map所有桶中的元素都迁移完成了</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 如果全部迁移完成了，则替换旧桶数组</span></span><br><span class="line">                <span class="comment">// 并设置下一次扩容门槛为新桶数组容量的0.75倍</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 当前线程扩容完成，把扩容线程数-1</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">// 扩容完成两边肯定相等</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 把finishing设置为true</span></span><br><span class="line">                <span class="comment">// finishing为true才会走到上面的if条件</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// i重新赋值为n</span></span><br><span class="line">                <span class="comment">// 这样会再重新遍历一次桶数组，看看是不是都迁移完成了</span></span><br><span class="line">                <span class="comment">// 也就是第二次遍历都会走到下面的(fh = f.hash) == MOVED这个条件</span></span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果桶中无数据，直接放入ForwardingNode标记该桶已迁移</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 如果桶中第一个元素的hash值为MOVED</span></span><br><span class="line">            <span class="comment">// 说明它是ForwardingNode节点</span></span><br><span class="line">            <span class="comment">// 也就是该桶已迁移</span></span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 锁定该桶并迁移元素</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次判断当前桶第一个元素是否有修改</span></span><br><span class="line">                <span class="comment">// 也就是可能其它线程先一步迁移了元素</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 把一个链表分化成两个链表</span></span><br><span class="line">                    <span class="comment">// 规则是桶中各元素的hash与桶大小n进行与操作</span></span><br><span class="line">                    <span class="comment">// 等于0的放到低位链表(low)中，不等于0的放到高位链表(high)中</span></span><br><span class="line">                    <span class="comment">// 其中低位链表迁移到新桶中的位置相对旧桶不变</span></span><br><span class="line">                    <span class="comment">// 高位链表迁移到新桶中位置正好是其在旧桶的位置加n</span></span><br><span class="line">                    <span class="comment">// 这也正是为什么扩容时容量在变成两倍的原因</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 第一个元素的hash值大于等于0</span></span><br><span class="line">                        <span class="comment">// 说明该桶中元素是以链表形式存储的</span></span><br><span class="line">                        <span class="comment">// 这里与HashMap迁移算法基本类似</span></span><br><span class="line">                        <span class="comment">// 唯一不同的是多了一步寻找lastRun</span></span><br><span class="line">                        <span class="comment">// 这里的lastRun是提取出链表后面不用处理再特殊处理的子链表</span></span><br><span class="line">                        <span class="comment">// 比如所有元素的hash值与桶大小n与操作后的值分别为 0 0 4 4 0 0 0</span></span><br><span class="line">                        <span class="comment">// 则最后后面三个0对应的元素肯定还是在同一个桶中</span></span><br><span class="line">                        <span class="comment">// 这时lastRun对应的就是倒数第三个节点</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 看看最后这几个元素归属于低位链表还是高位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 遍历链表，把hash&amp;n为0的放在低位链表中</span></span><br><span class="line">                        <span class="comment">// 不为0的放在高位链表中</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 低位链表的位置不变</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 高位链表的位置是原位置加n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 标记当前桶已迁移</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance为true，返回上面进行--i操作</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 如果第一个元素是树节点</span></span><br><span class="line">                        <span class="comment">// 也是一样，分化成两颗树</span></span><br><span class="line">                        <span class="comment">// 也是根据hash&amp;n为0放在低位树中</span></span><br><span class="line">                        <span class="comment">// 不为0放在高位树中</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">// 遍历整颗树，根据hash&amp;n是否为0分化成两颗树</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果分化的树中元素个数小于等于6，则退化成链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">// 低位树的位置不变</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 高位树的位置是原位置加n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 标记该桶已迁移</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance为true，返回上面进行--i操作</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object key)</strong>  删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;、</span><br><span class="line">    <span class="comment">// 计算hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果目标key所在的桶不存在，跳出循环返回null</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 如果正在扩容中，协助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 标记是否处理过</span></span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次验证当前桶第一个元素是否被修改过</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// fh&gt;=0表示是链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表寻找目标节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">// 找到了目标节点</span></span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                <span class="comment">// 检查目标节点旧value是否等于cv</span></span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">// 如果value不为空则替换旧值</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">// 如果前置节点不为空，删除当前节点</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">// 如果前置节点为空</span></span><br><span class="line">                                        <span class="comment">// 说明是桶中第一个元素，删除之</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="comment">// 遍历到链表尾部还没找到元素，跳出循环</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 如果是树节点</span></span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="comment">// 遍历树找到了目标节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="comment">// 检查目标节点旧value是否等于cv</span></span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    <span class="comment">// 如果value不为空则替换旧值</span></span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    <span class="comment">// 如果value为空则删除元素</span></span><br><span class="line">                                    <span class="comment">// 如果删除后树的元素个数较少则退化成链表</span></span><br><span class="line">                                    <span class="comment">// t.removeTreeNode(p)这个方法返回true表示删除节点后树的元素个数较少</span></span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果处理过，不管有没有找到元素都返回</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="comment">// 如果找到了元素，返回其旧值</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果要替换的值为空，元素个数减1</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get(Object key)</strong> 获取元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 如果元素所在的桶存在且里面有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果第一个元素就是要找的元素，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// hash小于0，说明是树或者正在扩容</span></span><br><span class="line">            <span class="comment">// 使用find寻找元素，find的寻找方式依据Node的不同子类有不同的实现方式</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历整个链表寻找元素</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>ConcurrentHashMap是HashMap的线程安全版本</li>
<li>ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素</li>
<li>ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多</li>
<li>ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等</li>
<li>ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制<ul>
<li>sizeCtl = -1，表示正在进行初始化</li>
<li>sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量</li>
<li>sizeCtl &gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛</li>
<li>sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；</li>
</ul>
</li>
<li>更新操作时如果正在进行扩容，当前线程协助扩容</li>
<li>更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想</li>
<li>整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键</li>
<li>迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕</li>
<li>元素个数的存储也是采用的分段思想，类似于LongAdder的实现</li>
<li>元素个数的更新会把不同的线程hash到不同的段上，减少资源争用</li>
<li>元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）</li>
<li>获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的</li>
<li>查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的</li>
<li>ConcurrentHashMap中不能存储key或value为null的元素；</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：红黑树</title>
    <url>/2020/03/20/25236/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>红黑树是一种含有红黑节点并且能自平衡的二叉查找树。它具有以下5个性质：</p>
<ol>
<li>每个节点要么是红色，要么是黑色</li>
<li>根节点为黑色</li>
<li>每个叶子节点(NIL)是黑色</li>
<li>每个红色节点的两个字节点都是黑色</li>
<li>任意一个节点到每个叶子节点的路径都包含相同数量的黑色节点</li>
</ol>
<p>下图为一颗简单的红黑树，其中Nil是叶子节点，并且它是黑色的。(Java中叶子节点是为null的节点)</p>
<img src="/2020/03/20/25236/redblacktree.png" class="">

<p>红黑树并不是一个<em>完美</em>平衡二叉查找树，从上图可以看到，根节点P的左子树显然比右子树高，但左子树和右子树的黑节点的层数是相等的，也即任意一个节点到到每个叶子节点的路径都包含数量相同的黑节点(性质5)。所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong></p>
<h2 id="自平衡"><a href="#自平衡" class="headerlink" title="自平衡"></a>自平衡</h2><p>红黑树能自平衡，它靠的是三种操作：左旋、右旋和变色</p>
<ul>
<li><strong>左旋</strong>：以某个节点作为支点(旋转节点)，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变</li>
<li><strong>右旋</strong>：以某个节点作为支点(旋转节点)，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变</li>
<li><strong>变色</strong>：节点的颜色由红变黑或由黑变红</li>
</ul>
<img src="/2020/03/20/25236/left.png" class="">

<img src="/2020/03/20/25236/right.png" class="">

<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p>
<ol>
<li>从根节点开始查找，把根节点设置为当前节点</li>
<li>若当前节点为空，返回null</li>
<li>若当前节点不为空，用当前节点的key跟查找key作比较</li>
<li>若当前节点key等于查找key，那么该key就是查找目标，返回当前节点</li>
<li>若当前节点key大于查找key，把当前节点的左子节点设置为当前节点，重复步骤2</li>
<li>若当前节点key小于查找key，把当前节点的右子节点设置为当前节点，重复步骤2</li>
</ol>
<img src="/2020/03/20/25236/search.png" class="">

<h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>插入操作包括两部分工作：查找插入的位置、插入后自平衡</p>
<p>查找插入的父节点，过程和查找操作区别不大：</p>
<ol>
<li>从根节点开始查找</li>
<li>若根节点为空，那么插入节点作为根节点，结束</li>
<li>若根节点不为空，那么把根节点作为当前，节点</li>
<li>若当前节点为null，返回当前节点的父节点，结束</li>
<li>若当前节点key等于查找key，那么该key所在节点就是插入节点，更新节点的值，结束</li>
<li>若当前节点key大于查找key，把当前节点的左子节点设置为当前节点，重复步骤4</li>
<li>若当前节点key小于查找key，把当前节点的右子节点设置为当前节点，重复步骤4</li>
</ol>
<img src="/2020/03/20/25236/insert1.png" class="">

<p>此时已经找到插入位置，此时插入节点。新插入的节点是红色的，原因是如果插入黑色节点，那么插入位置所在子树黑色节点总数多1，平衡必被破坏，必须做自平衡。而如果插入位置的父节点是黑色时，红黑树的黑色平衡没有被破坏，可以不做自平衡</p>
<p>所有插入情景如下图：</p>
<img src="/2020/03/20/25236/insert2.png" class="">

<h3 id="1：红黑树为空树"><a href="#1：红黑树为空树" class="headerlink" title="1：红黑树为空树"></a>1：红黑树为空树</h3><p>最简单的一种情景，直接把插入节点作为根节点就行，但注意，根据红黑树性质2还需要把插入节点设为黑色</p>
<h3 id="2：插入的节点的key已存在"><a href="#2：插入的节点的key已存在" class="headerlink" title="2：插入的节点的key已存在"></a>2：插入的节点的key已存在</h3><p>插入节点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，把节点的值更新就完成插入</p>
<h3 id="3：插入节点的父节点为黑节点"><a href="#3：插入节点的父节点为黑节点" class="headerlink" title="3：插入节点的父节点为黑节点"></a>3：插入节点的父节点为黑节点</h3><p>由于插入的节点是红色的，当插入节点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡</p>
<h3 id="4：插入节点的父节点为红节点"><a href="#4：插入节点的父节点为红节点" class="headerlink" title="4：插入节点的父节点为红节点"></a>4：插入节点的父节点为红节点</h3><p>如果插入的父节点为红节点，那么该父节点不可能为根节点，所以插入节点总是存在祖父节点。这点很重要，因为后续的旋转操作肯定需要祖父节点的参与</p>
<h4 id="4-1：叔叔节点存在并且为红节点"><a href="#4-1：叔叔节点存在并且为红节点" class="headerlink" title="4.1：叔叔节点存在并且为红节点"></a>4.1：叔叔节点存在并且为红节点</h4><p>从红黑树性质4可以，祖父节点肯定为黑节点，因为不可以同时存在两个相连的红节点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红</p>
<img src="/2020/03/20/25236/insert3.png" class="">

<img src="/2020/03/20/25236/insert4.png" class="">

<p>可以看到，我们把PP节点设为红色了，如果PP的父节点是黑色，那么无需再做任何处理；但如果PP的父节点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入节点，继续做自平衡处理，直到平衡为止</p>
<p>试想下PP刚好为根节点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根节点到叶子节点的路径中，黑色节点增加了。这也是唯一一种会增加红黑树黑色节点层数的插入情景</p>
<p>我们还可以总结出另外一个经验：红黑树的生长是自底向上的。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的</p>
<h4 id="4-2：叔叔节点不存在或为黑节点，且插入节点的父节点是祖父节点的左子节点"><a href="#4-2：叔叔节点不存在或为黑节点，且插入节点的父节点是祖父节点的左子节点" class="headerlink" title="4.2：叔叔节点不存在或为黑节点，且插入节点的父节点是祖父节点的左子节点"></a>4.2：叔叔节点不存在或为黑节点，且插入节点的父节点是祖父节点的左子节点</h4><p>单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔节点非红即为叶子节点(Nil)。因为如果叔叔节点为黑节点，而父节点为红节点，那么叔叔节点所在的子树的黑色节点就比父节点所在子树的多了，这不满足红黑树的性质5</p>
<h5 id="4-2-1：插入节点是其父节点的左子节点"><a href="#4-2-1：插入节点是其父节点的左子节点" class="headerlink" title="4.2.1：插入节点是其父节点的左子节点"></a>4.2.1：插入节点是其父节点的左子节点</h5><img src="/2020/03/20/25236/insert5.png" class="">

<h5 id="4-2-2：插入节点是其父节点的右子节点"><a href="#4-2-2：插入节点是其父节点的右子节点" class="headerlink" title="4.2.2：插入节点是其父节点的右子节点"></a>4.2.2：插入节点是其父节点的右子节点</h5><img src="/2020/03/20/25236/insert6.png" class="">

<h4 id="4-3：叔叔节点不存在或为黑节点，且插入节点的父节点是祖父节点的右子节点"><a href="#4-3：叔叔节点不存在或为黑节点，且插入节点的父节点是祖父节点的右子节点" class="headerlink" title="4.3：叔叔节点不存在或为黑节点，且插入节点的父节点是祖父节点的右子节点"></a>4.3：叔叔节点不存在或为黑节点，且插入节点的父节点是祖父节点的右子节点</h4><p>该情景对应情景4.2，只是方向反转</p>
<h5 id="4-3-1：插入节点是其父节点的左子节点"><a href="#4-3-1：插入节点是其父节点的左子节点" class="headerlink" title="4.3.1：插入节点是其父节点的左子节点"></a>4.3.1：插入节点是其父节点的左子节点</h5><img src="/2020/03/20/25236/insert7.png" class="">

<h5 id="4-3-2：插入节点是其父节点的右子节点"><a href="#4-3-2：插入节点是其父节点的右子节点" class="headerlink" title="4.3.2：插入节点是其父节点的右子节点"></a>4.3.2：插入节点是其父节点的右子节点</h5><img src="/2020/03/20/25236/insert8.png" class="">

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>红黑树的删除操作也包括两部分工作：查找目标节点、删除后自平衡。查找目标节点显然可以复用查找操作，当不存在目标节点时，忽略本次操作；当存在目标节点时，删除后就得做自平衡处理了。删除了节点后我们还需要找节点来替代删除节点的位置，不然子树跟父辈节点断开了，除非删除节点刚好没子节点，那么就不需要替代</p>
<p>二叉树删除节点找替代节点有3种情情景：</p>
<ol>
<li>若删除节点无子节点，直接删除</li>
<li>若删除节点只有一个子节点，用子节点替换删除节点</li>
<li>若删除节点有两个子节点，用后继节点（大于删除节点的最小节点）替换删除节点</li>
</ol>
<p>删除节点有一个很重要的思路：<strong>删除节点被替代后，在不考虑节点的键值的情况下，对于树来说，可以认为删除的是替代节点！</strong>如下图，在不看键值对的情况下，图17的红黑树最终结果是删除了Q所在位置的节点</p>
<img src="/2020/03/20/25236/delete1.png" class="">

<p>基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1</p>
<ul>
<li>情景2：删除节点用其唯一的子节点替换，子节点替换为删除节点后，可以认为删除的是子节点，若子节点又有两个子节点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1</li>
<li>情景3：删除节点用后继节点（肯定不存在左节点），如果后继节点有右子节点，那么相当于转换为情景2，否则转为为情景1</li>
</ul>
<p>综上所述，<strong>删除操作删除的节点可以看作删除替代节点，而替代节点最后总是在树末</strong></p>
<p>所有删除情景如下图：</p>
<img src="/2020/03/20/25236/delete2.png" class="">

<h3 id="1-替换节点是红色"><a href="#1-替换节点是红色" class="headerlink" title="1. 替换节点是红色"></a>1. 替换节点是红色</h3><p>由于替换节点时红色，删除也了不会影响红黑树的平衡，只要把替换节点的颜色设为删除的节点的颜色即可重新平衡</p>
<h3 id="2-替换节点是黑色"><a href="#2-替换节点是黑色" class="headerlink" title="2. 替换节点是黑色"></a>2. 替换节点是黑色</h3><p>当替换节点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换节点是其父节点的左子节点还是右子节点，来做不同的旋转操作，使树重新平衡</p>
<h4 id="2-1：替换节点是其父节点的左节点"><a href="#2-1：替换节点是其父节点的左节点" class="headerlink" title="2.1：替换节点是其父节点的左节点"></a>2.1：替换节点是其父节点的左节点</h4><h5 id="2-1-1：替换节点的兄弟节点为红色"><a href="#2-1-1：替换节点的兄弟节点为红色" class="headerlink" title="2.1.1：替换节点的兄弟节点为红色"></a>2.1.1：替换节点的兄弟节点为红色</h5><p>若兄弟节点是红节点，那么根据性质4，兄弟节点的父节点和子节点肯定为黑色，不会有其他子情景，我们按下图处理，得到2.1.2.3（后续讲解，这里先记住，此时R仍然是替代节点，它的新的兄弟节点SL和兄弟节点的子节点都是黑色）</p>
<img src="/2020/03/20/25236/delete3.png" class="">

<h5 id="2-1-2：替换节点的兄弟节点为黑色"><a href="#2-1-2：替换节点的兄弟节点为黑色" class="headerlink" title="2.1.2：替换节点的兄弟节点为黑色"></a>2.1.2：替换节点的兄弟节点为黑色</h5><p>当兄弟节点为黑时，其父节点和子节点的具体颜色也无法确定</p>
<h6 id="2-1-2-1：替换节点的兄弟节点的右子节点是红节点，左子节点任意颜色"><a href="#2-1-2-1：替换节点的兄弟节点的右子节点是红节点，左子节点任意颜色" class="headerlink" title="2.1.2.1：替换节点的兄弟节点的右子节点是红节点，左子节点任意颜色"></a>2.1.2.1：替换节点的兄弟节点的右子节点是红节点，左子节点任意颜色</h6><p>即将删除的左子树的一个黑色节点，显然左子树的黑色节点少1了，然而右子树又又红色节点，那么我们直接向右子树“借”个红节点来补充黑节点就好啦</p>
<img src="/2020/03/20/25236/delete4.png" class="">

<h6 id="2-1-2-2：替换节点的兄弟节点的右子节点为黑节点，左子节点为红节点"><a href="#2-1-2-2：替换节点的兄弟节点的右子节点为黑节点，左子节点为红节点" class="headerlink" title="2.1.2.2：替换节点的兄弟节点的右子节点为黑节点，左子节点为红节点"></a>2.1.2.2：替换节点的兄弟节点的右子节点为黑节点，左子节点为红节点</h6><p>兄弟节点所在的子树有红节点，我们总是可以向兄弟子树借个红节点过来，显然该情景可以转换为2.1.2.1</p>
<img src="/2020/03/20/25236/delete5.png" class="">

<h6 id="2-1-2-3：替换节点的兄弟节点的子节点都为黑节点"><a href="#2-1-2-3：替换节点的兄弟节点的子节点都为黑节点" class="headerlink" title="2.1.2.3：替换节点的兄弟节点的子节点都为黑节点"></a>2.1.2.3：替换节点的兄弟节点的子节点都为黑节点</h6><p>此次兄弟子树都没红节点“借”了，这种情景我们把兄弟节点设为红色，再把父节点当作替代节点，自底向上处理，去找父节点的兄弟节点去“借”。但为什么需要把兄弟节点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色节点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的</p>
<img src="/2020/03/20/25236/delete6.png" class="">

<h4 id="2-2：替换节点是其父节点的右节点"><a href="#2-2：替换节点是其父节点的右节点" class="headerlink" title="2.2：替换节点是其父节点的右节点"></a>2.2：替换节点是其父节点的右节点</h4><p>这种情景操作和2.1相反</p>
<h5 id="2-2-1：替换节点的兄弟节点为红色"><a href="#2-2-1：替换节点的兄弟节点为红色" class="headerlink" title="2.2.1：替换节点的兄弟节点为红色"></a>2.2.1：替换节点的兄弟节点为红色</h5><img src="/2020/03/20/25236/delete7.png" class="">

<h5 id="2-2-2：替换节点的兄弟节点为黑色"><a href="#2-2-2：替换节点的兄弟节点为黑色" class="headerlink" title="2.2.2：替换节点的兄弟节点为黑色"></a>2.2.2：替换节点的兄弟节点为黑色</h5><h6 id="2-2-2-1：替换节点的兄弟节点的右子节点是红节点，左子节点任意颜色"><a href="#2-2-2-1：替换节点的兄弟节点的右子节点是红节点，左子节点任意颜色" class="headerlink" title="2.2.2.1：替换节点的兄弟节点的右子节点是红节点，左子节点任意颜色"></a>2.2.2.1：替换节点的兄弟节点的右子节点是红节点，左子节点任意颜色</h6><img src="/2020/03/20/25236/delete8.png" class="">

<h6 id="2-2-2-2：替换节点的兄弟节点的右子节点为黑节点，左子节点为红节点"><a href="#2-2-2-2：替换节点的兄弟节点的右子节点为黑节点，左子节点为红节点" class="headerlink" title="2.2.2.2：替换节点的兄弟节点的右子节点为黑节点，左子节点为红节点"></a>2.2.2.2：替换节点的兄弟节点的右子节点为黑节点，左子节点为红节点</h6><img src="/2020/03/20/25236/delete9.png" class="">

<h6 id="2-2-2-3：替换节点的兄弟节点的子节点都为黑节点"><a href="#2-2-2-3：替换节点的兄弟节点的子节点都为黑节点" class="headerlink" title="2.2.2.3：替换节点的兄弟节点的子节点都为黑节点"></a>2.2.2.3：替换节点的兄弟节点的子节点都为黑节点</h6><img src="/2020/03/20/25236/delete10.png" class="">
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：TreeMap</title>
    <url>/2020/03/19/30067/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TreeMap使用红黑树存储元素，可以保证元素按key的大小进行遍历</p>
<p>关于红黑树的细节原理，可查看 <a href="/2020/03/20/25236/">数据结构：红黑树</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>AbstractMap&lt;K,V&gt;</strong>：实现Map接口时需要实现的工作量大大减少了</li>
<li>实现了<strong>NavigableMap</strong>：可以返回特定条件最近匹配的导航方法</li>
<li>实现了<strong>Cloneable</strong>：可以被克隆</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较器，如果没传则key需要实现Comparable接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储节点，典型的红黑树结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造方法，key必须实现Comparable接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入的Comparator用于比较两个key的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把传入的Map中元素保存到TreeMap中，key必须实现Comparable接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把传入的SortedMap中元素保存到TreeMap中,使用传入的Comparator用于比较两个key的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException | ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据key查找元素</span></span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="comment">// 找到了返回value，否则返回null</span></span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果初始化时传入了Comparator，使用getEntryUsingComparator获取元素</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="comment">// key为空时抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 把key强转为Comparable</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="comment">// 从根元素开始遍历</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 要查找的元素小于当前元素，从左子树查找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 要查找的元素大于当前元素，从右子树查找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 要查找的元素等于当前元素，直接返回当前元素</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    K k = (K) key;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从根元素开始遍历</span></span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 要查找的元素小于当前元素，从左子树查找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 要查找的元素大于当前元素，从右子树查找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 要查找的元素等于当前元素，直接返回当前元素</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>rotateLeft(Entry&lt;K,V&gt; p)</strong> 红黑树左旋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以p为支点左旋</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// p的右节点r</span></span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        <span class="comment">// 把r的左节点设为p的右节点</span></span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="comment">// 如果r的左节点不为不null，把其父节点设为p</span></span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        <span class="comment">// 把r的父节点设为p的父节点</span></span><br><span class="line">        r.parent = p.parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果p的父节点为空，把r设为根节点</span></span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            <span class="comment">// 如果p为其父节点的左节点，把r设为p的父节点的左节点</span></span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果p为其父节点的右节点，把r设为p的父节点的右节点</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        <span class="comment">// 把p设为r的左节点</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        <span class="comment">// 把r设为p的父节点</span></span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>rotateRight(Entry&lt;K,V&gt; p)</strong> 红黑树右旋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以p为支点右旋</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// p的左节点l</span></span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        <span class="comment">// 把l的右节点设为p的左节点</span></span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="comment">// 如果l的右节点不为不null，把其父节点设为p</span></span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>)</span><br><span class="line">            l.right.parent = p;</span><br><span class="line">        <span class="comment">// 把r的父节点设为p的父节点</span></span><br><span class="line">        l.parent = p.parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果p的父节点为空，把l设为根节点</span></span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            <span class="comment">// 如果p为其父节点的右节点，把l设为p的父节点的右节点</span></span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果p为其父节点的左节点，把l设为p的父节点的左节点</span></span><br><span class="line">            p.parent.left = l;</span><br><span class="line">        <span class="comment">// 把p设为l的右节点</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        <span class="comment">// 把l设为p的父节点</span></span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>put(K key, V value)</strong> 插入元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根节点为空,则直接插入到根节点</span></span><br><span class="line">        compare(key, key);</span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key比较的结果</span></span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    <span class="comment">// 用来寻找待插入节点的父节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 根基是否有comparator使用不同的分支</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果使用的是Comparator方式，key可为null，只要在comparator.compare()中允许即可</span></span><br><span class="line">        <span class="comment">// 从根节点开始遍历寻找</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 要查找的元素小于当前元素，从左子树查找</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 要查找的元素大于当前元素，从右子树查找</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 要查找的元素等于当前元素，直接返回当前元素</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果使用的是Comparable方式，key不能为nul</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 把key强转为Comparable</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="comment">// 从根节点开始遍历寻找</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 要查找的元素小于当前元素，从左子树查找</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 要查找的元素大于当前元素，从右子树查找</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 要查找的元素等于当前元素，直接返回当前元素</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到，则新建一个节点插入到树中</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果小于0插入到左子节点</span></span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果小于0插入到左子节点</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">// 插入之后的平衡</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入节点时默认插入红色节点</span></span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">// 如果父节点是祖父节点的左节点</span></span><br><span class="line">            <span class="comment">// y为叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1，叔叔节点也是红色</span></span><br><span class="line">                <span class="comment">// 父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// 叔叔节点设为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">// 祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// 把祖父节点设为新的当前节点</span></span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果叔叔节点为黑色</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">// 情况2，当前节点为父节点的右节点</span></span><br><span class="line">                    <span class="comment">// 把父节点设为新的当前节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">// 左旋当前节点</span></span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况3，当前节点为父节点的左节点</span></span><br><span class="line">                <span class="comment">// 父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// 祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// 右旋祖父节点</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果父节点是祖父节点的左节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">// y为叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1，叔叔节点也是红色</span></span><br><span class="line">                <span class="comment">// 父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果叔叔节点为黑色</span></span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">// 情况2，当前节点为父节点的右节点</span></span><br><span class="line">                    <span class="comment">// 把父节点设为新的当前节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">// 右旋当前节点</span></span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况3，当前节点为父节点的左节点</span></span><br><span class="line">                <span class="comment">// 父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// 祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// 左右旋祖父节点</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平衡完成后将根节点设为黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object key)</strong> 删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取节点</span></span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点既有左子节点，又有右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取其右子树中最小的节点</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        <span class="comment">// 用右子树中最小节点的值替换当前节点的值</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        <span class="comment">// 把右子树中最小节点设为当前节点</span></span><br><span class="line">        p = s;</span><br><span class="line">        <span class="comment">// 这种情况实际上并没有删除p节点，而是把p节点的值改了，实际删除的是p的后继节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果原来的当前节点p有2个子节点，则当前节点已经变成原来p的右子树中的最小节点了，也就是说其没有左子节点了</span></span><br><span class="line">    <span class="comment">// 到这一步，p肯定只有一个子节点了</span></span><br><span class="line">    <span class="comment">// 如果当前节点有子节点，则用子节点替换当前节点</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把替换节点直接放到当前节点的位置上（相当于删除了p，并把替换节点移动过来了）</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将p的各项属性都设为空</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果p是黑节点，则需要再平衡</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点就是根节点，则直接将根节点设为空即可</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  如果当前节点没有子节点且其为黑节点，则把自己当作虚拟的替换节点进行再平衡</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平衡完成后删除当前节点（与父节点断绝关系）</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只有当前节点不是根节点且当前节点是黑色时才进入循环</span></span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点是其父节点的左子节点</span></span><br><span class="line">            <span class="comment">// sib是当前节点的兄弟节点</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1，如果兄弟节点是红色</span></span><br><span class="line">                <span class="comment">// 把兄弟节点设为黑色</span></span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                <span class="comment">// 将父节点设为红色</span></span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                <span class="comment">// 左旋父节点</span></span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                <span class="comment">// 重新设置x的兄弟节点，进入下一步</span></span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                <span class="comment">// 情况2，如果兄弟节点的两个子节点都是黑色</span></span><br><span class="line">                <span class="comment">// 把兄弟节点设为红色</span></span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                <span class="comment">// 将x的父节点作为新的当前节点，进入下一次循环</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 情况3，如果兄弟节点的右子节点为黑色</span></span><br><span class="line">                    <span class="comment">// 把兄弟节点的左节点设为黑色</span></span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    <span class="comment">// 把兄弟节点设为红色</span></span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    <span class="comment">// 右旋兄弟节点</span></span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    <span class="comment">// 重新设置x的兄弟节点</span></span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况4</span></span><br><span class="line">                <span class="comment">// 把兄弟节点的颜色设为父节点的颜色</span></span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                <span class="comment">// 把父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// 把兄弟节点的右子节点设为黑色</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                <span class="comment">// 左旋父节点</span></span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                <span class="comment">// 把root作为新的当前节点，退出循环</span></span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点是其父节点的右子节点</span></span><br><span class="line">            <span class="comment">// sib是当前节点的兄弟节点</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1，如果兄弟节点是红色</span></span><br><span class="line">                <span class="comment">// 把兄弟节点设为黑色</span></span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                <span class="comment">// 将父节点设为红色</span></span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                <span class="comment">// 右旋父节点</span></span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                <span class="comment">// 重新设置x的兄弟节点，进入下一步</span></span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                <span class="comment">// 情况2，如果兄弟节点的两个子节点都是黑色</span></span><br><span class="line">                <span class="comment">// 把兄弟节点设为红色</span></span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                <span class="comment">// 将x的父节点作为新的当前节点，进入下一次循环</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 情况3，如果兄弟节点的右子节点为黑色</span></span><br><span class="line">                    <span class="comment">// 把兄弟节点的左节点设为黑色</span></span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    <span class="comment">// 把兄弟节点设为红色</span></span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    <span class="comment">// 左旋兄弟节点</span></span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    <span class="comment">// 重新设置x的兄弟节点</span></span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况4</span></span><br><span class="line">                <span class="comment">// 把兄弟节点的颜色设为父节点的颜色</span></span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                <span class="comment">// 把父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// 把兄弟节点的左子节点设为黑色</span></span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                <span class="comment">// 右旋父节点</span></span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                <span class="comment">// 把root作为新的当前节点，退出循环</span></span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出条件为多出来的黑色向上传递到了根节点或者红节点</span></span><br><span class="line">    <span class="comment">// 则将x设为黑色即可满足红黑树规则</span></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</strong> 遍历TreeMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="comment">// 遍历前的修改次数</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 执行遍历，先获取第一个元素的位置，再循环遍历后继节点</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e)) &#123;</span><br><span class="line">        action.accept(e.key, e.value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果发现修改次数变了，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">// 从根节点开始找最左边的节点，即最小的元素</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果当前节点为空，返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点有右子树，取右子树中最小的节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有右子树</span></span><br><span class="line">        <span class="comment">// 如果当前节点是父节点的左子节点，直接返回父节点</span></span><br><span class="line">        <span class="comment">// 如果当前节点是父节点的右子节点，一直往上找，直到找到一个祖先节点是其父节点的左子节点为止，返回这个祖先节点的父节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>TreeMap的存储结构只有一颗红黑树</li>
<li>TreeMap中的元素是有序的，按key的顺序排列</li>
<li>TreeMap比HashMap要慢一些，因为HashMap前面还做了一层桶，寻找元素要快很多</li>
<li>TreeMap没有扩容的概念</li>
<li>TreeMap的遍历不是采用传统的递归式遍历</li>
<li>TreeMap可以按范围查找元素，查找最近的元素</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：WeakHashMap</title>
    <url>/2020/03/19/6834/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WeakHashMap是一种弱引用map，内部的key会存储为弱引用。当jvm gc时如果这些key没有强引用存在的话，会被gc回收掉，下一次当我们操作map时会把对应的Entry整个删掉。基于这种特性，WeakHashMap特别适合用于缓存处理</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>AbstractMap&lt;K,V&gt;</strong>：大大减少了实现Map接口的工作量</li>
<li>实现了<strong>Map&lt;K,V&gt;</strong>：AbstractMap已经继承了Map接口，这样做可以直观地表达出WeakHashMap实现了Map</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量为2的30次方，如果一个更大的初始化容量在构造方法中被指定，将被MAXIMUM_CAPACITY替换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认装载因子0.75</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储键值对的数组，长度是2的幂</span></span><br><span class="line">Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对的实际个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的临界值，threshold = capacity * loadFactor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会保存被GC回收的“弱键”的队列</span></span><br><span class="line"><span class="comment">// 当弱键失效的时候会把Entry添加到这个队列中，当下次访问map的时候会把失效的Entry清除掉</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录HashMap被修改结构的次数</span></span><br><span class="line"><span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 可以发现没有key，因为key是作为弱引用存储到Reference类中</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于java.lang.ref</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用Reference的构造方法初始化key和引用队列</span></span><br><span class="line">        <span class="keyword">super</span>(referent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 存储key的地方</span></span><br><span class="line">    <span class="keyword">private</span> T referent;</span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br><span class="line"></span><br><span class="line">    Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = referent;</span><br><span class="line">        <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Initial Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load factor: "</span>+</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    table = newTable(capacity);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) ((<span class="keyword">float</span>)m.size() / DEFAULT_LOAD_FACTOR + <span class="number">1.0F</span>),</span><br><span class="line">            DEFAULT_INITIAL_CAPACITY),</span><br><span class="line">         DEFAULT_LOAD_FACTOR);</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法基本与HashMap类似，初始化为大于等于传入容量最近的2的n次方，扩容门槛threshold等于capacity*loadFactor</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>put(K key, V value)</strong> 添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果key为null，用空对象代替</span></span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="comment">// 计算hash</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    <span class="comment">// 获取桶</span></span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="comment">// 计算元素在那个桶中，就是 h &amp; (length-1)</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    <span class="comment">// 遍历桶对应的链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            <span class="comment">// 如果找到了元素就用新值替换旧值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (value != oldValue)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果没有找到元素就把新增插入到链表头部</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class="line">    <span class="comment">// 如果插入元素后达到扩容门槛就进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt;= threshold)</span><br><span class="line">        resize(tab.length * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里与HashMap不同，进行了4次异或操作，</span></span><br><span class="line">    <span class="comment">// 是因为在HashMap中1次异或就够了，就是冲突了也会转换成红黑树，对效率影响不大</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>resize(int newCapacity)</strong> 扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取旧桶</span></span><br><span class="line">    Entry&lt;K,V&gt;[] oldTable = getTable();</span><br><span class="line">    <span class="comment">// 旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 扩容前容量大于等于MAXIMUM_CAPACITY，则不再进行扩容</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新桶</span></span><br><span class="line">    Entry&lt;K,V&gt;[] newTable = newTable(newCapacity);</span><br><span class="line">    <span class="comment">// 把元素从旧桶转移到新桶</span></span><br><span class="line">    transfer(oldTable, newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果元素个数大于扩容门槛的一半，则使用新桶和新容量，并计算新的扩容门槛</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则把元素再转移回旧桶，还是使用旧桶</span></span><br><span class="line">        <span class="comment">// 因为在transfer的时候会清除失效的Entry，所以元素个数可能没有那么大了，就不需要扩容了</span></span><br><span class="line">        expungeStaleEntries();</span><br><span class="line">        transfer(newTable, oldTable);</span><br><span class="line">        table = oldTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry&lt;K,V&gt;[] src, Entry&lt;K,V&gt;[] dest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历旧桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        src[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object key = e.get();</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果key等于了null就清除，说明key被gc清理掉了，则把整个Entry清除</span></span><br><span class="line">                e.next = <span class="keyword">null</span>;  <span class="comment">// Help GC</span></span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">//  "   "</span></span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就计算在新桶中的位置并把这个元素放在新桶对应链表的头部</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, dest.length);</span><br><span class="line">                e.next = dest[i];</span><br><span class="line">                dest[i] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get(Object key)</strong> 获取元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="comment">// 计算hash</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="comment">// 遍历链表，找到元素则后返回</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object key)</strong> 移除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="comment">// 计算hash</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    <span class="comment">// 元素所在的桶的第一个元素</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            <span class="comment">// 如果找到了就删除元素</span></span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                <span class="comment">// 如果是头节点，就把头节点指向下一个节点</span></span><br><span class="line">                tab[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果不是头节点，删除该节点</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>expungeStaleEntries()</strong> 删除失效的Entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历引用队列</span></span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line">            <span class="comment">// 找到所在的桶</span></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="comment">// 找到该元素</span></span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="comment">// 删除该元素</span></span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>WeakHashMap使用（数组 + 链表）存储结构</li>
<li>WeakHashMap中的key是弱引用，gc的时候会被清除</li>
<li>每次对map的操作都会剔除失效key对应的Entry</li>
<li>使用String作为key时，一定要使用new String()这样的方式声明key，才会失效，其它的基本类型的包装类型是一样的</li>
<li>WeakHashMap常用来作为缓存使用；</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：LinkedHashMap</title>
    <url>/2020/03/18/41450/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略</p>
<p>LinkedHashMap可以看作LinkedList+HashMap</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>HashMap&lt;K,V&gt;</strong>：哈希表部分的功能和HashMap相似</li>
<li>实现了<strong>Map&lt;K,V&gt;</strong>：HashMap已经继承了Map接口，这样做可以直观地表达出LinkedHashMap实现了Map</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表尾节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否按访问顺序排序，如果为false则按插入顺序存储元素，如果是true则按访问顺序存储元素</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储节点，继承自HashMap的Node类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于HashMap中</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前四个构造方法accessOrder都等于false，说明双向链表是按插入顺序存储元素</p>
<p>最后一个构造方法accessOrder从构造方法参数传入，如果传入true，则就实现了按访问顺序存储元素，这也是实现LRU缓存策略的关键</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>afterNodeInsertion(boolean evict)</strong> 插入节点之后被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 如果evict为true、头节点不为空且确定移除最老的元素，则调用removeNode删除头节点</span></span><br><span class="line">    <span class="comment">// removeEldestEntry默认返回false，所以不会删除元素</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果重写该方法，就能自定义删除节点的规则</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>afterNodeAccess(Node&lt;K,V&gt; e)</strong> 节点访问之后被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 如果accessOrder为true且访问的节点不是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">// 把p节点从双向链表中移除</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 把p节点放到双向链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尾节点等于p</span></span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>afterNodeRemoval(Node&lt;K,V&gt; e)</strong> 节点删除之后调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 把节点p从双向链表中移除</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get(Object key)</strong> 获取指定key的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>LinkedHashMap继承自HashMap，具有HashMap的所有特性</li>
<li>LinkedHashMap内部维护了一个双向链表存储所有的元素</li>
<li>如果accessOrder为false，则可以按插入元素的顺序遍历元素</li>
<li>如果accessOrder为true，则可以按访问元素的顺序遍历元素</li>
<li>LinkedHashMap的实现非常精妙，很多方法都是在HashMap中留的钩子（Hook），直接实现这些Hook就可以实现对应的功能了，并不需要再重写put()等方法</li>
<li>默认的LinkedHashMap并不会移除旧元素，如果需要移除旧元素，则需要重写removeEldestEntry()方法设定移除策略</li>
<li>LinkedHashMap可以用来实现LRU缓存淘汰策略</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：HashMap</title>
    <url>/2020/03/18/30952/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HashMap采用key-value形式存储结构，每个可以对应唯一value，查询和修改的速度都很快，能达到$O(1)$的平均时间复杂度。它是非线程安全的，且不保证元素存储顺序</p>
<ul>
<li><strong>底层</strong>：HashMap是Map接口基于哈希表的实现</li>
<li><strong>是否允许null</strong>：HashMap允许key和value为null</li>
<li><strong>是否有序</strong>：HashMap不保证映射的顺序，特别是它不保证该顺序恒久不变</li>
<li><strong>何时rehash</strong>：超出当前允许的最大容量。initial capacity<em>load factor就是当前允许的最大元素数目，超过initial capacity</em>load factor之后，HashMap就会进行rehashed操作来进行扩容，扩容后的的容量为之前的两倍</li>
<li><strong>初始化容量对性能的影响</strong>：不应设置地太小，设置地小虽然可以节省空间，但会频繁地进行rehash操作。rehash会影响性能。总结：小了会增大时间开销（频繁rehash）；大了会增大空间开销（占用了更多空间）和时间开销（影响遍历）</li>
<li><strong>加载因子对性能的影响</strong>：加载因子过高虽然减少了空间开销，但同时也增加了查询成本。0.75是个折中的选择。总结：小了会增大时间开销（频繁rehash）；大了会也增大时间开销（影响遍历）</li>
<li><strong>是否同步</strong>：HashMap不是同步的</li>
<li><strong>迭代器</strong>：迭代器是fast-fail的</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现了<strong>Map&lt;K,V&gt;</strong>：具有Map的所有功能</li>
<li>实现了<strong>Cloneable</strong>：可以被克隆</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>HashMap的实现采用了数组+链表+红黑树的结构，数组的一个元素又称作桶</p>
<p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素则直接把元素放在此处，如果该位置已经有元素了，则把元素以链表的形式放在链表尾部</p>
<p>当一个链表的元素达到一定的数量时，则把链表转化为红黑树，从而提高效率</p>
<p>数组的查询效率是$O(1)$，链表的查询效率是$O(k)$，红黑树的查询效率是$O(\log_2k)$，k为桶中的元素个数。所以当元素数量非常多时，转化为红黑树能大幅提升效率</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量为2的30次方，如果一个更大的初始化容量在构造方法中被指定，将被MAXIMUM_CAPACITY替换</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认装载因子0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表转红黑树的阈值8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树转链表的阈值6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当桶的个数达到64的时候才进行树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组，又叫作桶（bucket）</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为entrySet()的缓存</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改次数，用于在迭代时执行fail-fast策略</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当桶的使用数量达到多少时进行扩容，threshold = capacity * loadFactor</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载因子，用来计算容量达到多少时才进行扩容</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap的节点类型。既是HashMap底层数组的组成元素，又是每个单向链表的组成元素</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位于HashMap中</span></span><br><span class="line"><span class="comment">// TreeNode是一个典型的树型节点，它继承自LinkedHashMap中的Entyr类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;</span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于LinkedHashMap中，典型的双向链表节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指定的初始化容量initialCapacity 和加载因子loadFactor构造一个空HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验传入的参数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 计算扩容门槛</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回传入的容量向上取最近的二的n次幂</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指定的初始化容量initialCapacity和默认加载因子0.75构造一个空HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指定的初始化容量16和默认加载因子0.75构造一个空HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指定Map m构造新的HashMap。使用指定的初始化容量16和默认加载因子0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>put(K key, V value)</strong> 添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用hash计算key的哈希</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 若key为null则hash为0，否则调用key的hashCode()方法</span></span><br><span class="line">    <span class="comment">// 哈希值再与自身的高16位异或运算，这样是为了计算出的hash更分散</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 若桶的数量为0，则初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用resize()初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n-1)&amp;hash 计算元素该放在那个桶中，判断桶中是否有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果桶为空，则新建一个节点放在该桶的第一个位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果桶中已经有元素存在</span></span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 如果桶中第一个元素的key与待插入元素的key相同，保存到e中用于后续修改value值</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果第一个元素是树节点，则调用树节点的putTreeVal插入元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链式结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表最后插入一个新节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果插入新节点后链表长度大于8，将其转化为红黑树</span></span><br><span class="line">                    <span class="comment">// 因为第一个元素没有加到binCount中，所以这里要减1</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 如果找到了待插入的key，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果找到了对应key的元素，先记录旧值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 判断是否需要替换旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 在节点访问后进行一些操作，在LinkedHashMap中用到</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到了这里说明没有找到元素</span></span><br><span class="line">    <span class="comment">// 修改次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 在节点插入后进行一些操作，在LinkedHashMap中用到</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>resize()</strong> 扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 保存扩容前的数组table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 保存扩容前table的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 记录扩容前的临界值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 扩容前容量大于0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 扩容前容量大于等于MAXIMUM_CAPACITY，则不再进行扩容</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 如果旧容量的两倍小于最大容量且旧容量大于等于默认初始容量，则容量和扩容阈值都增大至两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 使用非默认构造方法创建的map，第一次插入元素会走到这里</span></span><br><span class="line">        <span class="comment">// 如果旧容量为0且旧扩容门槛大于0，则把新容量赋值为旧门槛</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用默认构造方法创建的map，第一次插入元素会走到这里</span></span><br><span class="line">        <span class="comment">// 如果旧容量旧扩容门槛都是0，说明还未初始化过，则初始化容量为默认容量，扩容门槛为默认容量*默认装载因子</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果新扩容门槛为0，则计算为容量*装载因子，但不能超过最大容量</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值扩容门槛为新门槛</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建一个新容量的数组，把它赋值给table</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 判断旧数组是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 不为空则遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 判断每个数组元素是否不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 清空旧桶</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 如果这个桶只有一个元素，计算它在新数组中的位置并把它搬移到新的桶中</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果第一个元素为树节点，则把这棵树拆成两棵树插入到新数组中</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 如果这个桶不只一个元素且是一个链表</span></span><br><span class="line">                    <span class="comment">// 定义四个指针 低链表头、低链表尾、高链表头、高链表尾</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果hash值和旧容量做与运算结果为0，把该元素加到低链表中</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果hash值和旧容量做与运算结果为1，把该元素加到高链表中</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 低链表尾置空</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 低链表放在原来的位置</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 高链表尾置空</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 高链表放在原来位置+原数组大小的位置</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TreeNode.putTreeVal(…)</strong> 插入元素到红黑树中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 标记是否找到这个key的节点</span></span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 找到树的根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="comment">// dir标记在左边还是右边，ph为当前节点哈希值，pk为当前节点key值</span></span><br><span class="line">        <span class="keyword">int</span> dir, ph;</span><br><span class="line">        K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            <span class="comment">// 当前hash比目标hash大，说明在左边</span></span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            <span class="comment">// 当前hash比目标hash大，说明在右边</span></span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="comment">// 两者hash相同且key相等，说明找到了节点，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  <span class="comment">// 如果k是Comparable的子类则返回其真实的类，否则返回null</span></span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 <span class="comment">// 如果k是Comparable的子类则返回其真实的类，否则返回null</span></span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这个条件表示两者hash相同但是其中一个不是Comparable类型或者两者类型不同</span></span><br><span class="line">            <span class="comment">// 比如key是Object类型，这时可以传String也可以传Integer，两者hash值可能相同</span></span><br><span class="line">            <span class="comment">// 在红黑树中把同样hash值的元素存储在同一颗子树，这里相当于找到了这颗子树的顶点</span></span><br><span class="line">            <span class="comment">// 从这个顶点分别遍历其左右子树去寻找有没有跟待插入的key相同的元素</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 遍历左右子树找到了直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果两者类型相同，再根据它们的内存地址计算hash值进行比较</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果最后确实没找到对应key的元素，则新建一个节点</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">// 插入树节点后平衡，把root节点移动到链表的第一个节点</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>treeifyBin(Node&lt;K,V&gt;[] tab, int hash)</strong> 判断是否需要转为红黑树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">// 桶数量小于64直接扩容而不树化</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 把所有节点转化为树节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 则从头节点开始树化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>treeify(Node&lt;K,V&gt;[] tab)</strong> 把节点转为红黑树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 第一个元素作为根节点且为黑节点，其它元素依次插入到树中再做平衡</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 从根节点查找元素插入的位置</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                <span class="comment">// 从根节点查找元素插入的位置</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 插入后平衡，默认插入的是红节点，在balanceInsertion()方法里</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把根节点移动到链表的头节点，因为经过平衡之后原来的第一个元素不一定是根节点了</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get(Object key)</strong> 获取指定key的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果桶的数量大于0且待查找的key所在的桶的第一个元素不为空</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 如果第一个元素是查找的元素，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果第一个元素是树节点，则按树的方式查找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则遍历整个链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TreeNode.getTreeNode(int h, Object k)</strong> 树节点的查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从树的根节点开始查找</span></span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            <span class="comment">// 右子树</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="comment">// 找到了直接返回</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// hash相同但key不同，左子树为空查右子树</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 比较key值的大小决定使用左子树还是右子树</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果以上条件都不满足，则尝试在右子树查找</span></span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 都没找到则在左子树查找</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object key)</strong> 删除指定key的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 如果通的数量大于0且待删除元素所在桶的第一个元素不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 如果第一个元素就是要找的节点，赋值给node后续删除使用</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果第一个元素是树节点，则以树的方式查找节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则遍历链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了元素，则看参数是否需要匹配value值，若不需要则直接删除，需要则看value和传入的value是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果是树节点，以树的方式删除</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">// 如果待删除的元素是第一个元素，直接把第二个元素移到第一的位置</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则删除node节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 删除节点后置处理</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>TreeNode.removeTreeNode(…)</strong> 删除树的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 如果桶的数量为0直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 节点在桶中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    <span class="comment">// 第一个节点，根节点，根左子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    <span class="comment">// 后继节点，前置节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果前置节点为空，说明当前节点是根节点，则把后继节点赋值到第一个节点的位置，相当于删除了当前节点</span></span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则把前置节点的下个节点设置为当前节点的后继节点，相当于删除了当前节点</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="comment">// 如果后继节点不为空，则让后继节点的前置节点指向当前节点的前置节点，相当于删除了当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="comment">// 如果第一个节点为空，说明没有后继节点了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果根节点的父节点不为空，则重新查找父节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="comment">// 如果根节点为空，则需要反树化（将树转化为链表）</span></span><br><span class="line">    <span class="comment">// 如果需要移动节点且树的高度比较小，则需要反树化</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">        || (movable</span><br><span class="line">            &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上都是删除链表中的节点，下面才是直接删除红黑树的节点（因为TreeNode本身即是链表节点又是树节点）</span></span><br><span class="line">    <span class="comment">// 删除红黑树节点的大致过程是寻找右子树中最小的节点放到删除节点的位置，然后做平衡</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            (root = replacement).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构</li>
<li>HashMap的默认初始容量为16，默认装载因子为0.75，容量总是2的n次方</li>
<li>HashMap扩容时每次容量变为原来的两倍</li>
<li>当桶的数量小于64时不会进行树化，只会扩容</li>
<li>当桶的数量大于64且单个桶中元素的数量大于8时，进行树化</li>
<li>当单个桶中元素数量小于6时，进行反树化</li>
<li>HashMap是非线程安全的容器</li>
<li>HashMap查找添加元素的时间复杂度都为$O(1)​$</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：CopyOnWriteArrayList</title>
    <url>/2020/03/18/32330/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CopyOnWriteArrayList是ArrayList的线程安全版本，内部也是通过数组实现，每次对数组的修改都完全拷贝一份新的数组来修改，然后替换掉原数组，这样保证了只阻塞写操作，不阻塞都操作，实现读写分类</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现了<strong>List&lt;E&gt;</strong>：提供了基础的添加、删除、遍历等操作</li>
<li>实现了<strong>RandomAccess</strong>：支持快速随机访问</li>
<li>实现了<strong>Cloneable</strong>：可以被克隆</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于修改时加锁，使用transient修饰表示不自动序列化</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正存储元素的地方，只能通过getArray()/setArray()访问</span></span><br><span class="line"><span class="comment">// 使用transient修饰表示不自动序列化</span></span><br><span class="line"><span class="comment">// 使用volatile修饰表示一个线程对这个字段的修改另外一个线程立即可见</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>CopyOnWriteArrayList提供了三种构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空参构造，数组初始化长度为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] es;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        // 如果<span class="title">c</span>也是<span class="title">CopyOnWriteArrayList</span>，那么直接把它的数组拿来使用</span></span><br><span class="line"><span class="class">        <span class="title">es</span> </span>= ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，先把它转化为数组</span></span><br><span class="line">        es = c.toArray();</span><br><span class="line">        <span class="comment">// 检查c.toArray()返回的是不是Object[]类型，如果不是，重新拷贝成Object[].class类型</span></span><br><span class="line">        <span class="keyword">if</span> (es.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">es</span> </span>= Arrays.copyOf(es, es.length, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(es);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[]<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>add(E e)</strong> 添加元素到末尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 获取原数组和长度</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = es.length;</span><br><span class="line">        <span class="comment">// 把旧数组拷贝到新数组，新数组长度为旧数组长度加1</span></span><br><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 把要添加的元素放在最后一位</span></span><br><span class="line">        es[len] = e;</span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add(int index, E e)</strong> 添加元素到指定位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 获取原数组和长度</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = es.length;</span><br><span class="line">        <span class="comment">// 检查是否越界</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBounds(index, len));</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果插入的位置是最后一位</span></span><br><span class="line">            <span class="comment">// 那么拷贝一个长度为n+1的数组，其前n个元素与旧数组一致</span></span><br><span class="line">            newElements = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果插入的位置不是最后一位，那么新建一个长度为n+1的数组</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 拷贝旧数组前index的元素到新数组中</span></span><br><span class="line">            System.arraycopy(es, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 将index及其之后的元素往后挪一位拷贝到新数组中</span></span><br><span class="line">            System.arraycopy(es, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把要添加的元素放在index处</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>addIfAbsent(E e)</strong> 如果一个元素不存在于集合中则添加这个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取元素数组，称为快照</span></span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="comment">// 如果元素存在直接返回false，存在则添加元素</span></span><br><span class="line">    <span class="keyword">return</span> indexOfRange(e, snapshot, <span class="number">0</span>, snapshot.length) &lt; <span class="number">0</span></span><br><span class="line">        &amp;&amp; addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 获取原数组和长度</span></span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="comment">// 如果快照与刚获取的数组不一致说明期间有修改</span></span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">            <span class="comment">// 重新检查元素是否在刚获取的数组中</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; Objects.equals(e, current[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOfRange(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 那么拷贝一个长度为n+1的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 把元素放在最后一位</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组es的from到to区间中查找元素o所在位置索引，找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfRange</span><span class="params">(Object o, Object[] es, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; to; i++)</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; to; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get(int index)</strong> 获取指定索引处的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接返回index位置的元素</span></span><br><span class="line">    <span class="comment">// 这里是没有做越界检查的, 因为数组本身会做越界检查</span></span><br><span class="line">    <span class="keyword">return</span> elementAt(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">elementAt</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(int index)</strong> 删除指定索引位置的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 获取原数组和长度=</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = es.length;</span><br><span class="line">        E oldValue = elementAt(es, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果删除的位置是最后一位</span></span><br><span class="line">            <span class="comment">// 那么拷贝一个长度为n-1的数组，最后一位就自动删除了</span></span><br><span class="line">            newElements = Arrays.copyOf(es, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果删除的位置不是最后一位，那么新建一个长度为n-1的数组</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 拷贝旧数组前index的元素到新数组中</span></span><br><span class="line">            System.arraycopy(es, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 将index及其之后的元素往前挪一位拷贝到新数组中</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(es, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(es, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>CopyOnWriteArrayList使用lock锁，保证线程安全</li>
<li>CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是$O(n)$，性能比较低下</li>
<li>CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为$O(1)$</li>
<li>CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合</li>
<li>CopyOnWriteArrayList只保证最终一致性，不保证实时一致性</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：ArrayList</title>
    <url>/2020/03/17/47677/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ArrayList是一种以数组实现的List，它具有动态扩展的能力，因此也可称之为动态数组</p>
<ul>
<li><strong>底层</strong>：ArrayList是List接口的大小可变数组的实现</li>
<li><strong>是否允许null</strong>：ArrayList允许null元素</li>
<li><strong>时间复杂度</strong>：size、isEmpty、get、set、iterator和listIterator方法都以固定时间运行，时间复杂度为$O(1)$。add和remove方法需要$O(n)$时间。与用于LinkedList实现的常数因子相比，此实现的常数因子较低</li>
<li><strong>容量</strong>：ArrayList的容量可以自动增长</li>
<li><strong>是否同步</strong>：ArrayList不是同步的</li>
<li><strong>迭代器</strong>：ArrayList的iterator和listIterator方法返回的迭代器是fail-fast的</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>继承自<strong>AbstractList&lt;E&gt;</strong>：AbstractList提供List接口的骨干实现，以最大限度地减少“随机访问”数据存储（如ArrayList）实现Llist所需的工作</li>
<li>实现了<strong>List&lt;E&gt;</strong>：提供了基础的添加、删除、遍历等操作</li>
<li>实现了<strong>RandomAccess</strong>：支持快速随机访问</li>
<li>实现了<strong>Cloneable</strong>：可以被克隆</li>
<li>实现了<strong>Serializable</strong>：可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认容量为10，也就是通过new ArrayList()创建时的默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空数组，这种是通过new ArrayList(0)创建时用的是这个空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也是空数组，这种是通过new ArrayList()创建时用的是这个空数组</span></span><br><span class="line"><span class="comment">// 与EMPTY_ELEMENTDATA的区别是在添加第一个元素时使用这个空数组的会扩容为DEFAULT_CAPACITY</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存添加到ArrayList中的元素，被标记为transient，不会被序列化</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList的实际大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ArrayList提供了三种构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果大于0就初始化elementData为对应大小</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果等于0就使用EMPTY_ELEMENTDATA空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果小于0抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不传初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把elementData初始化为DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="comment">// 在添加第一个元素的时候会扩容为默认的大小，即10</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把传入集合的元素拷贝到elementData数组</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查c.toArray()返回的是不是Object[]类型，如果不是，重新拷贝成Object[].class类型</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果元素个数为0，则初始化为EMPTY_ELEMENTDATA空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>add(E e)</strong> 添加元素到末尾，平均时间复杂度$O(1)​$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 调用add的重载方法</span></span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若size等于elementData的长度，说明需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    <span class="comment">// 实际大小加1</span></span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="comment">// 因为是添加一个元素时调用的，所以扩容的最小容量为size+1</span></span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minCapacity参数为扩容所需要的最小容量</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">// 通过newCapacity方法确定扩容后的数组大小，把原数组复制到扩容后长度的新数组中并返回</span></span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分派给arrays的最大容量</span></span><br><span class="line"><span class="comment"> * 减去8因为某些VM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于VM的limit，最终导致OutOfMemoryError</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组原长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新长度为原长度的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩容后的容量还是小于想要的最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组为空数组，则返回DEFAULT_CAPACITY, minCapacity较大者</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity小于0，抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="comment">// 将扩容后的容量再次扩容为想要的最小容量</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果扩容后的容量大于临界值，则调用hugeCapacity方法进行大容量分配</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// minCapacity小于0则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//如果想要的容量大于MAX_ARRAY_SIZE，则分配Integer.MAX_VALUE，否则分配MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add(int index, E e)</strong> 添加元素到指定位置，平均时间复杂度$O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 越界检查</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">// 把数组index后的元素向后移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    <span class="comment">// 将index位置元素赋值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 实际大小加1</span></span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>addAll(Collection&lt;? extends E&gt; c)</strong> 添加一个集合内所有元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将要添加的集合转为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 添加的集合长度为0时添加失败</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">// 如果要添加的集合中元素个数大于数组空余空间长度，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    <span class="comment">// 把要添加的元素加入数组</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    <span class="comment">// 实际大小增加</span></span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get(int index)</strong> 获取指定索引处的元素，平均时间复杂度$O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否越界</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(int index)</strong> 删除指定索引位置的元素，时间复杂度$O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否越界</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E oldValue = (E) es[index];</span><br><span class="line">     <span class="comment">// 调用fastRemove，快速删除数组es下标i的元素</span></span><br><span class="line">    fastRemove(es, index);</span><br><span class="line">    <span class="comment">// 返回被删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="comment">// 把数组es下标i后所以元素向前移动一位</span></span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    <span class="comment">// 把数组最后一个元素置空</span></span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object o)</strong> 删除指定元素，时间复杂度$O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 寻找元素o在数组中的下标</span></span><br><span class="line">    found: &#123;</span><br><span class="line">        <span class="comment">// 判断要找的元素是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用fastRemove，快速删除数组es下标i的元素</span></span><br><span class="line">    fastRemove(es, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>removeAll(Collection&lt;?&gt; c)</strong> 删除指定集合中在当前集合的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除元素，complement为true表示删除c不包含的元素，为false表示删除c包含的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">final</span> <span class="keyword">int</span> from, <span class="keyword">final</span> <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">// 如果c中有符合条件的元素，把读指针放在该位置</span></span><br><span class="line">    <span class="keyword">for</span> (r = from;; r++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c.contains(es[r]) != complement)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> w = r++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// r w分别为读写指针，遍历es数组时每遍历一个元素r自增1</span></span><br><span class="line">        <span class="comment">// 当找到不要删除的元素时，把它放到w指针所在处后w自增1</span></span><br><span class="line">        <span class="keyword">for</span> (Object e; r &lt; end; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(e = es[r]) == complement)</span><br><span class="line">                es[w++] = e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        System.arraycopy(es, r, es, w, end - r);</span><br><span class="line">        w += end - r;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        modCount += end - w;</span><br><span class="line">        <span class="comment">// 把w指针后面的多余元素置空</span></span><br><span class="line">        shiftTailOverGap(es, w, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>retainAll(Collection&lt;?&gt; c)</strong> 求两个集合的交集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>因为elementData被设置成了transient，所以ArrayList自定义了序列化和反序列化的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 防止序列化期间有修改</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    <span class="comment">// 写出元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    <span class="comment">// 依次写出元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果序列化期间有修改则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 读入非transient非static属性（会读取size属性）</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[]<span class="class">.<span class="keyword">class</span>, <span class="title">size</span>)</span>;</span><br><span class="line">        Object[] elements = <span class="keyword">new</span> Object[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elementData = elements;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Invalid size: "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容</li>
<li>ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为$O(1)$</li>
<li>ArrayList添加元素到尾部极快，平均时间复杂度为$O(1)$</li>
<li>ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为$O(n)$</li>
<li>ArrayList从尾部删除元素极快，时间复杂度为$O(1)$</li>
<li>ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为$O(n)​$</li>
<li>ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可</li>
<li>ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可</li>
<li>ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：整体结构</title>
    <url>/2020/03/17/29776/</url>
    <content><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>通常，程序总是在运行的时候才能确定要创建对象的数量，甚至的对象的类型。为了解决这个问题，需要在任意时刻任意位置创建任意数量的对象。Java使用容器来解决这个问题</p>
<p>容器也称集合类，基本的类型有List、Set、Queue和Map</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><img src="/2020/03/17/29776/list.png" class="">

<p>List以线性方式存储元素，集合中可以存放重复对象，元素有序。主要实现方式有动态数组和链表</p>
<p>点击下方链接可直接到相应章节查看：</p>
<ul>
<li><a href="/2020/03/17/47677/">Java容器源码分析：ArrayList</a></li>
<li><a href="/2020/03/18/32330/">Java容器源码分析：CopyOnWriteArrayList</a></li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><img src="/2020/03/17/29776/set.png" class="">

<p>Set不保存同样的元素。Set与Collection有完全一样的接口。Set不保证维护元素的次序</p>
<p>点击下方链接可直接到相应章节查看：</p>
<ul>
<li><a href="/2020/03/22/32132/">Java容器源码分析：HashSet</a></li>
<li><a href="/2020/03/22/42122/">Java容器源码分析：LinkedHashSet</a></li>
<li><a href="/2020/03/22/28688/">Java容器源码分析：TreeSet</a></li>
<li><a href="/2020/03/22/36265/">Java容器源码分析：CopyOnWriteArraySet</a></li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><img src="/2020/03/17/29776/map.png" class="">

<p>Map 是一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象。 Map没有继承于Collection接口</p>
<p>点击下方链接可直接到相应章节查看：</p>
<ul>
<li><a href="/2020/03/17/47677/">Java容器源码分析：HashMap</a></li>
<li><a href="/2020/03/18/41450/">Java容器源码分析：LinkedHashMap</a></li>
<li><a href="/2020/03/19/6834/">Java容器源码分析：WeakHashMap</a></li>
<li><a href="/2020/03/19/30067/">Java容器源码分析：TreeMap</a></li>
<li><a href="/2020/03/21/18323/">Java容器源码分析：ConcurrentHashMap</a></li>
<li><a href="/2020/03/22/17546/">Java容器源码分析：ConcurrentSkipListMap</a></li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><img src="/2020/03/17/29776/queue.png" class="">

<p>Queue是一种叫做队列的数据结构，队列是遵循着一定原则的入队出队操作的集合，一般来说，入队是在队列尾添加元素，出队是在队列头删除元素，但是，也不一定，比如优先级队列的原则就稍微有些不同</p>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><img src="/2020/03/17/29776/deque.png" class="">

<p>Deque是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列（Double Ended Queue）</p>
<h2 id="相关工具类"><a href="#相关工具类" class="headerlink" title="相关工具类"></a>相关工具类</h2><ol>
<li><p>Iterator迭代器</p>
<p>迭代器是用来遍历并选择序列中的对象。只能单向移动</p>
</li>
<li><p>ListIterator迭代器</p>
<p>更强大的Iterator的子类型，它只能用于List的访问。它最大的优点是可以双向移动</p>
</li>
<li><p>Enumeration枚举类</p>
<p>只能在Hashtable、Vector、Stack中使用，此接口已被迭代器取代，很少使用</p>
</li>
<li><p>Arrays</p>
<p>用于更方便地操作数组</p>
</li>
<li><p>Collections</p>
<p>用于更方便地操作集合</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解(4)：寻找两个有序数组的中位数</title>
    <url>/2020/03/16/29343/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code></p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(log(m + n))$</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空</p>
<p>示例 1:</p>
<blockquote>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
</blockquote>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性：Stream</title>
    <url>/2020/03/16/36643/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Stream</strong> 操作简称流操作，这个流与I/O流没有关系，而是指流式操作</p>
<p>Stream流操作主要包括三大模块</p>
<ul>
<li><p>创建流操作：主要是创建Stream流对象</p>
</li>
<li><p>中间流操作：各种中间操作，如去重、过滤、排序等</p>
</li>
<li><p>终结流操作：产生最终结果</p>
</li>
</ul>
<h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><p>基于数组创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">IntStream s1 = Arrays.stream(ints);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; s2 = Stream.of(<span class="string">"111"</span>, <span class="string">"222"</span>, <span class="string">"333"</span>);</span><br></pre></td></tr></table></figure>

<p>通过构造器生成流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Object&gt; s3 = Stream.builder().add(<span class="string">"123"</span>).add(<span class="string">"321"</span>).build();</span><br></pre></td></tr></table></figure>

<p>基于集合创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"123"</span>, <span class="string">"321"</span>, <span class="string">"444"</span>);</span><br><span class="line">Stream&lt;String&gt; s4 = list.stream();</span><br><span class="line">Stream&lt;String&gt; s5 = list.parallelStream(); <span class="comment">// 并行流</span></span><br></pre></td></tr></table></figure>

<p>创建空流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Object&gt; s6 = Stream.empty();</span><br></pre></td></tr></table></figure>

<p>基于函数创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(() -&gt; <span class="string">"number"</span> + <span class="keyword">new</span> Random().nextInt()).limit(<span class="number">100</span>).forEach(System.out::println);</span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="流中间操作"><a href="#流中间操作" class="headerlink" title="流中间操作"></a>流中间操作</h2><table>
<thead>
<tr>
<th>序号</th>
<th>操作</th>
<th>方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>filter</td>
<td>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</td>
<td>返回当前流中满足参数predicate过滤条件的元素组成的新流</td>
<td>过滤器</td>
</tr>
<tr>
<td>2</td>
<td>map</td>
<td>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</td>
<td>返回通过给定mapper作用于当前流的每个元素之后的结果组成的新流</td>
<td>函数</td>
</tr>
<tr>
<td>3</td>
<td>mapToInt</td>
<td>IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)</td>
<td>返回通过给定mapper作用于当前流的每个元素之后的结果组成的新的Int流</td>
<td>函数</td>
</tr>
<tr>
<td>4</td>
<td>mapToLong</td>
<td>LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);</td>
<td>返回通过给定mapper作用于当前流的每个元素之后的结果组成的新的Long流</td>
<td>函数</td>
</tr>
<tr>
<td>5</td>
<td>mapToDouble</td>
<td>DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</td>
<td>返回通过给定mapper作用于当前流的每个元素之后的结果组成的新的Double流</td>
<td>函数</td>
</tr>
<tr>
<td>6</td>
<td>flatMap</td>
<td>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</td>
<td>根据给定的mapper作用于当前流的每个元素，将结果组成新的流来返回</td>
<td>扁平函数</td>
</tr>
<tr>
<td>7</td>
<td>flatMapToInt</td>
<td>IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper)</td>
<td>根据给定的mapper作用于当前流的每个元素，将结果组成新的Int流来返回</td>
<td>扁平函数</td>
</tr>
<tr>
<td>8</td>
<td>flatMapToLong</td>
<td>LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper)</td>
<td>根据给定的mapper作用于当前流的每个元素，将结果组成新的Long流来返回</td>
<td>扁平函数</td>
</tr>
<tr>
<td>9</td>
<td>flatMapToDouble</td>
<td>DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper)</td>
<td>根据给定的mapper作用于当前流的每个元素，将结果组成新的Double流来返回</td>
<td>扁平函数</td>
</tr>
<tr>
<td>10</td>
<td>distinct</td>
<td>Stream&lt;T&gt; distinct()</td>
<td>返回去掉当前流中重复元素之后的新流</td>
<td>去重</td>
</tr>
<tr>
<td>11</td>
<td>sorted</td>
<td>Stream&lt;T&gt; sorted()</td>
<td>返回当前流中元素排序之后的新流，需要元素类型实现Comparable</td>
<td>排序</td>
</tr>
<tr>
<td>12</td>
<td>sorted</td>
<td>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</td>
<td>返回当前流中元素排序之后的新流，需要传递一个Comparator</td>
<td>排序</td>
</tr>
<tr>
<td>13</td>
<td>peek</td>
<td>Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action);</td>
<td>针对流中的每个元素执行操作action</td>
<td>查阅</td>
</tr>
<tr>
<td>14</td>
<td>limit</td>
<td>Stream&lt;T&gt; limit(long maxSize)</td>
<td>返回指定的数量的元素组成的新流</td>
<td>限制</td>
</tr>
<tr>
<td>15</td>
<td>skip</td>
<td>Stream&lt;T&gt; skip(long n)</td>
<td>返回第n个之后的元素组成的新流</td>
<td>跳过</td>
</tr>
</tbody></table>
<h3 id="fliter"><a href="#fliter" class="headerlink" title="fliter"></a>fliter</h3><p>filter方法是过滤器方法，针对的是流中所有元素，满足条件的元素将会被保留以组成新的流</p>
<p>filter方法的参数是Predicate类型，这个函数式接口用于获取一个参数返回一个boolean值，整个参数作为过滤条件</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map方法可以理解为函数，需要针对流中每个元素执行，然后将执行的结果组成新的流返回</p>
<p>map方法的参数类型为Function，该函数式接口用于接受一个参数，返回一个结果</p>
<p>mapToInt、mapToLong、mapToDouble方法是map方法的扩展，其参数分别为ToIntFunction、ToLongFunction、ToDoubleFunction，分别接口一个参数，返回指定类型的值，分别为int、long、double，那么定义方法的时候就要注意返回值的类型了，必须一致，最后组成的新流就是一个int或long或double元素流（IntStream、LongStream、DoubleStream）</p>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>flatMap和map类似，都是针对流中每个元素进行操作，将结果组成新流，但flatMap含有一层扩展之意，就是当流中元素保护子元素时，通过该方法获取元素的子元素，并将子元素组成新流返回</p>
<p>flatMapToInt、flatMapToLong、flatMapToDouble类似于之前的mapToInt之类</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>distinct方法用于去除流中重复元素</p>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted方法用于对流中元素排序，当调用无参的sorted方法时，采用自然排序法排序，当使用指定比较器的方式时，可以自由指定排序规则</p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit方法用于从首个元素开始截取n个元素，组成新流返回</p>
<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>skip方法用于跳过前n个元素，将剩余元素组成新流返回</p>
<h2 id="流终结操作"><a href="#流终结操作" class="headerlink" title="流终结操作"></a>流终结操作</h2><table>
<thead>
<tr>
<th>序号</th>
<th>操作</th>
<th>方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>forEach</td>
<td>void forEach(Consumer&lt;? super T&gt; action);</td>
<td>对流中的每个元素执行指定的操作action</td>
<td>遍历</td>
</tr>
<tr>
<td>2</td>
<td>forEachOrdered</td>
<td>void forEachOrdered(Consumer&lt;? super T&gt; action)</td>
<td>如果有序，则按序遍历流中元素，针对每个元素执行指定操作</td>
<td>按序遍历</td>
</tr>
<tr>
<td>3</td>
<td>toArray</td>
<td>Object[] toArray()</td>
<td>返回一个包含流中所有元素的数组</td>
<td>数组化</td>
</tr>
<tr>
<td>4</td>
<td>toArray</td>
<td>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)</td>
<td>返回一个包含流中所有元素的参数指定类型的数组</td>
<td>数组化</td>
</tr>
<tr>
<td>5</td>
<td>reduce</td>
<td>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</td>
<td>以给定初始值为基础归纳流中元素，返回一个值</td>
<td>归纳</td>
</tr>
<tr>
<td>6</td>
<td>reduce</td>
<td>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</td>
<td>直接归纳流中的元素，返回一个封装有结果的Optional</td>
<td>归纳</td>
</tr>
<tr>
<td>7</td>
<td>reduce</td>
<td>&lt;U&gt; U reduce(U identity,  BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</td>
<td>以给定的初始值为基础，（并行）归纳流中元素，最后将各个线程的结果再统一归纳，返回一个值</td>
<td>归纳</td>
</tr>
<tr>
<td>8</td>
<td>collect</td>
<td>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</td>
<td>根据给定的收集器收集元素</td>
<td>归纳</td>
</tr>
<tr>
<td>9</td>
<td>collect</td>
<td>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</td>
<td>根据给定的各个参数归纳元素</td>
<td>归纳</td>
</tr>
<tr>
<td>10</td>
<td>max</td>
<td>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</td>
<td>根据给定的比较器，返回流中最大元素的Optional表示</td>
<td>最大值</td>
</tr>
<tr>
<td>11</td>
<td>min</td>
<td>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)</td>
<td>根据给定的比较器，返回流中最小元素的Optional表示</td>
<td>最小值</td>
</tr>
<tr>
<td>12</td>
<td>count</td>
<td>long count()</td>
<td>返回流中元素的个数</td>
<td>计数</td>
</tr>
<tr>
<td>13</td>
<td>anyMatch</td>
<td>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>校验流中是否有满足给定条件的元素</td>
<td>校验</td>
</tr>
<tr>
<td>14</td>
<td>allMatch</td>
<td>boolean allMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>校验流中的元素是否全部满足给定条件</td>
<td>校验</td>
</tr>
<tr>
<td>15</td>
<td>noneMatch</td>
<td>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>校验流中的元素是否全不满足给点条件</td>
<td>校验</td>
</tr>
<tr>
<td>16</td>
<td>findFirst</td>
<td>Optional&lt;T&gt; findFirst()</td>
<td>返回首个元素的Optional表示，如果为空流，返回空的Optional</td>
<td>返回首个元素</td>
</tr>
<tr>
<td>17</td>
<td>findAny</td>
<td>Optional&lt;T&gt; findAny()</td>
<td>如果流中有元素，则返回第一个元素的Optional表示，否则返回一个空的Optional</td>
<td>校验是否为空流</td>
</tr>
</tbody></table>
<h3 id="forEach和forEachOrdered"><a href="#forEach和forEachOrdered" class="headerlink" title="forEach和forEachOrdered"></a>forEach和forEachOrdered</h3><p>forEach就是遍历操作，对流中的每个元素做最后的操作</p>
<p>forEach并行遍历不保证顺序（顺序随机）,forEachOrdered是保证顺序来进行遍历的</p>
<h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><p>toArray有两个重载方法，一个是无参方法，一个有参方法</p>
<p>无参方法返回的只能是Object[]数组类型，而有参方法，可以指定结果数组类型，此乃二者区别</p>
<p>使用有参方法可以直接完成类型转换，一次到位</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce有三个重载方法，它们作用其实是一样的，就是归纳总结的意思</p>
<ul>
<li><p>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</p>
<p>参数accumulator是一个累加器，方法的作用是将这个累加器作用到流中的每一个元素需，要两个输入参数，有一个输出参数，意思是对两个元素执行某些操作，返回一个结果，然后将这个结果与下一个元素作为参数再输入该方法，执行操作后再返回一个新结果，以此类推，直到最后一个元素执行完毕，返回的就是最终结果，因为流中的元素我们是不确定的，那么我们就无法确定reduce的结果，因为如果流为空，那么将会返回null，所以使用Optional作为返回值，妥善处理null值</p>
</li>
<li><p>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</p>
<p>在上方法的基础上加了一个identity，且不使用Optional。原因是新加的identity是个初始值，后续操作都在这个初始值基础上进行，即使流中没有元素也不会返回null</p>
</li>
<li><p>&lt;U&gt; U reduce(U identity,  BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</p>
<p>在上方法的基础上又加了个参数combiner，这个方法用于处理并行流的归纳操作，最后的参数combiner用于归纳各个并行的结果</p>
</li>
</ul>
<h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>collect操作是Stream中最强大的方法了，几乎可以得到任何你想要的结果，collect方法有两个重载方法</p>
<ul>
<li><p>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</p>
<p>supplier用于生成一个R类型的结果容器来盛放结果，accumulator累加器用于定义盛放的方式，其中T为一个元素，R为结果容器，第三个参数combiner的作用是将并行操作的各个结果整合起来</p>
</li>
<li><p>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector</p>
<p>Collector是定义来承载一个收集器，但是JDK提供了一个Collectors工具类，在这个工具类里面预实现了N多的Collector供我们直接使用，之前的Collectors.toList()就是其用法之一</p>
</li>
</ul>
<h3 id="max和min"><a href="#max和min" class="headerlink" title="max和min"></a>max和min</h3><p>通过给定的比较器，得出流中最大\最小的元素，为避免null返回，这里使用Optional来封装返回值</p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>count是无参方法，用于计数，返回流中元素个数</p>
<h3 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h3><p>该方法需要一个Predicate参数，用于校验流中的元素，只要有一个满足规则，则返回true，全不满足，返回false</p>
<h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p>该方法需要一个Predicate参数，用于校验流中的所有元素，只有全部满足规则才能返回true，只要有一个不满足则返回false</p>
<h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p>该方法需要一个Predicate参数，用于校验流中的所有元素,只有所有元素都不满足规则的情况下返回true，否则返回false</p>
<h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p>该方法无参数，主要用于获取流中的第一个元素，如果流无序，那么可能返回任意一个</p>
<h3 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h3><p>该方法无参数，主要用于获取流中的任一元素</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性：函数式编程</title>
    <url>/2020/03/16/31228/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JDK1.8引入了函数式编程，重点包括函数式接口、lambda表达式和方法引用等</p>
<p>所谓函数式编程是把函数作为一个基本单位进行传递。以往Java中参数只能是具体的变量，二函数式编程打破这一规范，可以把整个方法作为一个参数传递</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是JDK1.8时提出的概念，但其实以往的JDK中就已经存在这些结构，只是没有定义化</p>
<p>函数式接口就是只有一个抽象方法的接口。常用的有 <strong>Runnable</strong>、<strong>Comparator</strong> 等</p>
<p>为了规范化，同时避免用户自定义函数式接口时错误地添加其他抽象方法，定义了一个注解 <strong>@FunctionalInterface</strong>，凡是由该注解标注的接口皆为函数式接口，强制的只能有一个抽象方法</p>
<p>为了函数式接口的扩展，JDK对接口规范进行了修改，接口中除了可以定义抽象方法之外，还可以定义静态方法和默认方法。其中静态方法一般作为工具方法，二默认方法是可以被继承重写的，还能有一个默认实现。除此之外，函数式接口中还可以重写Object中定义的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 典型函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Itest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;<span class="comment">// 重写Object中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这是一个默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这是一个静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK中预定义的函数式接口</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>接口名</th>
<th>抽象方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Supplier&lt;T&gt;</td>
<td>T get()</td>
<td>通过操作返回结果</td>
<td>无中生有</td>
</tr>
<tr>
<td>2</td>
<td>IntSupplier</td>
<td>int getAsInt()</td>
<td>通过操作返回一个int值</td>
<td>无中生有</td>
</tr>
<tr>
<td>3</td>
<td>LongSupplier</td>
<td>long getAsLong()</td>
<td>通过操作返回一个long值</td>
<td>无中生有</td>
</tr>
<tr>
<td>4</td>
<td>DoubleSupplier</td>
<td>double getAsDouble()</td>
<td>通过操作返回一个double值</td>
<td>无中生有</td>
</tr>
<tr>
<td>5</td>
<td>BooleanSupplier</td>
<td>boolean getAsBoolean()</td>
<td>通过操作返回一个boolean值</td>
<td>无中生有</td>
</tr>
<tr>
<td>6</td>
<td>Consumer&lt;T&gt;</td>
<td>void accept(T t)</td>
<td>针对参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>7</td>
<td>BiConsumer&lt;T,U&gt;</td>
<td>void accept(T t,U u)</td>
<td>针对两个参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>8</td>
<td>IntConsumer</td>
<td>void accept(int value)</td>
<td>针对int参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>9</td>
<td>LongConsumer</td>
<td>void accept(long value)</td>
<td>针对long参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>10</td>
<td>DoubleConsumer</td>
<td>void accept(double value)</td>
<td>针对double参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>11</td>
<td>ObjIntConsumer&lt;T&gt;</td>
<td>void accept(T t, int value)</td>
<td>针对T和int参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>12</td>
<td>ObjLongConsumer&lt;T&gt;</td>
<td>void accept(T t, long value)</td>
<td>针对T和long参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>13</td>
<td>ObjDoubleConsumer&lt;T&gt;</td>
<td>void accept(T t, double value)</td>
<td>针对T和double参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>14</td>
<td>Function&lt;T, R&gt;</td>
<td>R apply(T t)</td>
<td>根据参数生成一个返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>15</td>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>R apply(T t,U u)</td>
<td>根据两个参数生成一个返回值</td>
<td>多因一果</td>
</tr>
<tr>
<td>16</td>
<td>IntFunction&lt;R&gt;</td>
<td>R apply(int value)</td>
<td>根据int参数生成一个返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>17</td>
<td>LongFunction&lt;R&gt;</td>
<td>R apply(long value)</td>
<td>根据long参数生成一个返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>18</td>
<td>DoubleFunction&lt;R&gt;</td>
<td>R apply(double value)</td>
<td>根据double参数生成一个返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>19</td>
<td>ToIntFunction&lt;T&gt;</td>
<td>int applyAsInt(T value)</td>
<td>根据一个参数生成一个int返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>20</td>
<td>ToIntBiFunction&lt;T, U&gt;</td>
<td>int applyAsInt(T t, U u)</td>
<td>根据两个参数生成一个int返回值</td>
<td>多因一果</td>
</tr>
<tr>
<td>21</td>
<td>ToLongFunction&lt;T&gt;</td>
<td>long applyAsLong(T value)</td>
<td>根据一个参数生成一个long返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>22</td>
<td>ToLongBiFunction&lt;T, U&gt;</td>
<td>long applyAsLong(T t, U u)</td>
<td>根据两个参数生成一个long返回值</td>
<td>多因一果</td>
</tr>
<tr>
<td>23</td>
<td>ToDoubleFunction&lt;T&gt;</td>
<td>double applyAsDouble(T value)</td>
<td>根据一个参数生成一个double返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>24</td>
<td>ToDoubleBiFunction&lt;T, U&gt;</td>
<td>double applyAsDouble(T t, U u)</td>
<td>根据两个参数生成一个double返回值</td>
<td>多因一果</td>
</tr>
<tr>
<td>25</td>
<td>IntToLongFunction</td>
<td>long applyAsLong(int value)</td>
<td>根据int参数生成一个long结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>26</td>
<td>IntToDoubleFunction</td>
<td>double applyAsDouble(int value)</td>
<td>根据int参数生成一个double结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>27</td>
<td>LongToIntFunction</td>
<td>int applyAsInt(long value)</td>
<td>根据long参数生成一个int结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>28</td>
<td>LongToDoubleFunction</td>
<td>double applyAsDouble(long value)</td>
<td>根据long参数生成一个double结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>29</td>
<td>DoubleToIntFunction</td>
<td>int applyAsInt(double value)</td>
<td>根据double参数生成一个int结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>30</td>
<td>DoubleToLongFunction</td>
<td>long applyAsLong(double value)</td>
<td>根据double参数生成一个long结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>31</td>
<td>Predicate&lt;T&gt;</td>
<td>boolean test(T t)</td>
<td>根据参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>32</td>
<td>BiPredicate&lt;T, U&gt;</td>
<td>boolean test(T t, U u)</td>
<td>根据两个参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>33</td>
<td>IntPredicate</td>
<td>boolean test(int value)</td>
<td>根据int参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>34</td>
<td>LongPredicate</td>
<td>boolean test(long value)</td>
<td>根据long参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>35</td>
<td>DoublePredicate</td>
<td>boolean test(double value)</td>
<td>根据double参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>36</td>
<td>UnaryOperator&lt;T&gt;</td>
<td>T apply(T t)</td>
<td>根据参数通过操作返回结果</td>
<td>一元操作</td>
</tr>
<tr>
<td>37</td>
<td>BinaryOperator&lt;T&gt;</td>
<td>T apply(T t1,T t2)</td>
<td>根据两个参数通过操作返回结果</td>
<td>二元操作</td>
</tr>
<tr>
<td>38</td>
<td>IntUnaryOperator</td>
<td>int applyAsInt(int operand)</td>
<td>根据int参数通过操作返回int结果</td>
<td>一元操作</td>
</tr>
<tr>
<td>39</td>
<td>IntBinaryOperator</td>
<td>int applyAsInt(int left, int right)</td>
<td>根据两个int参数通过操作返回int结果</td>
<td>二元操作</td>
</tr>
<tr>
<td>40</td>
<td>LongUnaryOperator</td>
<td>long applyAsLong(long operand)</td>
<td>根据long参数通过操作返回long结果</td>
<td>一元操作</td>
</tr>
<tr>
<td>41</td>
<td>LongBinaryOperator</td>
<td>long applyAsLong(long left, long right)</td>
<td>根据两个long参数通过操作返回long结果</td>
<td>二元操作</td>
</tr>
<tr>
<td>42</td>
<td>DoubleUnaryOperator</td>
<td>double applyAsDouble(double operand)</td>
<td>根据double参数通过操作返回double结果</td>
<td>一元操作</td>
</tr>
<tr>
<td>43</td>
<td>DoubleBinaryOperator</td>
<td>double applyAsDouble(double left, double right)</td>
<td>根据两个double参数通过操作返回double结果</td>
<td>二元操作</td>
</tr>
</tbody></table>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式可用于两个地方：集合遍历和替换匿名内部类。前者基于 <strong>Iterable</strong> 接口中定义的 <strong>forEach</strong> 方法，后者则依据函数式接口</p>
<ol>
<li><p><strong>forEach</strong> 方法</p>
<p>forEach方法是对函数式接口的有效利用，将遍历的书写流程简化，不用再写一大堆的for循环框架代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LanbdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Collections.EMPTY_LIST;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">        Map&lt;String,Object&gt; map = Collections.EMPTY_MAP;</span><br><span class="line">        map.forEach((k,v) -&gt; System.out.println(k + <span class="string">":"</span>+ v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>forEach</strong> 方法的参数是 <strong>Consumer</strong> 或 <strong>BigConsumer</strong>，主要是用于消费资源，即需提供参数但没有返回值的方法</p>
<p><strong>Iterable</strong> 中的 <strong>forEach</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Iterable</strong> 的实现类均可以通过重写该方法来自定义遍历的方式</p>
</li>
<li><p>替换匿名内部类</p>
<p>Lambda替换匿名内部类有一个前提，那就是这个匿名内部类的接口类型必须为函数式接口，如果不是函数式接口，是无法使用Lambda替换的</p>
<p>常用的函数式接口为 <strong>Runnable</strong>，使用匿名内部类方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"采用匿名内部类"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lambda替换如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"采用匿名内部类"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用出现的目的是为了解决所需的操作已经存在的情况</p>
<p>当我们需要传递的操作已经存在，那就不必再费尽心思的再写一个出来啦，直接使用方法引用来将已有的方法给它就行了</p>
<p>方法引用使用<code>::</code>双冒号组成的操作符来指定方法，参数不再是显式传递，而是会自动传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LanbdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(Supplier&lt;String&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"huahua"</span>);</span><br><span class="line">        System.out.println(getName(person::getName)); <span class="comment">// 打印：huahua</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们使用了方法引用：person::getName，Person类中有已定义好的获取name的方法，这里就可以直接引用该方法。Supplier是供应者，可以无中生有，也就是不需要参数，产生一个返回值</p>
<p>方法引用的种类：</p>
<ul>
<li>类的构造器引用：ArrayList::new、String[]::new</li>
<li>类的静态方法引用：String::valueOf、Integer::valueOf</li>
<li>类的实例方法引用：String::length、Person::getName</li>
<li>对象的实例方法引用：sring::length、person::getName</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识：Enum深入解析</title>
    <url>/2020/03/16/36839/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>枚举是一个语法糖，使用 <strong>enum</strong> 定义一个枚举，实际上是定义了一个类继承了 <strong>Enum</strong> 类</p>
<p>了解了 <strong>Enum</strong> 类，就能了解枚举</p>
<h2 id="Enum-解析"><a href="#Enum-解析" class="headerlink" title="Enum 解析"></a>Enum 解析</h2><ol>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Constable</span>, <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>枚举类实现了 <strong>Comparable</strong> 和 <strong>Serializable</strong> 接口，这表示每个枚举都拥有比较和序列化的功能</p>
</li>
<li><p>属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个属性是枚举的内置属性，name表示枚举值的名称，ordinal表示枚举值的序号</p>
</li>
<li><p>构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Enum</strong> 只有这一个构造器，声明为protected是为了让继承它的子类(即我们定义的各种枚举)来调用</p>
</li>
<li><p>equals和hashcode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>==other;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的equals方法就是直接使用==来比较的，所以枚举的比较使用==和equals都是可以的</p>
</li>
<li><p>禁用的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这四个方法被禁用，目的是：</p>
<ul>
<li>clone 保证单例唯一</li>
<li>finalize 禁用终引用</li>
<li>readObjeect 保证单例唯一</li>
<li>readObjectNoData 保证单例唯一</li>
</ul>
</li>
<li><p>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span> </span>&#123;</span><br><span class="line">    Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;</span><br><span class="line">    Enum&lt;E&gt; self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (self.getClass() != other.getClass() &amp;&amp; <span class="comment">// optimization</span></span><br><span class="line">        self.getDeclaringClass() != other.getDeclaringClass())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">    <span class="keyword">return</span> self.ordinal - other.ordinal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span> </span>&#123;</span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">         <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>compartTo 用于定义比较的方式，可以看出是使用序号作为比较条件的</li>
<li>valueOf 用于获取到指定枚举类型中指定枚举名称的枚举值</li>
</ul>
</li>
</ol>
<h2 id="枚举的实现"><a href="#枚举的实现" class="headerlink" title="枚举的实现"></a>枚举的实现</h2><p>枚举是一种编译器语法糖，当使用 <strong>enum</strong> 关键字定义一个枚举，编译之后，编译器会对其进行加工：</p>
<ul>
<li>编译成class类型，并继承Enum</li>
<li>添加静态方法values，用于获取所以枚举值的数组</li>
<li>添加方法valueOf，实现Enum中的valueOf方法，可根据具体的枚举名称字符串获取对应枚举值</li>
<li>添加私有构造器，其中调用Enum中定义的唯一的构造器</li>
<li>定义静态常量枚举值</li>
<li>添加静态块为这些静态枚举常量赋值</li>
</ul>
<p>通过上述方法加工之后，枚举类被解析为一个普通的类，类名不变</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解(3)：无重复字符的最长字串</title>
    <url>/2020/03/14/24182/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>长度</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3<br>请注意，你的答案必须是<strong>子串</strong>的长度，”pwke” 是一个子序列，不是子串</p>
</blockquote>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>使用一个哈希表，key为字符，value为字符下标+1，+1表示从字符位置后一个开始才不重复</p>
<p>使用两个变量 l，r表示非重复字串的左右两端索引</p>
<p>遍历字符串，当遇到重复字符时，更新 l 值</p>
<p>无论是否更新 l ，都会更新 map 和结果 max</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, len = s.length();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; len; r++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(r);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">            l = Math.max(map.get(c), l);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, r - l + <span class="number">1</span>);</span><br><span class="line">        map.put(c, r + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n)$，空间复杂度 $O(min(m,n))$</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解(2)：两数相加</title>
    <url>/2020/03/14/33378/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<p>相关标签：<strong>链表</strong> <strong>数学</strong></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode a = l1, b = l2, cur = result;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = a == <span class="keyword">null</span> ? <span class="number">0</span> : a.val;</span><br><span class="line">        <span class="keyword">int</span> q = b == <span class="keyword">null</span> ? <span class="number">0</span> : b.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v = (p + q + n) % <span class="number">10</span>;</span><br><span class="line">        n = (p + q + n) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(v);</span><br><span class="line">        cur = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            a = a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(max(m,n))​$，空间复杂度 $O(max(m,n))​$</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解(1)：两数之和</title>
    <url>/2020/03/14/26270/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<p>相关标签： <strong>数组</strong> <strong>哈希表</strong></p>
<h2 id="解法1-暴力破解"><a href="#解法1-暴力破解" class="headerlink" title="解法1 暴力破解"></a>解法1 暴力破解</h2><p>遍历数组，对每个元素 nums[i]，查找剩下的元素中是否有值等于 target-nums[i]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target - nums[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n^2)$，空间复杂度 $O(1)​$</p>
<h2 id="解法2-两遍哈希表"><a href="#解法2-两遍哈希表" class="headerlink" title="解法2 两遍哈希表"></a>解法2 两遍哈希表</h2><p>构建一个哈希表，第一次循环时把元素的值和索引添加到表中，第二次循环时检查每个元素 nums[i] 所对应的目标元素 target-nums[i] 是否在表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put( nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = target - nums[i];</span><br><span class="line">        Integer index = map.get(val);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val) &amp;&amp; index != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, index&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n)$，空间复杂度 $O(n)​$</p>
<h2 id="解法3-一遍哈希表"><a href="#解法3-一遍哈希表" class="headerlink" title="解法3 一遍哈希表"></a>解法3 一遍哈希表</h2><p>在第一次循环时就检查每个元素 nums[i] 所对应的目标元素 target-nums[i] 是否在表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum3(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = target - nums[i];</span><br><span class="line">        Integer index = map.get(val);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val) &amp;&amp; index != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, index&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n)$，空间复杂度 $O(n)$</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：斐波那契数列</title>
    <url>/2020/03/04/25921/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>斐波那契数列是这样一个数列，它满足：$f(n)=\begin{cases}0&amp;\text{n=0}\\1&amp;\text{n=1}\\f(n-1)+f(n-2)&amp;\text{n&gt;=2}\end{cases}$</p>
<h2 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h2><p>实现很简单，当n=0返回0，n=1返回1，当n&gt;=2时使用递归返回前两项之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> n &lt; <span class="number">2</span> ? n : fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码很简单，只用1行就实现了斐波那契的算法，但这种单纯的递归实现会有很严重的性能问题。我用自己电脑计算 fib(50) 时就花了大概45秒，fib(60) 就算不出来了，一直卡着</p>
<p>之所以出现这种情况，是因为在递归的过程中存在大量重复的计算，如下图所示：</p>
<img src="/2020/03/04/25921/fibonacci1.jpg" class="">

<p>可见，仅仅是对 fib(10) 的计算，而且仅画出了4层，就出现了大量的重复。随着 n 的递增，为求出结果，重复的计算会急剧增加，这种方法的时间复杂度是 $O(n^2)​$</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>使用尾递归，把每次计算的结果保存下来，计算结果参与下一次的计算，从而减少计算量。原本递归产生的栈的层次像二叉树一样以指数级增长，现在栈的层次像数组，变成线性增长了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">long</span> first, <span class="keyword">long</span> second, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first + second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(second, first + second, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h2><p>不使用递归，而是使用迭代的方式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n1 = <span class="number">0</span>, n2 = <span class="number">1</span>, n3 = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        n3 = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现3"><a href="#实现3" class="headerlink" title="实现3"></a>实现3</h2><p>实际上斐波那契数列数列是有非递推式的通项公式的: $f(n)=\frac{1}{\sqrt5}(\frac{1+\sqrt5}{2})^n-\frac{1}{\sqrt5}(\frac{1-\sqrt5}{2})^n$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>) (Math.pow((<span class="number">1</span> + Math.sqrt(<span class="number">5</span>)) / <span class="number">2</span>, n) / Math.sqrt(<span class="number">5</span>)</span><br><span class="line">                   - Math.pow((<span class="number">1</span> - Math.sqrt(<span class="number">5</span>)) / <span class="number">2</span>, n) / Math.sqrt(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通项公式中要求某个数的 n 次幂，所以空间复杂度为 $O(\log_2n)$</p>
<h2 id="实现4"><a href="#实现4" class="headerlink" title="实现4"></a>实现4</h2><p>使用矩阵快速幂方式实现</p>
<p>斐波那契数列的通项公式为 $f(n)=\begin{cases}0&amp;\text{n=0}\\1&amp;\text{n=1}\\f(n-1)+f(n-2)&amp;\text{n&gt;=2}\end{cases}$</p>
<p>根据通项公式可写成以下形式：</p>
<p>$f(n+1)=1*f(n)+1*f(n-1)$</p>
<p>$f(n)=1*f(n-1)+1*f(n-2)$</p>
<p>$f(n)=1*f(n)+0*f(n-1)$</p>
<p>$f(n-1)=1*f(n-1)+0*f(n-2)​$</p>
<p>用矩阵表示为：</p>
<p>$$\begin{bmatrix}f(n+1)&amp;f(n)\\f(n)&amp;f(n-1)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}*\begin{bmatrix}f(n)&amp;f(n-1)\\f(n-1)&amp;f(n-2)\end{bmatrix}$$</p>
<p>进一步，可得：</p>
<p>$$\begin{bmatrix}f(n+1)&amp;f(n)\\f(n)&amp;f(n-1)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^2*\begin{bmatrix}f(n-1)&amp;f(n-2)\\f(n-2)&amp;f(n-3)\end{bmatrix}$$</p>
<p>$$=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-1}*\begin{bmatrix}f(2)&amp;f(1)\\f(1)&amp;f(0)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^n$$</p>
<p>所以通过求矩阵 $\begin{bmatrix}1&amp;1\\ 1&amp;0\end{bmatrix}​$ 的n次方就可以得到 $f(n)​$ 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>[][] UNIT = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] fib(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// n 为偶数</span></span><br><span class="line">        <span class="keyword">long</span>[][] matrix = fib(n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMultiply(matrix, matrix);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n 为奇数</span></span><br><span class="line">        <span class="keyword">long</span>[][] matrix = fib((n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMultiply(UNIT, matrixMultiply(matrix, matrix));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] matrixMultiply(<span class="keyword">long</span>[][] a, <span class="keyword">long</span>[][] b) &#123;</span><br><span class="line">    <span class="keyword">int</span> row = a.length, col = b[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">long</span>[][] result = <span class="keyword">new</span> <span class="keyword">long</span>[row][col];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a[i].length; k++) &#123;</span><br><span class="line">                result[i][j] += a[i][k] * b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现5"><a href="#实现5" class="headerlink" title="实现5"></a>实现5</h2><p>在GMP(GNU多重精度算术库)中，它并没有使用矩阵快速幂的方法，而是使用递推式，不过它使用的递推式更加复杂：</p>
<p>$$f(2k+1)=4*f(k)^2-f(k-1)^2+2*(-1)^k$$</p>
<p>$$f(2k-1)=f(k)^2+f(k-1)^2$$</p>
<p>$$f(2k)=f(2k+1)-f(2k-1)$$</p>
<p>这个算法首先把n转化成二进制形式，然后从最高位开始向低位遍历，设m的二进制前i位(0到i-1位)表示的值为 $k_i​$，那么 $f(k_i)​$ 和 $f(k_i-1)​$ 都是已知的</p>
<ul>
<li>如果第i位为1，那么就用已知的 $f(k_i)$ 和 $f(k_i-1)$ 计算 $f(2k_i+1)$ 和 $f(2k_i)$，得到 $f(k_{i+1})$ 和 $f(k_{i+1}-1)​$</li>
<li>如果第i位为0，那么就用已知的 $f(k_i)​$ 和 $f(k_i-1)​$ 计算 $f(2k_i)​$ 和 $f(2k_i-1)​$，得到 $f(k_{i+1})​$ 和 $f(k_{i+1}-1)​$</li>
</ul>
<p>可以看到迭代的次数跟n的二进制长度一致，所以其时间复杂度也是 $O(\log_2n)$</p>
<p>需要注意的是，上述递推式中的 $f(k)^2$ 和 $f(k-1)^2$ 是可以复用的，实际上每一次迭代只需要进行两次大整数乘法运算</p>
<p>举个栗子：求 $f(25)$，已知 $f(-1)=1$，$f(0)=0$</p>
<p>首先把25转化为二进制形式11001，从最高位开始，它是1，那么此时 k=0</p>
<p>$$f(1)=4*f(0)^2=f(-1)^2+2=1$$</p>
<p>$$f(-1)=1$$</p>
<p>$$f(0)=0$$</p>
<p>然后第2位，同样为1，此时 k=1</p>
<p>$$f(3)=4*f(1)^2-f(0)^2-2=2$$</p>
<p>$$f(1)=1$$</p>
<p>$$f(2)=f(3)-f(1)=1$$</p>
<p>第3位为0，此时 k=3</p>
<p>$$f(7)=4*f(3)^2-f(2)^2-2=13$$</p>
<p>$$f(5)=f(3)^2+f(2)^2=5$$</p>
<p>$$f(6)=f(7)-f(5)=8$$</p>
<p>第4位为0，此时 k=6</p>
<p>$$f(13)=4*f(6)^2-f(5)^2+2=13$$</p>
<p>$$f(11)=f(6)^2+f(5)^2=98$$</p>
<p>$$f(12)=f(13)-f(11)=144$$</p>
<p>第5位为1，此时 k=12，得到最终结果</p>
<p>$$f(25)=4*f(12)^2-f(11)^2+2=75025$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    String b = Integer.toBinaryString(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> prev = <span class="number">1</span>, cur = <span class="number">0</span>, sign = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> prev2 = prev * prev;</span><br><span class="line">        <span class="keyword">long</span> cur2 = cur * cur;</span><br><span class="line">        cur = <span class="number">4</span> * cur2 - prev2 + sign;</span><br><span class="line">        prev = cur2 + prev2;</span><br><span class="line">        <span class="keyword">if</span> (b.charAt(i) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            cur = cur - prev;</span><br><span class="line">            sign = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b.charAt(i) == <span class="string">'1'</span>) &#123;</span><br><span class="line">            prev = cur - prev;</span><br><span class="line">            sign = -<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法总结</title>
    <url>/2020/03/04/45778/</url>
    <content><![CDATA[<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th>排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(n^{1.3})$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td>In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n)$</td>
<td>Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td>Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n+k)$</td>
<td>Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td>Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p><a href="/2020/02/21/61456/">冒泡排序</a></p>
<p>（无序区，有序区）从无序区通过交换找出最大元素放到有序区前端</p>
</li>
<li><p><a href="/2020/02/21/39445/">选择排序</a></p>
<p>（有序区，无序区）在无序区中找出一个最小的元素跟在有序区后面</p>
</li>
<li><p><a href="/2020/02/21/1609/">插入排序</a></p>
<p>（有序区，无序区）把无序区的第一个元素插入到有序区的合适位置</p>
</li>
<li><p><a href="/2020/02/22/53145/">希尔排序</a></p>
<p>每一轮按照事先决定的间隔进行插入排序，间隔会逐渐缩小至1</p>
</li>
<li><p><a href="/2020/02/22/20366/">快速排序</a></p>
<p>（小数，基准值，大数）在区间中选择一个元素作为基准，把小于基准的元素放在基准之前，大于基准的元素放在基准之后，在分别对小数区和大数区进行排序</p>
</li>
<li><p><a href="/2020/02/24/27532/">归并排序</a></p>
<p>把数据分为两段，从两段中组个选最小的元素移入新数据段的末尾</p>
</li>
<li><p><a href="/2020/03/03/14948/">堆排序</a></p>
<p>（最大堆，有序区）从堆顶把根节点取出来放在有序区之前，再恢复堆</p>
</li>
<li><p><a href="/2020/03/03/4826/">计数排序</a></p>
<p>统计小于等于该元素值的个数 i，该元素就放在目标数组的索引 i 位</p>
</li>
<li><p><a href="/2020/03/03/52110/">桶排序</a></p>
<p>遍历数组把各元素放入对于的桶中，再对桶中个元素进行排序</p>
</li>
<li><p><a href="/2020/03/04/53833/">基数排序</a></p>
<p>低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(10)：基数排序</title>
    <url>/2020/03/04/53833/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>取得数组中的最大数，并取得位数</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/04/53833/radix.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化10个桶</span></span><br><span class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次循环 n*10，当 max/n小于0 时说明已经遍历到了最高位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; max / n &gt; <span class="number">0</span>; n *= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            buckets[(arr[i] / n) % <span class="number">10</span>][i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buckets[j][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    arr[index++] = buckets[j][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(9)：桶排序</title>
    <url>/2020/03/03/52110/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>设定一个定量的数组当作空桶</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶中</li>
<li>对每个不是空的桶进行排序</li>
<li>从不是空的桶里把排好序的数据拼接起来</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/03/52110/bucket.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出数组最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = (value - min) / arr.length;</span><br><span class="line">        bucketArr.get(num).add(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; integers : bucketArr) &#123;</span><br><span class="line">        Collections.sort(integers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把桶中元素取回原数组</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; integers : bucketArr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            arr[index++]=integer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(8)：计数排序</title>
    <url>/2020/03/03/4826/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去1</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/03/4826/counting.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组中最大的值</span></span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 遍历数组arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        count[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, index = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>若原数组值的范围不是从0开始的，计数数组的前面部分空间就会浪费。可以再定义一个变量 min，在给count数组某个下标赋值时把下标减去min</li>
<li>上面的实现中算法是不稳定的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出数组最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数数组，记录每个数组出现的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        count[value - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数每个数字在排序后数组中应该处于的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp = arr.clone();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        arr[--count[temp[i] - min]] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>计数排序是非比较排序，它适用于特定问题，也就是对源数据有要求</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(7)：堆排序</title>
    <url>/2020/03/03/14948/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>堆排序是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区</li>
<li>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1,R2,……Rn-1) 和新的有序区 (Rn)，且满足R[1,2…n-1]&lt;=R[n]</li>
<li>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1,R2,……Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区 (Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/03/14948/heap.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后节点的父节点开始把原数组构建为堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次把堆顶元素和最后一个元素交换，再把堆顶heapify</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr, i, <span class="number">0</span>);</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] tree, <span class="keyword">int</span> size, <span class="keyword">int</span> curRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点大于size时退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (curRoot &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前节点的左右字节点索引</span></span><br><span class="line">    <span class="keyword">int</span> l = curRoot * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = curRoot * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> max = curRoot;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; size &amp;&amp; tree[l] &gt; tree[max]) &#123;</span><br><span class="line">        max = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; size &amp;&amp; tree[r] &gt; tree[max]) &#123;</span><br><span class="line">        max = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把当前节点、左右子节点中最大的值与当前节点交换</span></span><br><span class="line">    <span class="keyword">if</span> (max != curRoot) &#123;</span><br><span class="line">        swap(tree, max, curRoot);</span><br><span class="line">        heapify(tree, size, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Bilibili弹幕屏蔽正则</title>
    <url>/2020/02/26/65032/</url>
    <content><![CDATA[<p>自用的b站弹幕屏蔽正则，有效屏蔽一些刷屏、玩烂梗、nt的弹幕</p>
<ol>
<li><p>前排</p>
<p><code>/^\s*[前第]\s*(排|\d+|[二-十]|一$)|关上.+大门/</code></p>
</li>
<li><p>时间</p>
<p><code>/(\d+\D)?\d+\D\d+|年?.+月.+日?|(\d+|[一-十])[十百千万]?(世纪|辈子|年|月|时|小时|分钟|秒)(前|后见)?[^0-9a-zA-Z\u4e00-\u9fa5]*$/</code></p>
</li>
<li><p>+1怪</p>
<p><code>/(\+|加)(\d+|[一-十])[^sS秒]/</code></p>
</li>
<li><p>变色</p>
<p><code>/变.*色|色.*变|(颜|什么.?)色|[戴带].*[冠帽]|[冠帽].*[戴带掉]|帽子|爱.?一.?光|自然.?力量|我.*白色?的?[？?]*$|^(.?[紫基].{2,3}|.?[橘桔].{2,3})$/</code></p>
</li>
<li><p>存活</p>
<p><code>/确\s*认\s*存\s*活|存\s*活\s*确\s*认|^(存活|活着)/</code></p>
</li>
<li><p>完结撒花</p>
<p><code>/[完玩万]\s*[结节結節截美].*[撒散洒杀啥]|[撒散洒杀啥]\s*花[^0-9a-zA-Z\u4e00-\u9fa5]*$|感\s*谢\s*陪\s*伴/</code></p>
</li>
<li><p>虚空对话</p>
<p><code>/([前后上下]面的?|你|[那这]个).*(等|够了|休想|你|我|在下|[跟带加]上)|恶?魔鬼?[吗吧]?[^0-9a-zA-Z\u4e00-\u9fa5]*$/</code></p>
</li>
<li><p>自我意识过剩+饭圈</p>
<p><code>/(我[哒的].?|我.?([男女基]朋?友|老[公婆])|参上|一拜)[^0-9a-zA-Z\u4e00-\u9fa5]*$|是我的|我的[就，\s]|我.*(表示|接受)|归我|承包|[我俺]也?一|先.为敬/</code></p>
</li>
<li><p>nt+烂梗</p>
<ul>
<li><code>/(出现|[上发传转放在到至]).*[在到至]?([bBpP批破比逼哔][iI]?[站占战]|[哔批][里哩]|[bBpP][iI][lL][iI])/</code></li>
<li><code>/(([你女汝][听闻看瞧]|([看听瞧说评])\3|这是).*人|^.?人).*[言话]|[做当作坐座]个人|人.*干.*事/</code></li>
<li><code>/[一亿]人[一亿].|夸父|水娃|我.*喝[一亿]口/</code></li>
<li><code>/典[明眀]粥|[啊阿][帕怕伯泊]基?茶|抽紫烟|神父.*碟|[jJ][iI]?[oO]\s*(等|印|护车)|[bB][oO].*[kK][iI]|上一.+(现在|已经)/</code></li>
<li><code>/[开放停][炮火箭]|[敌友]军|厚葬|秀|意大利[炮跑泡砲面]/</code></li>
<li><code>/[掉上下]线|挂机|回合|重连|续费|登[录陆] |(参与|[介加进]入|[退逃][离出]|离开).{2,4}$|谢.+[刷送]|^.{1,4}([\s\-•·].+)?表示/</code></li>
<li><code>/你币.了/</code></li>
<li><code>/众所周知.*是一/</code></li>
<li><code>/[糟遭曹漕]老头.+坏/</code></li>
<li><code>/馋.*身[子体]|身[子体].*馋/</code></li>
<li><code>/[你宁您].*([看康瞧瞅听学])(\1|着点)/</code></li>
<li><code>/[下上此这].*名单/</code></li>
<li><code>/左.*右.*(大法|手|失)|^(请求)?空降.*[^\d]|[开收停施]工|[oO][pP]|[eE][dD]|正片|(上|前面).*彩蛋/</code></li>
<li><code>/[掉上下]线|挂机|回合|重连|续费|登[录陆]|([一请参作求出助][站战]|参与|[介加进]入|[退逃][离出]|离开|就位).{0,4}$|谢.+[刷送]|^.{1,4}([\s\-•·].+)?表示/</code></li>
<li><code>/[wW].*[dD].*[nN].*[mM].*[dD]|[aA][1iIlLeE]高闪|秋梨膏|我.+了.*什么好说|[rR][uU][sS][hH].*[bB]/</code></li>
<li><code>/(你|君|あなた).*[指手].*[躍跃飛飞舞動动光]/</code></li>
<li><code>/此生.*来世.*/</code></li>
<li><code>/停止.*行为/</code></li>
<li><code>/.*血赚.*不亏/</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(6)：归并排序</title>
    <url>/2020/02/24/27532/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法</strong>的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列</li>
<li>对这两个子序列分别采用归并排序</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/24/27532/merge.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    sort(arr, aux, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sort(arr, aux, left, mid);</span><br><span class="line">    sort(arr, aux, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    merge(arr, aux, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(arr, left, aux, left, right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = left; t &lt;= right; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分的已经全部放到原数组了，将右半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分的已经全部放到原数组了，将左半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt;= aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分取出的元素较小，那么把左半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分取出的元素较小，那么把右半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>和快速排序一样，对于小数组可以使用插入排序或者选择排序，避免递归调用</li>
<li>在merge调用前，可以判断一下<code>arr[mid]</code>是否小于等于<code>arr[mid+1]</code>。如果是的话那么就不用归并了，数组已经是有序的。原因很简单，既然两个子数组已经有序了，那么<code>arr[mid]</code>是第一个子数组的最大值，<code>arr[mid+1]</code>是第二个子数组的最小值。当<code>a[mid]&lt;=a[mid+1]</code>时，数组整体有序</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    sort(arr, aux, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sort(arr, aux, left, mid);</span><br><span class="line">    sort(arr, aux, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 如果左半数组最大的数小于右半数组最小的数，那么说明这两个数组以及有序，不需要合并</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">        merge(arr, aux, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(arr, left, aux, left, right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = left; t &lt;= right; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分的已经全部放到原数组了，将右半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分的已经全部放到原数组了，将左半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt;= aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分取出的元素较小，那么把左半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分取出的元素较小，那么把右半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= left &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h2><p>在上面的实现中，相当于将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。将一个大的数组的排序划分为小数组的排序是自顶向下的排序。还有一种实现是自底向上的排序，即先两两归并，然后四四归并……</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, i, Math.min(i + <span class="number">7</span>, len - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">7</span>; sz &lt; len; sz += sz) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - sz; i += sz + sz) &#123;</span><br><span class="line">            <span class="comment">// 如果左半数组最大的数小于右半数组最小的数，不需要合并</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i + sz - <span class="number">1</span>] &gt; arr[i + sz]) &#123;</span><br><span class="line">                merge(arr, aux, i, i + sz - <span class="number">1</span>, Math.min(i + sz + sz - <span class="number">1</span>, len - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(5)：快速排序</title>
    <url>/2020/02/22/20366/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从数列中挑出一个元素，称为 “基准”</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作</li>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/20366/quick.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组元素等于1 返回</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 选择左端点为基准</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">        <span class="keyword">int</span> pos = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">            <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                swap(arr, pos, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">        swap(arr, left, pos);</span><br><span class="line">        <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">        quickSort(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速排序最佳情况下时间复杂度为 $O(n\log_2n)$，最坏情况下为 $O(n^2)$，平均复杂度接近最佳情况 $O(n\log_2n)$</p>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化 1"></a>优化 1</h2><p>快排是不断减小问题规模来解决子问题的，需要不断递归。但是递归到规模足够小时，如果继续采用这种 不稳定+递归 的方式执行下去，效率不见得会很好</p>
<p>插入排序的时间复杂度是 $O(n^2)$，但是在已经排序好的数组上面，插入排序的最佳情况是 $O(n)$，插入排序在小数组的排序上是非常高效的，所以在快速排序递归的子序列，如果序列规模足够小，可以使用插入排序替代快速排序，因此可以在快排之前判断数组大小，如果小于一个阈值就使用插入排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort1(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort1(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= left &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-2"><a href="#优化-2" class="headerlink" title="优化 2"></a>优化 2</h2><p>在数组几乎有序时，快排性能不好，因为每趟排序后，左右两个子递归规模相差悬殊，大的那部分时间复杂度最后很可能会达到 $O(n^2)$</p>
<p>解决方法：<strong>三数取中（median-of-three）法</strong>。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中间数位于较为中间的值的可能性就大大提高了。由于整个序列是无序状态，随机选取三个数和从左中右端取三个数其实是一回事，而且随机数生成器本身还会带来时间上的开销，因此随机生成不予考虑</p>
<p>三数取中法对小数组来说有很大的概率选择到一个比较好的pivot，但是对于大数组来说就不足以保证能够选择出一个好的pivot，因此还有个办法是所谓median-of-nine，这个怎么做呢？它是先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为pivot，也就是median-of-three。取样也不是乱来，分别是在左端点、中点和右端点取样。什么时候采用median-of-nine去选择pivot，这里也有个数组大小的阀值，这个值完全是经验值，设定在40，大小大于40的数组使用median-of-nine选择pivot，大小在7到40之间的数组使用median-of-three选择中数，大小等于7的数组直接选择中数，小于7的数组则直接使用插入排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="comment">// 当数组长度大于40时九数取中</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort2(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort2(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[a] &lt; arr[b]</span><br><span class="line">            ? (arr[b] &lt; arr[c] ? b : arr[a] &lt; arr[c] ? c : a)</span><br><span class="line">            : (arr[b] &gt; arr[c] ? b : arr[a] &gt; arr[c] ? c : a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-3"><a href="#优化-3" class="headerlink" title="优化 3"></a>优化 3</h2><p>目前的算法只使用了一个索引i，i从左向右扫描，遇到比pivot小的，就从pos+1开始的位置进行交换，最终划分点在pos，在递归左右两序列</p>
<p>更高效的过程是使用i，j两个索引，分别从左右进行扫描，i扫描到大于等于pivot的元素就停止，j扫描到小于等于pivot的元素也停止，交换着两个元素，持续这个过程直至两个索引相遇，这时pivot的位置就落在了j，交换pivot和j的位置，后续的工作和之前一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left + <span class="number">1</span>;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, l++, r--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值交换的合适的位置</span></span><br><span class="line">    swap(arr,left, r);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-4"><a href="#优化-4" class="headerlink" title="优化 4"></a>优化 4</h2><p>减少不必要的交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort4</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; l &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[l++] = arr[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[r--] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时 i==j，将 pivot 填到这个坑中</span></span><br><span class="line">    arr[l] = pivot;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort3(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort3(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-5"><a href="#优化-5" class="headerlink" title="优化 5"></a>优化 5</h2><p>当大量数据，且重复数多时，用三路快排</p>
<p>把数组分为三路，第一路都比pivot小，第二路都等于pivot，第三路都大于pivot</p>
<p>用指针从前到后扫描，如果：</p>
<ol>
<li>cur指向的数小于pivot，那么：交换arr[cur]和arr[i]的值，然后i++,cur++</li>
<li>cur指向的数等于pivot,  那么：cur++</li>
<li>cur指向的数大于pivot，那么：交换arr[cur]和arr[j]的值，然后j–</li>
</ol>
<p>当cur &gt; j的时候说明三路都已经完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort5</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> cur = left+<span class="number">1</span>;</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; pivot)&#123;</span><br><span class="line">            swap(arr,cur++,l++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; pivot)&#123;</span><br><span class="line">            swap(arr, cur, r--);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, r + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(4)：希尔排序</title>
    <url>/2020/02/22/53145/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>希尔排序是第一个突破 $O(n^2)$ 的算法，它是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>希尔排序在排序前根据一个增量值将一个序列分成了好几个序列</li>
<li>对这几个序列做插入排序。排序后，部分较大的数字往后靠，部分较小的数字往前靠</li>
<li>减小增量值从而减少序列的数量，继续对这些序列做插入排序</li>
<li>当序列只剩一个时，这时即可得到排好序的结果</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/53145/shell.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length / <span class="number">2</span>; step &gt; <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curIndex = i;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (curIndex - step &gt;= <span class="number">0</span> &amp;&amp; arr[curIndex - step] &gt; current) &#123;</span><br><span class="line">                arr[curIndex] = arr[curIndex - step];</span><br><span class="line">                curIndex -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[curIndex] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(3)：插入排序</title>
    <url>/2020/02/21/1609/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>插入排序是一种简单直观的排序算法。它通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/1609/insertion.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>插入排序在实现上，通常采用in-place排序（即只需用到 $O(1)$ 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(2)：选择排序</title>
    <url>/2020/02/21/39445/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>选择排序是一种简单直观的排序算法。它的工作原理是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从第i个(i=1,2,3…n-1)元素开始，从 i~n 的元素中，选出最小的数，将它与第i个元素交换</li>
<li>重复步骤1，直到排序完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/39445/selection.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>选择排序是表现最稳定的排序算法之一，因为无论什么数据进去都是 $O(n^2)$ 的时间复杂度，所以用到它的时候，数据规模越小越好</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(1)：冒泡排序</title>
    <url>/2020/02/21/61456/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，依次比较两个元素，如果发现逆序则交换，使得值较大的元素逐渐从前移向后部，就像水底的气泡逐渐向上冒</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>重复步骤1~3，直到排序完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/61456/bubble.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>在第二层循环中设置一个flag判断元素是否交换过，如果一趟比较下来没有元素交换，就说明排序已完成，没有必要继续下面的比较</li>
<li>在每次扫描中，记录最后一次发生交换的位置pos，此时[0, pos-1]是无序区，[pos, n-1]是有序区，这样下一次扫描只需要扫描到pos就行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                pos = j；</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        k = pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <url>/2020/02/20/10417/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><strong>中缀表达式</strong>：我们平时写的数学表达式一般为中缀表达式，如 <code>1+2*(3*(4-5*6+7))</code>。中缀表达式的特点是：二元运算符总是在两个运算对象之间。人读起来比较好理解，但是计算机处理起来就很麻烦，运算顺序往往因表达式的内容而定，不具规律性</li>
<li><strong>后缀表达式</strong>：又称为<strong>逆波兰表达式</strong>。后缀表达式的特点是：每个运算符都置于其运算对象之后。如上面的中缀表达式转化为后缀表达式为 <code>523312*-1+**+</code></li>
</ul>
<h2 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h2><ol>
<li>初始化一个栈来存放运算符</li>
<li>从左至右依次读取中缀表达式的字符</li>
<li>当读取到数字时，立即放到输出中</li>
<li>当遇到运算符时，比较其与栈顶运算符的优先级<ol>
<li>如果栈为空或栈顶运算符为 ( ，则直接将此运算符入栈</li>
<li>比栈顶高，也将运算符入栈</li>
<li>比栈顶低或相同，将栈顶运算符弹出并输出，再与新的栈顶运算符比较</li>
</ol>
</li>
<li>当遇到括号<ol>
<li>左括号，运算符入栈</li>
<li>右括号，依次弹出栈顶运算符并输出，直到遇到左括号为止，此时舍弃这对括号</li>
</ol>
</li>
<li>重复至表达式最右边，然后将栈中运算符输出</li>
</ol>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>输入 <code>1+2*(3*(4-5*6+7))</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>栈</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>读取 1</td>
<td>把操作数直接输出</td>
<td></td>
<td><code>1</code></td>
</tr>
<tr>
<td>读取 +</td>
<td>栈为空，把运算符压入栈</td>
<td><code>+</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td>读取 2</td>
<td>把操作数直接输出</td>
<td><code>+</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 +，优先级低于 *，把运算符压入栈</td>
<td><code>+*</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 (</td>
<td>把 ( 直接压入栈</td>
<td><code>+*(</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 3</td>
<td>把操作数直接输出</td>
<td><code>+*(</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 (，把运算符压入栈</td>
<td><code>+*(*</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 (</td>
<td>把 ( 直接压入栈</td>
<td><code>+*(*(</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 4</td>
<td>把操作数直接输出</td>
<td><code>+*(*(</code></td>
<td><code>1234</code></td>
</tr>
<tr>
<td>读取 -</td>
<td>栈顶为 (，把运算符压入栈</td>
<td><code>+*(*(-</code></td>
<td><code>1234</code></td>
</tr>
<tr>
<td>读取 5</td>
<td>把操作数直接输出</td>
<td><code>+*(*(-</code></td>
<td><code>12345</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 -，优先级低于 *，把运算符压入栈</td>
<td><code>+*(*(-*</code></td>
<td><code>12345</code></td>
</tr>
<tr>
<td>读取 6</td>
<td>把操作数直接输出</td>
<td><code>+*(*(-*</code></td>
<td><code>123456</code></td>
</tr>
<tr>
<td>读取 +</td>
<td>栈顶为 *，优先级高于 +，依次弹出栈中运算符 到输出，到 ( 停止，把运算符压入栈中</td>
<td><code>+*(*(+</code></td>
<td><code>123456*-</code></td>
</tr>
<tr>
<td>读取 7</td>
<td>把操作数直接输出</td>
<td><code>+*(*(+</code></td>
<td><code>123456*-7</code></td>
</tr>
<tr>
<td>读取 )</td>
<td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td>
<td><code>+*(*</code></td>
<td><code>123456*-7+</code></td>
</tr>
<tr>
<td>读取 )</td>
<td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td>
<td><code>+*</code></td>
<td><code>123456*-7+*</code></td>
</tr>
<tr>
<td>结束读取</td>
<td>把栈中的元素全部弹出到输出</td>
<td></td>
<td><code>123456*-7+**+</code></td>
</tr>
</tbody></table>
<p>输出后缀表达式为：<code>123456*-7+**+</code></p>
<h2 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h2><ol>
<li>按次序读取表达式的每一个字符</li>
<li>读到操作数时，把操作数压入栈</li>
<li>读到操作符时，弹出栈顶的两个数做相应运算，把结果压入栈</li>
<li>读取完所有表达式的字符后，弹出栈，结果即为所求的值</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huben.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> koishi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndixToSuffix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入表达式:"</span>);</span><br><span class="line">        String str = in.next();</span><br><span class="line">        System.out.println(<span class="string">"你输入的表达式为: "</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"转化为后缀表达式为："</span> + transfer(str));</span><br><span class="line">        System.out.println(<span class="string">"计算结果为:"</span> + calculate(transfer(str)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把中缀表达式转换为后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 中缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后缀表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transfer</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; (stack.peek() == <span class="string">'*'</span> || stack.peek() == <span class="string">'/'</span>)) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Float&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                stack.push((<span class="keyword">float</span>) (c - <span class="string">'0'</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(cal(c, stack.pop(), stack.pop()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Float <span class="title">cal</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b + a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b * a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b / a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果截图</p>
<img src="/2020/02/20/10417/result.png" class="">
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
