<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>八大基本排序(5)：快速排序</title>
    <url>/2020/02/22/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-5-%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从数列中挑出一个元素，称为 “基准”</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作；</li>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-5-%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/quick.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组元素等于1 返回</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 选择左端点为基准</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">        <span class="keyword">int</span> pos = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">            <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                swap(arr, pos, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">        swap(arr, left, pos);</span><br><span class="line">        <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">        quickSort(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">    	arr[a] = arr[b];</span><br><span class="line">    	arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速排序最佳情况下时间复杂度为 $O(n\log_2n)$，最坏情况下为 $O(n^2)$，平均复杂度接近最佳情况 $O(n\log_2n)$</p>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化 1"></a>优化 1</h2><p>快排是不断减小问题规模来解决子问题的，需要不断递归。但是递归到规模足够小时，如果继续采用这种 不稳定+递归 的方式执行下去，效率不见得会很好</p>
<p>插入排序的时间复杂度是 $O(n^2)$，但是在已经排序好的数组上面，插入排序的最佳情况是 $O(n)$，插入排序在小数组的排序上是非常高效的，所以在快速排序递归的子序列，如果序列规模足够小，可以使用插入排序替代快速排序，因此可以在快排之前判断数组大小，如果小于一个阀值就使用插入排序</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort1(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort1(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-2"><a href="#优化-2" class="headerlink" title="优化 2"></a>优化 2</h2><p>在数组几乎有序时，快排性能不好，因为每趟排序后，左右两个子递归规模相差悬殊，大的那部分时间复杂度最后很可能会达到 $O(n^2)$</p>
<p>解决方法：<strong>三数取中（median-of-three）法</strong>。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中间数位于较为中间的值的可能性就大大提高了。由于整个序列是无序状态，随机选取三个数和从左中右端取三个数其实是一回事，而且随机数生成器本身还会带来时间上的开销，因此随机生成不予考虑。</p>
<p>三数取中法对小数组来说有很大的概率选择到一个比较好的pivot，但是对于大数组来说就不足以保证能够选择出一个好的pivot，因此还有个办法是所谓median-of-nine，这个怎么做呢？它是先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为pivot，也就是median-of-three。取样也不是乱来，分别是在左端点、中点和右端点取样。什么时候采用median-of-nine去选择pivot，这里也有个数组大小的阀值，这个值完全是经验值，设定在40，大小大于40的数组使用median-of-nine选择pivot，大小在7到40之间的数组使用median-of-three选择中数，大小等于7的数组直接选择中数，小于7的数组则直接使用插入排序</p>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="comment">// 当数组长度大于40时九数取中</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort2(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort2(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[a] &lt; arr[b]</span><br><span class="line">            ? (arr[b] &lt; arr[c] ? b : arr[a] &lt; arr[c] ? c : a)</span><br><span class="line">            : (arr[b] &gt; arr[c] ? b : arr[a] &gt; arr[c] ? c : a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-3"><a href="#优化-3" class="headerlink" title="优化 3"></a>优化 3</h2><p>目前的算法只使用了一个索引i，i从左向右扫描，遇到比pivot小的，就从pos+1开始的位置进行交换，最终划分点在pos，在递归左右两序列。</p>
<p>更高效的过程是使用i，j两个索引，分别从左右进行扫描，i扫描到大于等于pivot的元素就停止，j扫描到小于等于pivot的元素也停止，交换着两个元素，持续这个过程直至两个索引相遇，这时pivot的位置就落在了j，交换pivot和j的位置，后续的工作和之前一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left + <span class="number">1</span>;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, l++, r--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值交换的合适的位置</span></span><br><span class="line">    swap(arr,left, r);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-4"><a href="#优化-4" class="headerlink" title="优化 4"></a>优化 4</h2><p>减少不必要的交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort4</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; l &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[l++] = arr[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[r--] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时 i==j，将 pivot 填到这个坑中</span></span><br><span class="line">    arr[l] = pivot;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort3(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort3(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-5"><a href="#优化-5" class="headerlink" title="优化 5"></a>优化 5</h2><p>当大量数据，且重复数多时，用三路快排</p>
<p>把数组分为三路，第一路都比pivot小，第二路都等于pivot，第三路都大于pivot</p>
<p>用指针从前到后扫描，如果：</p>
<ol>
<li>cur指向的数小于pivot，那么：交换arr[cur]和arr[i]的值，然后i++,cur++</li>
<li>cur指向的数等于pivot,  那么：cur++</li>
<li>cur指向的数大于pivot，那么：交换arr[cur]和arr[j]的值，然后j–</li>
</ol>
<p>当cur &gt; j的时候说明三路都已经完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort5</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> cur = left+<span class="number">1</span>;</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; pivot)&#123;</span><br><span class="line">            swap(arr,cur++,l++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; pivot)&#123;</span><br><span class="line">            swap(arr, cur, r--);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, r + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>八大基本排序(4)：希尔排序</title>
    <url>/2020/02/22/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-4-%EF%BC%9A%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>希尔排序是第一个突破 $O(n^2)$ 的算法，它是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>希尔排序在排序前根据一个增量值将一个序列分成了好几个序列</li>
<li>对这几个序列做插入排序。排序后，部分较大的数字往后靠，部分较小的数字往前靠</li>
<li>减小增量值从而减少序列的数量，继续对这些序列做插入排序</li>
<li>当序列只剩一个时，这时即可得到排好序的结果</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-4-%EF%BC%9A%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/shell.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length / <span class="number">2</span>; step &gt; <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curIndex = i;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (curIndex - step &gt;= <span class="number">0</span> &amp;&amp; arr[curIndex - step] &gt; current) &#123;</span><br><span class="line">                arr[curIndex] = arr[curIndex - step];</span><br><span class="line">                curIndex -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[curIndex] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Gihub Pages和hexo搭建个人博客</title>
    <url>/2020/02/22/%E4%BD%BF%E7%94%A8Gihub-Pages%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><strong>Github Pages</strong> 可以被认为是用户编写的、托管在github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p>
<p><strong>Hexo</strong> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h2 id="一、Github创建个人仓库"><a href="#一、Github创建个人仓库" class="headerlink" title="一、Github创建个人仓库"></a>一、Github创建个人仓库</h2><p>登录到 <a href="httpw://www.github.com">Github</a> ，如果没有账号先去注册一个。点击个人页面中的 New repository 创建新仓库</p>
<p>仓库的名字必须为：自己注册的用户名 + .github.io</p>
<p>例如</p>
<blockquote>
<p>我的用户名为：huben2koishi</p>
<p>那么仓库名字就是：huben2koishi.github.io</p>
</blockquote>
<p>至此，你就已经相当于给自己的博客利用 github 的服务器搭了一个后台。很简单对不对~~</p>
<p>注意几点：</p>
<ol>
<li>注册的邮箱一定要验证，否则不会成功</li>
<li>仓库名字必须是：username.github.io，其中username是你的用户名</li>
<li>仓库创建成功不一定会立即生效，可能需要过一段时间</li>
</ol>
<h2 id="二、安装Git"><a href="#二、安装Git" class="headerlink" title="二、安装Git"></a>二、安装Git</h2><p>提交代码到Github上必须用到Git。前往 <a href="https://git-scm.com/download" target="_blank" rel="noopener">官网</a> 下载，默认安装就行</p>
<p>安装完成后，在cmd命令行输入 <code>git -v</code> 看看版本测试安装是否成功</p>
<h2 id="三、绑定本地-Git-和-Github-账号"><a href="#三、绑定本地-Git-和-Github-账号" class="headerlink" title="三、绑定本地 Git 和 Github 账号"></a>三、绑定本地 Git 和 Github 账号</h2><ol>
<li><p>配置 Git 信息：</p>
<p>打开cmd窗口</p>
<blockquote>
<p>git config –global user.name “你的github用户名”</p>
<p>git config –global user.email “你的github注册邮箱”</p>
</blockquote>
</li>
<li><p>生成 ssh 密钥文件</p>
<p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题</p>
<blockquote>
<p>cd .ssh </p>
</blockquote>
<p>如果提示：The system cannot find the path specified. 说明你是第一次使用</p>
<p>生成密钥</p>
<blockquote>
<p>ssh-keygen -t rsa</p>
</blockquote>
<p>然后连续3次回车，最终会生成一个文件夹 .ssh 在用户目录下，打开 .ssh 文件夹，复制 id_rsa.pub 文件的内容</p>
<p>打开 Github 主页，进入个人设置 &gt;&gt; SSH and GPG keys &gt;&gt; New SSH key，title为标题，任填即可，将复制的内容粘贴进 key，最后点击 Add SSH key</p>
</li>
<li><p>测试是否成功添加公钥</p>
<p>在 Git Bash 中检测 GitHub 公钥设置是否成功，输入 <code>ssh git@github.com</code></p>
<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p>
<blockquote>
<p>Hi xxxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
</li>
</ol>
<p>如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>由于 Hexo 基于 Node.js 因此我们到 <a href="https://nodejs.org/zh-cn/download" target="_blank" rel="noopener">官网</a> 上下载一下 Node.js。</p>
<p>下载安装包，默认安装后，在命令行中输入 <code>node -v</code> 检测是否安装成功。</p>
<p>Node.js 会默认帮我们安装npm，这是个包管理工具，下面的Hexo安装就要用到npm。由于npm使用的包源是国外的，所以国内访问可能非常慢，这里我们把npm的源替换为国内的</p>
<blockquote>
<p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</blockquote>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>Hexo 是我们的博客框架，这里需要在电脑内创建一个文件夹，可以随意命名</p>
<p>进入文件夹，打开cmd 窗口，安装 Hexo</p>
<blockquote>
<p>npm i -g hexo-cli</p>
</blockquote>
<p>安装完成后，初始化博客</p>
<blockquote>
<p>hexo init</p>
</blockquote>
<h2 id="把博客部署到-Github"><a href="#把博客部署到-Github" class="headerlink" title="把博客部署到 Github"></a>把博客部署到 Github</h2><p>打开博客的配置文件 _config.yml，翻到最后修改为</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">这里填你之前Github上创建的仓库的路径</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>然后安装Git部署插件</p>
<blockquote>
<p>npm i hexo-deployer-git</p>
</blockquote>
<p>最后，分别输入</p>
<blockquote>
<p>hexo g</p>
<p>hexo d</p>
</blockquote>
<p>你就会发现你的博客已经上线了，在浏览器输入 <code>你的用户名.github.io</code> 就可以访问了。</p>
]]></content>
  </entry>
  <entry>
    <title>八大基本排序(3)：插入排序</title>
    <url>/2020/02/21/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-3-%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>插入排序是一种简单直观的排序算法。它通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-3-%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/insertion.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>八大基本排序(2)：选择排序</title>
    <url>/2020/02/21/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-2-%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>选择排序是一种简单直观的排序算法。它的工作原理是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从第i个(i=1,2,3…n-1)元素开始，从 i~n 的元素中，选出最小的数，将它与第i个元素交换</li>
<li>重复步骤1，直到排序完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-2-%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/selection.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>选择排序是表现最稳定的排序算法之一，因为无论什么数据进去都是 $O(n^2)$ 的时间复杂度，所以用到它的时候，数据规模越小越好</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>八大基本排序(1)：冒泡排序</title>
    <url>/2020/02/21/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-1-%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，依次比较两个元素，如果发现逆序则交换，使得值较大的元素逐渐从前移向后部，就像水底的气泡逐渐向上冒</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>重复步骤1~3，直到排序完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/%E5%85%AB%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F-1-%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/bubble.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>在第二层循环中设置一个flag判断元素是否交换过，如果一趟比较下来没有元素交换，就说明排序已完成，没有必要继续下面的比较</li>
<li>在每次扫描中，记录最后一次发生交换的位置pos，此时[0, pos-1]是无序区，[pos, n-1]是有序区，这样下一次扫描只需要扫描到pos就行</li>
</ol>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                pos = j；</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        k = pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <url>/2020/02/20/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><strong>中缀表达式</strong>：我们平时写的数学表达式一般为中缀表达式，如 <code>1+2*(3*(4-5*6+7))</code>，中缀表达式的特点是：二元运算符总是在两个运算对象之间。人读起来比较好理解，但是计算机处理起来就很麻烦，运算顺序往往因表达式的内容而定，不具规律性</li>
<li><strong>后缀表达式</strong>：又称为<strong>逆波兰表达式</strong>。后缀表达式的特点是：每个运算符都置于其运算对象之后。如上面的中缀表达式转化为后缀表达式为 <code>523312*-1+**+</code>。</li>
</ul>
<h2 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h2><ol>
<li>初始化一个栈来存放运算符</li>
<li>从左至右依次读取中缀表达式的字符</li>
<li>当读取到数字时，立即放到输出中</li>
<li>当遇到运算符时，比较其与栈顶运算符的优先级<ol>
<li>如果栈为空或栈顶运算符为 ( ，则直接将此运算符入栈</li>
<li>比栈顶高，也将运算符入栈</li>
<li>比栈顶低或相同，将栈顶运算符弹出并输出，再与新的栈顶运算符比较</li>
</ol>
</li>
<li>当遇到括号<ol>
<li>左括号，运算符入栈</li>
<li>右括号，依次弹出栈顶运算符并输出，直到遇到左括号为止，此时舍弃这对括号</li>
</ol>
</li>
<li>重复至表达式最右边，然后将栈中运算符输出</li>
</ol>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>输入 <code>1+2*(3*(4-5*6+7))</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>栈</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>读取 1</td>
<td>把操作数直接输出</td>
<td></td>
<td><code>1</code></td>
</tr>
<tr>
<td>读取 +</td>
<td>栈为空，把运算符压入栈</td>
<td><code>+</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td>读取 2</td>
<td>把操作数直接输出</td>
<td><code>+</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 +，优先级低于 *，把运算符压入栈</td>
<td><code>+*</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 (</td>
<td>把 ( 直接压入栈</td>
<td><code>+*(</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 3</td>
<td>把操作数直接输出</td>
<td><code>+*(</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 (，把运算符压入栈</td>
<td><code>+*(*</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 (</td>
<td>把 ( 直接压入栈</td>
<td><code>+*(*(</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 4</td>
<td>把操作数直接输出</td>
<td><code>+*(*(</code></td>
<td><code>1234</code></td>
</tr>
<tr>
<td>读取 -</td>
<td>栈顶为 (，把运算符压入栈</td>
<td><code>+*(*(-</code></td>
<td><code>1234</code></td>
</tr>
<tr>
<td>读取 5</td>
<td>把操作数直接输出</td>
<td><code>+*(*(-</code></td>
<td><code>12345</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 -，优先级低于 *，把运算符压入栈</td>
<td><code>+*(*(-*</code></td>
<td><code>12345</code></td>
</tr>
<tr>
<td>读取 6</td>
<td>把操作数直接输出</td>
<td><code>+*(*(-*</code></td>
<td><code>123456</code></td>
</tr>
<tr>
<td>读取 +</td>
<td>栈顶为 *，优先级高于 +，依次弹出栈中运算符 到输出，到 ( 停止，把运算符压入栈中</td>
<td><code>+*(*(+</code></td>
<td><code>123456*-</code></td>
</tr>
<tr>
<td>读取 7</td>
<td>把操作数直接输出</td>
<td><code>+*(*(+</code></td>
<td><code>123456*-7</code></td>
</tr>
<tr>
<td>读取 )</td>
<td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td>
<td><code>+*(*</code></td>
<td><code>123456*-7+</code></td>
</tr>
<tr>
<td>读取 )</td>
<td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td>
<td><code>+*</code></td>
<td><code>123456*-7+*</code></td>
</tr>
<tr>
<td>结束读取</td>
<td>把栈中的元素全部弹出到输出</td>
<td></td>
<td><code>123456*-7+**+</code></td>
</tr>
</tbody></table>
<p>输出后缀表达式为：<code>123456*-7+**+</code></p>
<h2 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h2><ol>
<li>按次序读取表达式的每一个字符</li>
<li>读到操作数时，把操作数压入栈</li>
<li>读到操作符时，弹出栈顶的两个数做相应运算，把结果压入栈</li>
<li>读取完所有表达式的字符后，弹出栈，结果即为所求的值</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huben.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> koishi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndixToSuffix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入表达式:"</span>);</span><br><span class="line">        String str = in.next();</span><br><span class="line">        System.out.println(<span class="string">"你输入的表达式为: "</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"转化为后缀表达式为："</span> + transfer(str));</span><br><span class="line">        System.out.println(<span class="string">"计算结果为:"</span> + calculate(transfer(str)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把中缀表达式转换为后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 中缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后缀表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transfer</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; (stack.peek() == <span class="string">'*'</span> || stack.peek() == <span class="string">'/'</span>)) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Float&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                stack.push((<span class="keyword">float</span>) (c - <span class="string">'0'</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(cal(c, stack.pop(), stack.pop()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Float <span class="title">cal</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b + a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b * a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b / a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果截图</p>
<img src="/2020/02/20/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/result.png" class="">

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
