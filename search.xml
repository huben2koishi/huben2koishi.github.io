<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法：斐波那契数列</title>
    <url>/2020/03/04/25921/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>斐波那契数列是这样一个数列，它满足：$f(n)=\begin{cases}0&amp;\text{n=0}\\1&amp;\text{n=1}\\f(n-1)+f(n-2)&amp;\text{n&gt;=2}\end{cases}$</p>
<h2 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h2><p>实现很简单，当n=0返回0，n=1返回1，当n&gt;=2时使用递归返回前两项之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> n &lt; <span class="number">2</span> ? n : fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码很简单，只用1行就实现了斐波那契的算法，但这种单纯的递归实现会有很严重的性能问题。我用自己电脑计算 fib(50) 时就花了大概45秒，fib(60) 就算不出来了，一直卡着</p>
<p>之所以出现这种情况，是因为在递归的过程中存在大量重复的计算，如下图所示：</p>
<img src="/2020/03/04/25921/fibonacci1.jpg" class="">

<p>可见，仅仅是对 fib(10) 的计算，而且仅画出了4层，就出现了大量的重复。随着 n 的递增，为求出结果，重复的计算会急剧增加，这种方法的时间复杂度是 $O(n^2)​$</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>使用尾递归，把每次计算的结果保持下来，计算结果参与下一次的计算，从而减少计算量。原本递归产生的栈的层次下网二叉树一样以指数级增长，现在栈的层次像数组，变成线性增长了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">long</span> first, <span class="keyword">long</span> second, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first + second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(second, first + second, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h2><p>不使用递归，而是使用迭代的方式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n1 = <span class="number">0</span>, n2 = <span class="number">1</span>, n3 = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        n3 = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现3"><a href="#实现3" class="headerlink" title="实现3"></a>实现3</h2><p>实际上斐波那契数列数列是有非递推式的通项公式的: $f(n)=\frac{1}{\sqrt5}(\frac{1+\sqrt5}{2})^n-\frac{1}{\sqrt5}(\frac{1-\sqrt5}{2})^n$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>) (Math.pow((<span class="number">1</span> + Math.sqrt(<span class="number">5</span>)) / <span class="number">2</span>, n) / Math.sqrt(<span class="number">5</span>) </span><br><span class="line">                   - Math.pow((<span class="number">1</span> - Math.sqrt(<span class="number">5</span>)) / <span class="number">2</span>, n) / Math.sqrt(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通项公式中要求某个数的 n 次幂，所以空间复杂度为 $O(\log_2n)$</p>
<h2 id="实现4"><a href="#实现4" class="headerlink" title="实现4"></a>实现4</h2><p>使用矩阵快速幂方式实现</p>
<p>斐波那契数列的通项公式为 $f(n)=\begin{cases}0&amp;\text{n=0}\\1&amp;\text{n=1}\\f(n-1)+f(n-2)&amp;\text{n&gt;=2}\end{cases}$</p>
<p>根据通项公式可写成以下形式：</p>
<p>$f(n+1)=1*f(n)+1*f(n-1)$</p>
<p>$f(n)=1*f(n-1)+1*f(n-2)$</p>
<p>$f(n)=1*f(n)+0*f(n-1)$</p>
<p>$f(n-1)=1*f(n-1)+0*f(n-2)​$</p>
<p>用矩阵表示为：</p>
<p>$$\begin{bmatrix}f(n+1)&amp;f(n)\\f(n)&amp;f(n-1)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}*\begin{bmatrix}f(n)&amp;f(n-1)\\f(n-1)&amp;f(n-2)\end{bmatrix}$$</p>
<p>进一步，可得：</p>
<p>$$\begin{bmatrix}f(n+1)&amp;f(n)\\f(n)&amp;f(n-1)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^2*\begin{bmatrix}f(n-1)&amp;f(n-2)\\f(n-2)&amp;f(n-3)\end{bmatrix}$$</p>
<p>$$=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-1}*\begin{bmatrix}f(2)&amp;f(1)\\f(1)&amp;f(0)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^n$$</p>
<p>所以通过求矩阵 $\begin{bmatrix}1&amp;1\\ 1&amp;0\end{bmatrix}​$ 的n次方就可以得到 $f(n)​$ 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>[][] UNIT = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] fib(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// n 为偶数</span></span><br><span class="line">        <span class="keyword">long</span>[][] matrix = fib(n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMultiply(matrix, matrix);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n 为奇数</span></span><br><span class="line">        <span class="keyword">long</span>[][] matrix = fib((n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMultiply(UNIT, matrixMultiply(matrix, matrix));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] matrixMultiply(<span class="keyword">long</span>[][] a, <span class="keyword">long</span>[][] b) &#123;</span><br><span class="line">    <span class="keyword">int</span> row = a.length, col = b[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">long</span>[][] result = <span class="keyword">new</span> <span class="keyword">long</span>[row][col];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a[i].length; k++) &#123;</span><br><span class="line">                result[i][j] += a[i][k] * b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现5"><a href="#实现5" class="headerlink" title="实现5"></a>实现5</h2><p>在GMP(GNU多重精度算术库)中，它并没有使用矩阵快速幂的方法，而是使用递推式，不过它使用的递推式更加复杂：</p>
<p>$$f(2k+1)=4*f(k)^2-f(k-1)^2+2*(-1)^k$$</p>
<p>$$f(2k-1)=f(k)^2+f(k-1)^2$$</p>
<p>$$f(2k)=f(2k+1)-f(2k-1)$$</p>
<p>这个算法首先把n转化成二进制形式，然后从最高位开始向低位遍历，设m的二进制前i位(0到i-1位)表示的值为 $k_i​$，那么 $f(k_i)​$ 和 $f(k_i-1)​$ 都是已知的</p>
<ul>
<li>如果第i位为1，那么就用已知的 $f(k_i)$ 和 $f(k_i-1)$ 计算 $f(2k_i+1)$ 和 $f(2k_i)$，得到 $f(k_{i+1})$ 和 $f(k_{i+1}-1)​$</li>
<li>如果第i位为0，那么就用已知的 $f(k_i)​$ 和 $f(k_i-1)​$ 计算 $f(2k_i)​$ 和 $f(2k_i-1)​$，得到 $f(k_{i+1})​$ 和 $f(k_{i+1}-1)​$</li>
</ul>
<p>可以看到迭代的次数跟n的二进制长度一致，所以其时间复杂度也是 $O(\log_2n)$</p>
<p>需要注意的是，上述递推式中的 $f(k)^2$ 和 $f(k-1)^2$ 是可以复用的，实际上每一次迭代只需要进行两次大整数乘法运算</p>
<p>举个栗子：求 $f(25)$，已知 $f(-1)=1$，$f(0)=0$</p>
<p>首先把25转化为二进制形式11001，从最高位开始，它是1，那么此时 k=0</p>
<p>$$f(1)=4*f(0)^2=f(-1)^2+2=1$$</p>
<p>$$f(-1)=1$$</p>
<p>$$f(0)=0$$</p>
<p>然后第2位，同样为1，此时 k=1</p>
<p>$$f(3)=4*f(1)^2-f(0)^2-2=2$$</p>
<p>$$f(1)=1$$</p>
<p>$$f(2)=f(3)-f(1)=1$$</p>
<p>第3位为0，此时 k=3</p>
<p>$$f(7)=4*f(3)^2-f(2)^2-2=13$$</p>
<p>$$f(5)=f(3)^2+f(2)^2=5$$</p>
<p>$$f(6)=f(7)-f(5)=8$$</p>
<p>第4位为0，此时 k=6</p>
<p>$$f(13)=4*f(6)^2-f(5)^2+2=13$$</p>
<p>$$f(11)=f(6)^2+f(5)^2=98$$</p>
<p>$$f(12)=f(13)-f(11)=144$$</p>
<p>第5位为1，此时 k=12，得到最终结果</p>
<p>$$f(25)=4*f(12)^2-f(11)^2+2=75025$$</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法总结</title>
    <url>/2020/03/04/45778/</url>
    <content><![CDATA[<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(n^{1.3})$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(1)$</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p><a href="/2020/02/21/61456/">冒泡排序</a></p>
<p>（无序区，有序区）从无序区通过交换找出最大元素放到有序区前端</p>
</li>
<li><p><a href="/2020/02/21/39445/">选择排序</a></p>
<p>（有序区，无序区）在无序区中找出一个最小的元素跟在有序区后面</p>
</li>
<li><p><a href="/2020/02/21/1609/">插入排序</a></p>
<p>（有序区，无序区）把无序区的第一个元素插入到有序区的合适位置</p>
</li>
<li><p><a href="/2020/02/22/53145/">希尔排序</a></p>
<p>每一轮按照事先决定的间隔进行插入排序，间隔会逐渐缩小至1</p>
</li>
<li><p><a href="/2020/02/22/20366/">快速排序</a></p>
<p>（小数，基准值，大数）在区间中选择一个元素作为基准，把小于基准的元素放在基准之前，大于基准的元素放在基准之后，在分别对小数区和大数区进行排序</p>
</li>
<li><p><a href="/2020/02/24/27532/">归并排序</a></p>
<p>把数据分为两段，从两段中组个选最小的元素移入新数据段的末尾</p>
</li>
<li><p><a href="/2020/03/03/14948/">堆排序</a></p>
<p>（最大堆，有序区）从堆顶把根节点取出来放在有序区之前，再恢复堆</p>
</li>
<li><p><a href="/2020/03/03/4826/">计数排序</a></p>
<p>统计小于等于该元素值的个数 i，该元素就放在目标数组的索引 i 位</p>
</li>
<li><p><a href="/2020/03/03/52110/">桶排序</a></p>
<p>遍历数组把各元素放入对于的桶中，再对桶中个元素进行排序</p>
</li>
<li><p><a href="/2020/03/04/53833/">基数排序</a></p>
<p>低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(10)：基数排序</title>
    <url>/2020/03/04/53833/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>取得数组中的最大数，并取得位数</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/04/53833/radix.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化10个桶</span></span><br><span class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次循环 n*10，当 max/n小于0 时说明已经遍历到了最高位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; max / n &gt; <span class="number">0</span>; n *= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            buckets[(arr[i] / n) % <span class="number">10</span>][i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buckets[j][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    arr[index++] = buckets[j][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(9)：桶排序</title>
    <url>/2020/03/03/52110/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>设定一个定量的数组当作空桶</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶中</li>
<li>对每个不是空的桶进行排序</li>
<li>从不是空的桶里把排好序的数据拼接起来</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/03/52110/bucket.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出数组最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = (value - min) / arr.length;</span><br><span class="line">        bucketArr.get(num).add(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; integers : bucketArr) &#123;</span><br><span class="line">        Collections.sort(integers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把桶中元素取回原数组</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; integers : bucketArr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            arr[index++]=integer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(8)：计数排序</title>
    <url>/2020/03/03/4826/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去1。</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/03/4826/counting.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组中最大的值</span></span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 遍历数组arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        count[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, index = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>若原数组值的范围不是从0开始的，计数数组的前面部分空间就会浪费。可以再定义一个变量 min，在给count数组某个下标赋值时把下标减去min</li>
<li>上面的实现中算法是不稳定的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出数组最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数数组，记录每个数组出现的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        count[value - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数每个数字在排序后数组中应该处于的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp = arr.clone();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        arr[--count[temp[i] - min]] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>计数排序是非比较排序，它适用于特定问题，也就是对源数据有要求</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(7)：堆排序</title>
    <url>/2020/03/03/14948/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>堆排序是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区</li>
<li>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1,R2,……Rn-1) 和新的有序区 (Rn)，且满足R[1,2…n-1]&lt;=R[n]</li>
<li>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1,R2,……Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区 (Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/03/14948/heap.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后节点的父节点开始把原数组构建为堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次把堆顶元素和最后一个元素交换，再把堆顶heapify</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr, i, <span class="number">0</span>);</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] tree, <span class="keyword">int</span> size, <span class="keyword">int</span> curRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点大于size时退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (curRoot &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前节点的左右字节点索引</span></span><br><span class="line">    <span class="keyword">int</span> l = curRoot * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = curRoot * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> max = curRoot;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; size &amp;&amp; tree[l] &gt; tree[max]) &#123;</span><br><span class="line">        max = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; size &amp;&amp; tree[r] &gt; tree[max]) &#123;</span><br><span class="line">        max = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把当前节点、左右子节点中最大的值与当前节点交换</span></span><br><span class="line">    <span class="keyword">if</span> (max != curRoot) &#123;</span><br><span class="line">        swap(tree, max, curRoot);</span><br><span class="line">        heapify(tree, size, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Bilibili弹幕屏蔽正则</title>
    <url>/2020/02/26/65032/</url>
    <content><![CDATA[<p>自用的b站弹幕屏蔽正则，有效屏蔽一些刷屏、玩烂梗、nt的弹幕。</p>
<ol>
<li><p>前排</p>
<p><code>/^\s*[前第]\s*(排|\d+|[二-十]|一$)|关上.+大门/</code></p>
</li>
<li><p>时间</p>
<p><code>/(\d+\D)?\d+\D\d+|年?.+月.+日?|(\d+|[一-十])[十百千万]?(世纪|辈子|年|月|时|小时|分钟|秒)(前|后见)?[^0-9a-zA-Z\u4e00-\u9fa5]*$/</code></p>
</li>
<li><p>+1怪</p>
<p><code>/(\+|加)(\d+|[一-十])[^sS秒]/</code></p>
</li>
<li><p>变色</p>
<p><code>/变.*色|色.*变|(颜|什么.?)色|[戴带].*[冠帽]|[冠帽].*[戴带掉]|帽子|爱.?一.?光|自然.?力量|我.*白色?的?[？?]*$|^(.?[紫基].{2,3}|.?[橘桔].{2,3})$/</code></p>
</li>
<li><p>存活</p>
<p><code>/确\s*认\s*存\s*活|存\s*活\s*确\s*认|^(存活|活着)/</code></p>
</li>
<li><p>完结撒花</p>
<p><code>/[完玩万]\s*[结节結節截美].*[撒散洒杀啥]|[撒散洒杀啥]\s*花[^0-9a-zA-Z\u4e00-\u9fa5]*$|感\s*谢\s*陪\s*伴/</code></p>
</li>
<li><p>虚空对话</p>
<p><code>/([前后上下]面的?|你|[那这]个).*(等|够了|休想|你|我|在下|[跟带加]上)|恶?魔鬼?[吗吧]?[^0-9a-zA-Z\u4e00-\u9fa5]*$/</code></p>
</li>
<li><p>自我意识过剩+饭圈</p>
<p><code>/(我[哒的].?|我.?([男女基]朋?友|老[公婆])|参上|一拜)[^0-9a-zA-Z\u4e00-\u9fa5]*$|是我的|我的[就，\s]|我.*(表示|接受)|归我|承包|[我俺]也?一|先.为敬/</code></p>
</li>
<li><p>nt+烂梗</p>
<ul>
<li><code>/(出现|[上发传转放在到至]).*[在到至]?([bBpP批破比逼哔][iI]?[站占战]|[哔批][里哩]|[bBpP][iI][lL][iI])/</code></li>
<li><code>/(([你女汝][听闻看瞧]|([看听瞧说评])\3|这是).*人|^.?人).*[言话]|[做当作坐座]个人|人.*干.*事/</code></li>
<li><code>/[一亿]人[一亿].|夸父|水娃|我.*喝[一亿]口/</code></li>
<li><code>/典[明眀]粥|[啊阿][帕怕伯泊]基?茶|抽紫烟|神父.*碟|[jJ][iI]?[oO]\s*(等|印|护车)|[bB][oO].*[kK][iI]|上一.+(现在|已经)/</code></li>
<li><code>/[开放停][炮火箭]|[敌友]军|厚葬|秀|意大利[炮跑泡砲面]/</code></li>
<li><code>/[掉上下]线|挂机|回合|重连|续费|登[录陆] |(参与|[介加进]入|[退逃][离出]|离开).{2,4}$|谢.+[刷送]|^.{1,4}([\s\-•·].+)?表示/</code></li>
<li><code>/你币.了/</code></li>
<li><code>/众所周知.*是一/</code></li>
<li><code>/[糟遭曹漕]老头.+坏/</code></li>
<li><code>/馋.*身[子体]|身[子体].*馋/</code></li>
<li><code>/[你宁您].*([看康瞧瞅听学])(\1|着点)/</code></li>
<li><code>/[下上此这].*名单/</code></li>
<li><code>/左.*右.*(大法|手|失)|^(请求)?空降.*[^\d]|[开收停施]工|[oO][pP]|[eE][dD]|正片|(上|前面).*彩蛋/</code></li>
<li><code>/[掉上下]线|挂机|回合|重连|续费|登[录陆]|([一请参作求出助][站战]|参与|[介加进]入|[退逃][离出]|离开|就位).{0,4}$|谢.+[刷送]|^.{1,4}([\s\-•·].+)?表示/</code></li>
<li><code>/[wW].*[dD].*[nN].*[mM].*[dD]|[aA][1iIlLeE]高闪|秋梨膏|我.+了.*什么好说|[rR][uU][sS][hH].*[bB]/</code></li>
<li><code>/(你|君|あなた).*[指手].*[躍跃飛飞舞動动光]/</code></li>
<li><code>/此生.*来世.*/</code></li>
<li><code>/停止.*行为/</code></li>
<li><code>/.*血赚.*不亏/</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(6)：归并排序</title>
    <url>/2020/02/24/27532/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法</strong>的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列</li>
<li>对这两个子序列分别采用归并排序</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/24/27532/merge.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    sort(arr, aux, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sort(arr, aux, left, mid);</span><br><span class="line">    sort(arr, aux, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    merge(arr, aux, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(arr, left, aux, left, right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = left; t &lt;= right; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分的已经全部放到原数组了，将右半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分的已经全部放到原数组了，将左半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt;= aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分取出的元素较小，那么把左半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分取出的元素较小，那么把右半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>和快速排序一样，对于小数组可以使用插入排序或者选择排序，避免递归调用</li>
<li>在merge调用前，可以判断一下<code>arr[mid]</code>是否小于等于<code>arr[mid+1]</code>。如果是的话那么就不用归并了，数组已经是有序的。原因很简单，既然两个子数组已经有序了，那么<code>arr[mid]</code>是第一个子数组的最大值，<code>arr[mid+1]</code>是第二个子数组的最小值。当<code>a[mid]&lt;=a[mid+1]</code>时，数组整体有序</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    sort(arr, aux, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sort(arr, aux, left, mid);</span><br><span class="line">    sort(arr, aux, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 如果左半数组最大的数小于右半数组最小的数，那么说明这两个数组以及有序，不需要合并</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">        merge(arr, aux, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(arr, left, aux, left, right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = left; t &lt;= right; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分的已经全部放到原数组了，将右半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分的已经全部放到原数组了，将左半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt;= aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分取出的元素较小，那么把左半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分取出的元素较小，那么把右半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= left &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h2><p>在上面的实现中，相当于将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。将一个大的数组的排序划分为小数组的排序是自顶向下的排序。还有一种实现是自底向上的排序，即先两两归并，然后四四归并……</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, i, Math.min(i + <span class="number">7</span>, len - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">7</span>; sz &lt; len; sz += sz) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - sz; i += sz + sz) &#123;</span><br><span class="line">            <span class="comment">// 如果左半数组最大的数小于右半数组最小的数，不需要合并</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i + sz - <span class="number">1</span>] &gt; arr[i + sz]) &#123;</span><br><span class="line">                merge(arr, aux, i, i + sz - <span class="number">1</span>, Math.min(i + sz + sz - <span class="number">1</span>, len - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(5)：快速排序</title>
    <url>/2020/02/22/20366/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从数列中挑出一个元素，称为 “基准”</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作；</li>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/20366/quick.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组元素等于1 返回</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 选择左端点为基准</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">        <span class="keyword">int</span> pos = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">            <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                swap(arr, pos, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">        swap(arr, left, pos);</span><br><span class="line">        <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">        quickSort(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">    	arr[a] = arr[b];</span><br><span class="line">    	arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速排序最佳情况下时间复杂度为 $O(n\log_2n)$，最坏情况下为 $O(n^2)$，平均复杂度接近最佳情况 $O(n\log_2n)$</p>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化 1"></a>优化 1</h2><p>快排是不断减小问题规模来解决子问题的，需要不断递归。但是递归到规模足够小时，如果继续采用这种 不稳定+递归 的方式执行下去，效率不见得会很好</p>
<p>插入排序的时间复杂度是 $O(n^2)$，但是在已经排序好的数组上面，插入排序的最佳情况是 $O(n)$，插入排序在小数组的排序上是非常高效的，所以在快速排序递归的子序列，如果序列规模足够小，可以使用插入排序替代快速排序，因此可以在快排之前判断数组大小，如果小于一个阈值就使用插入排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort1(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort1(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= left &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-2"><a href="#优化-2" class="headerlink" title="优化 2"></a>优化 2</h2><p>在数组几乎有序时，快排性能不好，因为每趟排序后，左右两个子递归规模相差悬殊，大的那部分时间复杂度最后很可能会达到 $O(n^2)$</p>
<p>解决方法：<strong>三数取中（median-of-three）法</strong>。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中间数位于较为中间的值的可能性就大大提高了。由于整个序列是无序状态，随机选取三个数和从左中右端取三个数其实是一回事，而且随机数生成器本身还会带来时间上的开销，因此随机生成不予考虑。</p>
<p>三数取中法对小数组来说有很大的概率选择到一个比较好的pivot，但是对于大数组来说就不足以保证能够选择出一个好的pivot，因此还有个办法是所谓median-of-nine，这个怎么做呢？它是先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为pivot，也就是median-of-three。取样也不是乱来，分别是在左端点、中点和右端点取样。什么时候采用median-of-nine去选择pivot，这里也有个数组大小的阀值，这个值完全是经验值，设定在40，大小大于40的数组使用median-of-nine选择pivot，大小在7到40之间的数组使用median-of-three选择中数，大小等于7的数组直接选择中数，小于7的数组则直接使用插入排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="comment">// 当数组长度大于40时九数取中</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort2(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort2(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[a] &lt; arr[b]</span><br><span class="line">            ? (arr[b] &lt; arr[c] ? b : arr[a] &lt; arr[c] ? c : a)</span><br><span class="line">            : (arr[b] &gt; arr[c] ? b : arr[a] &gt; arr[c] ? c : a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-3"><a href="#优化-3" class="headerlink" title="优化 3"></a>优化 3</h2><p>目前的算法只使用了一个索引i，i从左向右扫描，遇到比pivot小的，就从pos+1开始的位置进行交换，最终划分点在pos，在递归左右两序列。</p>
<p>更高效的过程是使用i，j两个索引，分别从左右进行扫描，i扫描到大于等于pivot的元素就停止，j扫描到小于等于pivot的元素也停止，交换着两个元素，持续这个过程直至两个索引相遇，这时pivot的位置就落在了j，交换pivot和j的位置，后续的工作和之前一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left + <span class="number">1</span>;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, l++, r--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值交换的合适的位置</span></span><br><span class="line">    swap(arr,left, r);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-4"><a href="#优化-4" class="headerlink" title="优化 4"></a>优化 4</h2><p>减少不必要的交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort4</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; l &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[l++] = arr[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[r--] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时 i==j，将 pivot 填到这个坑中</span></span><br><span class="line">    arr[l] = pivot;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort3(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort3(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-5"><a href="#优化-5" class="headerlink" title="优化 5"></a>优化 5</h2><p>当大量数据，且重复数多时，用三路快排</p>
<p>把数组分为三路，第一路都比pivot小，第二路都等于pivot，第三路都大于pivot</p>
<p>用指针从前到后扫描，如果：</p>
<ol>
<li>cur指向的数小于pivot，那么：交换arr[cur]和arr[i]的值，然后i++,cur++</li>
<li>cur指向的数等于pivot,  那么：cur++</li>
<li>cur指向的数大于pivot，那么：交换arr[cur]和arr[j]的值，然后j–</li>
</ol>
<p>当cur &gt; j的时候说明三路都已经完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort5</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> cur = left+<span class="number">1</span>;</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; pivot)&#123;</span><br><span class="line">            swap(arr,cur++,l++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; pivot)&#123;</span><br><span class="line">            swap(arr, cur, r--);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, r + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(4)：希尔排序</title>
    <url>/2020/02/22/53145/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>希尔排序是第一个突破 $O(n^2)$ 的算法，它是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>希尔排序在排序前根据一个增量值将一个序列分成了好几个序列</li>
<li>对这几个序列做插入排序。排序后，部分较大的数字往后靠，部分较小的数字往前靠</li>
<li>减小增量值从而减少序列的数量，继续对这些序列做插入排序</li>
<li>当序列只剩一个时，这时即可得到排好序的结果</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/53145/shell.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length / <span class="number">2</span>; step &gt; <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curIndex = i;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (curIndex - step &gt;= <span class="number">0</span> &amp;&amp; arr[curIndex - step] &gt; current) &#123;</span><br><span class="line">                arr[curIndex] = arr[curIndex - step];</span><br><span class="line">                curIndex -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[curIndex] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(3)：插入排序</title>
    <url>/2020/02/21/1609/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>插入排序是一种简单直观的排序算法。它通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/1609/insertion.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>插入排序在实现上，通常采用in-place排序（即只需用到 $O(1)$ 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(2)：选择排序</title>
    <url>/2020/02/21/39445/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>选择排序是一种简单直观的排序算法。它的工作原理是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从第i个(i=1,2,3…n-1)元素开始，从 i~n 的元素中，选出最小的数，将它与第i个元素交换</li>
<li>重复步骤1，直到排序完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/39445/selection.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>选择排序是表现最稳定的排序算法之一，因为无论什么数据进去都是 $O(n^2)$ 的时间复杂度，所以用到它的时候，数据规模越小越好</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(1)：冒泡排序</title>
    <url>/2020/02/21/61456/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，依次比较两个元素，如果发现逆序则交换，使得值较大的元素逐渐从前移向后部，就像水底的气泡逐渐向上冒</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>重复步骤1~3，直到排序完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/61456/bubble.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>在第二层循环中设置一个flag判断元素是否交换过，如果一趟比较下来没有元素交换，就说明排序已完成，没有必要继续下面的比较</li>
<li>在每次扫描中，记录最后一次发生交换的位置pos，此时[0, pos-1]是无序区，[pos, n-1]是有序区，这样下一次扫描只需要扫描到pos就行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                pos = j；</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        k = pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <url>/2020/02/20/28b1/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><strong>中缀表达式</strong>：我们平时写的数学表达式一般为中缀表达式，如 <code>1+2*(3*(4-5*6+7))</code>，中缀表达式的特点是：二元运算符总是在两个运算对象之间。人读起来比较好理解，但是计算机处理起来就很麻烦，运算顺序往往因表达式的内容而定，不具规律性</li>
<li><strong>后缀表达式</strong>：又称为<strong>逆波兰表达式</strong>。后缀表达式的特点是：每个运算符都置于其运算对象之后。如上面的中缀表达式转化为后缀表达式为 <code>523312*-1+**+</code>。</li>
</ul>
<h2 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h2><ol>
<li>初始化一个栈来存放运算符</li>
<li>从左至右依次读取中缀表达式的字符</li>
<li>当读取到数字时，立即放到输出中</li>
<li>当遇到运算符时，比较其与栈顶运算符的优先级<ol>
<li>如果栈为空或栈顶运算符为 ( ，则直接将此运算符入栈</li>
<li>比栈顶高，也将运算符入栈</li>
<li>比栈顶低或相同，将栈顶运算符弹出并输出，再与新的栈顶运算符比较</li>
</ol>
</li>
<li>当遇到括号<ol>
<li>左括号，运算符入栈</li>
<li>右括号，依次弹出栈顶运算符并输出，直到遇到左括号为止，此时舍弃这对括号</li>
</ol>
</li>
<li>重复至表达式最右边，然后将栈中运算符输出</li>
</ol>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>输入 <code>1+2*(3*(4-5*6+7))</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>栈</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>读取 1</td>
<td>把操作数直接输出</td>
<td></td>
<td><code>1</code></td>
</tr>
<tr>
<td>读取 +</td>
<td>栈为空，把运算符压入栈</td>
<td><code>+</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td>读取 2</td>
<td>把操作数直接输出</td>
<td><code>+</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 +，优先级低于 *，把运算符压入栈</td>
<td><code>+*</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 (</td>
<td>把 ( 直接压入栈</td>
<td><code>+*(</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 3</td>
<td>把操作数直接输出</td>
<td><code>+*(</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 (，把运算符压入栈</td>
<td><code>+*(*</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 (</td>
<td>把 ( 直接压入栈</td>
<td><code>+*(*(</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 4</td>
<td>把操作数直接输出</td>
<td><code>+*(*(</code></td>
<td><code>1234</code></td>
</tr>
<tr>
<td>读取 -</td>
<td>栈顶为 (，把运算符压入栈</td>
<td><code>+*(*(-</code></td>
<td><code>1234</code></td>
</tr>
<tr>
<td>读取 5</td>
<td>把操作数直接输出</td>
<td><code>+*(*(-</code></td>
<td><code>12345</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 -，优先级低于 *，把运算符压入栈</td>
<td><code>+*(*(-*</code></td>
<td><code>12345</code></td>
</tr>
<tr>
<td>读取 6</td>
<td>把操作数直接输出</td>
<td><code>+*(*(-*</code></td>
<td><code>123456</code></td>
</tr>
<tr>
<td>读取 +</td>
<td>栈顶为 *，优先级高于 +，依次弹出栈中运算符 到输出，到 ( 停止，把运算符压入栈中</td>
<td><code>+*(*(+</code></td>
<td><code>123456*-</code></td>
</tr>
<tr>
<td>读取 7</td>
<td>把操作数直接输出</td>
<td><code>+*(*(+</code></td>
<td><code>123456*-7</code></td>
</tr>
<tr>
<td>读取 )</td>
<td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td>
<td><code>+*(*</code></td>
<td><code>123456*-7+</code></td>
</tr>
<tr>
<td>读取 )</td>
<td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td>
<td><code>+*</code></td>
<td><code>123456*-7+*</code></td>
</tr>
<tr>
<td>结束读取</td>
<td>把栈中的元素全部弹出到输出</td>
<td></td>
<td><code>123456*-7+**+</code></td>
</tr>
</tbody></table>
<p>输出后缀表达式为：<code>123456*-7+**+</code></p>
<h2 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h2><ol>
<li>按次序读取表达式的每一个字符</li>
<li>读到操作数时，把操作数压入栈</li>
<li>读到操作符时，弹出栈顶的两个数做相应运算，把结果压入栈</li>
<li>读取完所有表达式的字符后，弹出栈，结果即为所求的值</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huben.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> koishi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndixToSuffix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入表达式:"</span>);</span><br><span class="line">        String str = in.next();</span><br><span class="line">        System.out.println(<span class="string">"你输入的表达式为: "</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"转化为后缀表达式为："</span> + transfer(str));</span><br><span class="line">        System.out.println(<span class="string">"计算结果为:"</span> + calculate(transfer(str)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把中缀表达式转换为后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 中缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后缀表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transfer</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; (stack.peek() == <span class="string">'*'</span> || stack.peek() == <span class="string">'/'</span>)) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Float&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                stack.push((<span class="keyword">float</span>) (c - <span class="string">'0'</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(cal(c, stack.pop(), stack.pop()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Float <span class="title">cal</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b + a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b * a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b / a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果截图</p>
<img src="/2020/02/20/28b1/result.png" class="">

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
