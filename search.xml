<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java容器源码分析：ArrayList</title>
    <url>/2020/03/17/47677/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ArrayList是一种以数组实现的List，它具有动态扩展的能力，因此也可称之为动态数组</p>
<ul>
<li>底层：ArrayList是List接口的大小可变数组的实现</li>
<li>是否允许null：ArrayList运行null元素</li>
<li>时间复杂度：size、isEmpty、get、set、iterator和listIterator方法都是以固定的时间运行，时间复杂度为$O(1)$，add和remove方法为$O(n)$</li>
<li>容量：ArrayList容量可以自动增长</li>
<li>是否同步：ArrayList不是同步的</li>
<li>迭代器：ArrayList的iterator和listIterator返回的迭代器是fail-fast的</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>从中可以知道：</p>
<ul>
<li><strong>ArrayList&lt;E&gt;</strong>：说明ArrayList支持泛型</li>
<li>继承<strong>AbstractList</strong>：AbstractList提供List接口的骨干实现，以最大限度地减少“随机访问”数据存储（如ArrayList）实现Llist所需的工作</li>
<li>实现<strong>List</strong>：实现了List。实现了所有可选列表操作</li>
<li>实现<strong>RandomAccess</strong>：表明ArrayList支持快速随机访问</li>
<li>实现<strong>Cloneable</strong>：表明ArrayList可以被克隆</li>
<li>实现<strong>Serializable</strong>：表明ArrayList可以被序列化</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认容量为10，也就是通过new ArrayList()创建时的默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空数组，这种是通过new ArrayList(0)创建时用的是这个空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也是空数组，这种是通过new ArrayList()创建时用的是这个空数组</span></span><br><span class="line"><span class="comment">// 与EMPTY_ELEMENTDATA的区别是在添加第一个元素时使用这个空数组的会扩容为DEFAULT_CAPACITY</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存添加到ArrayList中的元素，被标记为transient，不会被序列化</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList的实际大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ArrayList提供了三种构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果大于0就初始化elementData为对应大小</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果等于0就使用EMPTY_ELEMENTDATA空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果小于0抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不传初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把elementData初始化为DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="comment">// 在添加第一个元素的时候会扩容为默认的大小，即10</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把传入集合的元素拷贝到elementData数组</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查c.toArray()返回的是不是Object[]类型，如果不是，重新拷贝成Object[].class类型</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果元素个数为0，则初始化为EMPTY_ELEMENTDATA空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>get(int index)</strong> 获取指定索引处的元素，平均时间复杂度$O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否越界</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add(E e)</strong> 添加元素到末尾，平均时间复杂度$O(1)​$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 调用add的重载方法</span></span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若size等于elementData的长度，说明需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    <span class="comment">// 实际大小加1</span></span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="comment">// 因为是添加一个元素时调用的，所以扩容的最小容量为size+1</span></span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minCapacity参数为扩容所需要的最小容量</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">// 通过newCapacity方法确定扩容后的数组大小，把原数组复制到扩容后长度的新数组中并返回</span></span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分派给arrays的最大容量</span></span><br><span class="line"><span class="comment"> * 减去8因为某些VM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于VM的limit，最终导致OutOfMemoryError。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组原长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新长度为原长度的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩容后的容量还是小于想要的最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组为空数组，则返回DEFAULT_CAPACITY, minCapacity较大者</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity小于0，抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="comment">// 将扩容后的容量再次扩容为想要的最小容量</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果扩容后的容量大于临界值，则调用hugeCapacity方法进行大容量分配</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// minCapacity小于0，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//如果想要的容量大于MAX_ARRAY_SIZE，则分配Integer.MAX_VALUE，否则分配MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add(int index, E e)</strong> 添加元素到指定位置，平均时间复杂度$O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 越界检查</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">// 把数组index后的元素向后移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    <span class="comment">// 将index位置元素赋值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 实际大小加1</span></span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>addAll(Collection&lt;? extends E&gt; c)</strong> 添加一个集合内所有元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将要添加的集合转为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 添加的集合长度为0时添加失败</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">// 如果要添加的集合中元素个数大于数组空余空间长度，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    <span class="comment">// 把要添加的元素加入数组</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    <span class="comment">// 实际大小增加</span></span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(int index)</strong> 删除指定索引位置的元素，时间复杂度$O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否越界</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E oldValue = (E) es[index];</span><br><span class="line">     <span class="comment">// 调用fastRemove，快速删除数组es下标i的元素</span></span><br><span class="line">    fastRemove(es, index);</span><br><span class="line">    <span class="comment">// 返回被删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="comment">// 把数组es下标i后所以元素向前移动一位</span></span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    <span class="comment">// 把数组最后一个元素置空</span></span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object o)</strong> 删除指定元素，时间复杂度$O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 寻找元素o在数组中的下标</span></span><br><span class="line">    found: &#123;</span><br><span class="line">        <span class="comment">// 判断要找的元素是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用fastRemove，快速删除数组es下标i的元素</span></span><br><span class="line">    fastRemove(es, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>removeAll(Collection&lt;?&gt; c)</strong> 删除指定集合中在当前集合的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除元素，complement为true表示删除c不包含的元素，为false表示删除c包含的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">final</span> <span class="keyword">int</span> from, <span class="keyword">final</span> <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">// 如果c中有符合条件的元素，把读指针放在该位置</span></span><br><span class="line">    <span class="keyword">for</span> (r = from;; r++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c.contains(es[r]) != complement)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> w = r++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// r w分别为读写指针，遍历es数组时每遍历一个元素r自增1</span></span><br><span class="line">        <span class="comment">// 当找到不要删除的元素时，把它放到w指针所在处后w自增1</span></span><br><span class="line">        <span class="keyword">for</span> (Object e; r &lt; end; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(e = es[r]) == complement)</span><br><span class="line">                es[w++] = e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        System.arraycopy(es, r, es, w, end - r);</span><br><span class="line">        w += end - r;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        modCount += end - w;</span><br><span class="line">        <span class="comment">// 把w指针后面的多余元素置空</span></span><br><span class="line">        shiftTailOverGap(es, w, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>retainAll(Collection&lt;?&gt; c)</strong> 求两个集合的交集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>因为elementData被设置成了transient，所以ArrayList自定义了序列化和反序列化的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 防止序列化期间有修改</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    <span class="comment">// 写出元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    <span class="comment">// 依次写出元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果序列化期间有修改则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 读入非transient非static属性（会读取size属性）</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[]<span class="class">.<span class="keyword">class</span>, <span class="title">size</span>)</span>;</span><br><span class="line">        Object[] elements = <span class="keyword">new</span> Object[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elementData = elements;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Invalid size: "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容</p>
</li>
<li><p>ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为$O(1)$</p>
</li>
<li><p>ArrayList添加元素到尾部极快，平均时间复杂度为$O(1)$</p>
</li>
<li><p>ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为$O(n)$</p>
</li>
<li><p>ArrayList从尾部删除元素极快，时间复杂度为$O(1)$</p>
</li>
<li><p>ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为$O(n)​$</p>
</li>
<li><p>ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可</p>
</li>
<li><p>ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可</p>
</li>
<li><p>ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器源码分析：整体结构</title>
    <url>/2020/03/17/29776/</url>
    <content><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>通常，程序总是在运行的时候才能确定要创建对象的数量，甚至的对象的类型。为了解决这个问题，需要在任意时刻任意位置创建任意数量的对象。Java使用容器来解决这个问题</p>
<p>容器也称集合类，基本的类型有List、Set、Queue和Map</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><img src="/2020/03/17/29776/list.png" class="">

<p>List以线性方式存储元素，集合中可以存放重复对象，元素有序。主要实现方式有动态数组和链表<br>最常用实现类：</p>
<ul>
<li>ArrayList：随机访问元素快，增删元素慢</li>
<li>Vector：Vector与ArrayList相似。但Vector的方法是线程安全的，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此ArrayList的性能比Vector好</li>
<li>LinkedList：随机访问元素慢，顺序访问快，增删元素快</li>
<li>Stack：栈，继承Vector，特点是先进后出(FILO, First In Last Out)</li>
</ul>
<p>点击下方连接可直接到相应章节查看：</p>
<ul>
<li><a href="/2020/03/17/47677/">Java容器源码分析：ArrayList</a></li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><img src="/2020/03/17/29776/set.png" class="">

<p>Set不保存同样的元素。Set与Collection有完全一样的接口。Set不保证维护元素的次序</p>
<p>最常用实现类：</p>
<ul>
<li>HashSet：随机查找快。存入HashSet的对象必须定义hashCode()。HashSet查找某个对象时，首先用hashCode()方法计算出这个对象的Hash码，然后再根据Hash码到相应的存储区域用equals()方法查找，从而提高了效率</li>
<li>TreeSet：保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列</li>
<li>LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><img src="/2020/03/17/29776/map.png" class="">

<p>Map 是一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象。 Map没有继承于Collection接口</p>
<p>最常用的实现类：</p>
<ul>
<li>HashMap：Map基于哈希表的 Map 接口的实现</li>
<li>HashTable：hashtable和hashmap，从存储结构和实现来讲基本上都是相同的，最大的不同就是hashtable是线程安全的</li>
<li>LinkedHashMap：LinkedHashMap是HashMap的一个子类，是Map接口的哈希表和链接列表实现。它维护着一个双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序</li>
<li>TreeMap：基于红黑树的实现</li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><img src="/2020/03/17/29776/queue.png" class="">

<p>Queue是一种叫做队列的数据结构，队列是遵循着一定原则的入队出队操作的集合，一般来说，入队是在队列尾添加元素，出队是在队列头删除元素，但是，也不一定，比如优先级队列的原则就稍微有些不同</p>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><img src="/2020/03/17/29776/deque.png" class="">

<p>Deque是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列（Double Ended Queue）</p>
<h2 id="相关工具类"><a href="#相关工具类" class="headerlink" title="相关工具类"></a>相关工具类</h2><ol>
<li><p>Iterator迭代器</p>
<p>迭代器是用来遍历并选择序列中的对象。只能单向移动</p>
</li>
<li><p>ListIterator迭代器</p>
<p>更强大的Iterator的子类型，它只能用于List的访问。它最大的优点是可以双向移动</p>
</li>
<li><p>Enumeration枚举类</p>
<p>只能在Hashtable、Vector、Stack中使用，此接口已被迭代器取代，很少使用。</p>
</li>
<li><p>Arrays</p>
<p>用于更方便地操作数组</p>
</li>
<li><p>Collections</p>
<p>用于更方便地操作集合</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解(4)：寻找两个有序数组的中位数</title>
    <url>/2020/03/16/29343/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(log(m + n))$。</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空 </p>
<p>示例 1: </p>
<blockquote>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0</p>
</blockquote>
<p>示例 2: </p>
<blockquote>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
</blockquote>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性：Stream</title>
    <url>/2020/03/16/36643/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Stream操作简称流操作，这个流与I/O流没有关系，而是指流式操作</p>
<p>Stream流操作主要包括三大模块</p>
<ul>
<li><p>创建流操作：主要是创建Stream流对象</p>
</li>
<li><p>中间流操作：各种中间操作，如去重、过滤、排序等</p>
</li>
<li><p>终结流操作：产生最终结果</p>
</li>
</ul>
<h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><p>基于数组创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">IntStream s1 = Arrays.stream(ints);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; s2 = Stream.of(<span class="string">"111"</span>, <span class="string">"222"</span>, <span class="string">"333"</span>);</span><br></pre></td></tr></table></figure>

<p>通过构造器生成流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Object&gt; s3 = Stream.builder().add(<span class="string">"123"</span>).add(<span class="string">"321"</span>).build();</span><br></pre></td></tr></table></figure>

<p>基于集合创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"123"</span>, <span class="string">"321"</span>, <span class="string">"444"</span>);</span><br><span class="line">Stream&lt;String&gt; s4 = list.stream();</span><br><span class="line">Stream&lt;String&gt; s5 = list.parallelStream(); <span class="comment">// 并行流</span></span><br></pre></td></tr></table></figure>

<p>创建空流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Object&gt; s6 = Stream.empty();</span><br></pre></td></tr></table></figure>

<p>基于函数创建无限流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(() -&gt; <span class="string">"number"</span> + <span class="keyword">new</span> Random().nextInt()).limit(<span class="number">100</span>).forEach(System.out::println);</span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="流中间操作"><a href="#流中间操作" class="headerlink" title="流中间操作"></a>流中间操作</h2><table>
<thead>
<tr>
<th>序号</th>
<th>操作</th>
<th>方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>filter</td>
<td>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</td>
<td>返回当前流中满足参数predicate过滤条件的元素组成的新流</td>
<td>过滤器</td>
</tr>
<tr>
<td>2</td>
<td>map</td>
<td>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</td>
<td>返回通过给定mapper作用于当前流的每个元素之后的结果组成的新流</td>
<td>函数</td>
</tr>
<tr>
<td>3</td>
<td>mapToInt</td>
<td>IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)</td>
<td>返回通过给定mapper作用于当前流的每个元素之后的结果组成的新的Int流</td>
<td>函数</td>
</tr>
<tr>
<td>4</td>
<td>mapToLong</td>
<td>LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);</td>
<td>返回通过给定mapper作用于当前流的每个元素之后的结果组成的新的Long流</td>
<td>函数</td>
</tr>
<tr>
<td>5</td>
<td>mapToDouble</td>
<td>DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</td>
<td>返回通过给定mapper作用于当前流的每个元素之后的结果组成的新的Double流</td>
<td>函数</td>
</tr>
<tr>
<td>6</td>
<td>flatMap</td>
<td>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</td>
<td>根据给定的mapper作用于当前流的每个元素，将结果组成新的流来返回</td>
<td>扁平函数</td>
</tr>
<tr>
<td>7</td>
<td>flatMapToInt</td>
<td>IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper)</td>
<td>根据给定的mapper作用于当前流的每个元素，将结果组成新的Int流来返回</td>
<td>扁平函数</td>
</tr>
<tr>
<td>8</td>
<td>flatMapToLong</td>
<td>LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper)</td>
<td>根据给定的mapper作用于当前流的每个元素，将结果组成新的Long流来返回</td>
<td>扁平函数</td>
</tr>
<tr>
<td>9</td>
<td>flatMapToDouble</td>
<td>DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper)</td>
<td>根据给定的mapper作用于当前流的每个元素，将结果组成新的Double流来返回</td>
<td>扁平函数</td>
</tr>
<tr>
<td>10</td>
<td>distinct</td>
<td>Stream&lt;T&gt; distinct()</td>
<td>返回去掉当前流中重复元素之后的新流</td>
<td>去重</td>
</tr>
<tr>
<td>11</td>
<td>sorted</td>
<td>Stream&lt;T&gt; sorted()</td>
<td>返回当前流中元素排序之后的新流，需要元素类型实现Comparable</td>
<td>排序</td>
</tr>
<tr>
<td>12</td>
<td>sorted</td>
<td>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</td>
<td>返回当前流中元素排序之后的新流，需要传递一个Comparator</td>
<td>排序</td>
</tr>
<tr>
<td>13</td>
<td>peek</td>
<td>Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action);</td>
<td>针对流中的每个元素执行操作action</td>
<td>查阅</td>
</tr>
<tr>
<td>14</td>
<td>limit</td>
<td>Stream&lt;T&gt; limit(long maxSize)</td>
<td>返回指定的数量的元素组成的新流</td>
<td>限制</td>
</tr>
<tr>
<td>15</td>
<td>skip</td>
<td>Stream&lt;T&gt; skip(long n)</td>
<td>返回第n个之后的元素组成的新流</td>
<td>跳过</td>
</tr>
</tbody></table>
<h3 id="fliter"><a href="#fliter" class="headerlink" title="fliter"></a>fliter</h3><p>filter方法是过滤器方法，针对的是流中所有元素，满足条件的元素将会被保留以组成新的流</p>
<p>filter方法的参数是Predicate类型，这个函数式接口用于获取一个参数返回一个boolean值，整个参数作为过滤条件</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map方法可以理解为函数，需要针对流中每个元素执行，然后将执行的结果组成新的流返回</p>
<p>map方法的参数类型为Function，该函数式接口用于接受一个参数，返回一个结果</p>
<p>mapToInt、mapToLong、mapToDouble方法是map方法的扩展，其参数分别为ToIntFunction、ToLongFunction、ToDoubleFunction，分别接口一个参数，返回指定类型的值，分别为int、long、double，那么定义方法的时候就要注意返回值的类型了，必须一致，最后组成的新流就是一个int或long或double元素流（IntStream、LongStream、DoubleStream）</p>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>flatMap和map类似，都是针对流中每个元素进行操作，将结果组成新流，但flatMap含有一层扩展之意，就是当流中元素保护子元素时，通过该方法获取元素的子元素，并将子元素组成新流返回</p>
<p>flatMapToInt、flatMapToLong、flatMapToDouble类似于之前的mapToInt之类</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>distinct方法用于去除流中重复元素</p>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted方法用于对流中元素排序，当调用无参的sorted方法时，采用自然排序法排序，当使用指定比较器的方式时，可以自由指定排序规则</p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit方法用于从首个元素开始截取n个元素，组成新流返回</p>
<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>skip方法用于跳过前n个元素，将剩余元素组成新流返回</p>
<h2 id="流终结操作"><a href="#流终结操作" class="headerlink" title="流终结操作"></a>流终结操作</h2><table>
<thead>
<tr>
<th>序号</th>
<th>操作</th>
<th>方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>forEach</td>
<td>void forEach(Consumer&lt;? super T&gt; action);</td>
<td>对流中的每个元素执行指定的操作action</td>
<td>遍历</td>
</tr>
<tr>
<td>2</td>
<td>forEachOrdered</td>
<td>void forEachOrdered(Consumer&lt;? super T&gt; action)</td>
<td>如果有序，则按序遍历流中元素，针对每个元素执行指定操作</td>
<td>按序遍历</td>
</tr>
<tr>
<td>3</td>
<td>toArray</td>
<td>Object[] toArray()</td>
<td>返回一个包含流中所有元素的数组</td>
<td>数组化</td>
</tr>
<tr>
<td>4</td>
<td>toArray</td>
<td>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)</td>
<td>返回一个包含流中所有元素的参数指定类型的数组</td>
<td>数组化</td>
</tr>
<tr>
<td>5</td>
<td>reduce</td>
<td>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</td>
<td>以给定初始值为基础归纳流中元素，返回一个值</td>
<td>归纳</td>
</tr>
<tr>
<td>6</td>
<td>reduce</td>
<td>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</td>
<td>直接归纳流中的元素，返回一个封装有结果的Optional</td>
<td>归纳</td>
</tr>
<tr>
<td>7</td>
<td>reduce</td>
<td>&lt;U&gt; U reduce(U identity,  BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</td>
<td>以给定的初始值为基础，（并行）归纳流中元素，最后将各个线程的结果再统一归纳，返回一个值</td>
<td>归纳</td>
</tr>
<tr>
<td>8</td>
<td>collect</td>
<td>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</td>
<td>根据给定的收集器收集元素</td>
<td>归纳</td>
</tr>
<tr>
<td>9</td>
<td>collect</td>
<td>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</td>
<td>根据给定的各个参数归纳元素</td>
<td>归纳</td>
</tr>
<tr>
<td>10</td>
<td>max</td>
<td>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</td>
<td>根据给定的比较器，返回流中最大元素的Optional表示</td>
<td>最大值</td>
</tr>
<tr>
<td>11</td>
<td>min</td>
<td>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)</td>
<td>根据给定的比较器，返回流中最小元素的Optional表示</td>
<td>最小值</td>
</tr>
<tr>
<td>12</td>
<td>count</td>
<td>long count()</td>
<td>返回流中元素的个数</td>
<td>计数</td>
</tr>
<tr>
<td>13</td>
<td>anyMatch</td>
<td>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>校验流中是否有满足给定条件的元素</td>
<td>校验</td>
</tr>
<tr>
<td>14</td>
<td>allMatch</td>
<td>boolean allMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>校验流中的元素是否全部满足给定条件</td>
<td>校验</td>
</tr>
<tr>
<td>15</td>
<td>noneMatch</td>
<td>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>校验流中的元素是否全不满足给点条件</td>
<td>校验</td>
</tr>
<tr>
<td>16</td>
<td>findFirst</td>
<td>Optional&lt;T&gt; findFirst()</td>
<td>返回首个元素的Optional表示，如果为空流，返回空的Optional</td>
<td>返回首个元素</td>
</tr>
<tr>
<td>17</td>
<td>findAny</td>
<td>Optional&lt;T&gt; findAny()</td>
<td>如果流中有元素，则返回第一个元素的Optional表示，否则返回一个空的Optional</td>
<td>校验是否为空流</td>
</tr>
</tbody></table>
<h3 id="forEach和forEachOrdered"><a href="#forEach和forEachOrdered" class="headerlink" title="forEach和forEachOrdered"></a>forEach和forEachOrdered</h3><p>forEach就是遍历操作，对流中的每个元素做最后的操作</p>
<p>forEach并行遍历不保证顺序（顺序随机）,forEachOrdered是保证顺序来进行遍历的</p>
<h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><p>toArray有两个重载方法，一个是无参方法，一个有参方法</p>
<p>无参方法返回的只能是Object[]数组类型，而有参方法，可以指定结果数组类型，此乃二者区别</p>
<p>使用有参方法可以直接完成类型转换，一次到位。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce有三个重载方法，它们作用其实是一样的，就是归纳总结的意思</p>
<ul>
<li><p>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</p>
<p>参数accumulator是一个累加器，方法的作用是将这个累加器作用到流中的每一个元素需，要两个输入参数，有一个输出参数，意思是对两个元素执行某些操作，返回一个结果，然后将这个结果与下一个元素作为参数再输入该方法，执行操作后再返回一个新结果，以此类推，直到最后一个元素执行完毕，返回的就是最终结果，因为流中的元素我们是不确定的，那么我们就无法确定reduce的结果，因为如果流为空，那么将会返回null，所以使用Optional作为返回值，妥善处理null值</p>
</li>
<li><p>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</p>
<p>在上方法的基础上加了一个identity，且不使用Optional。原因是新加的identity是个初始值，后续操作都在这个初始值基础上进行，即使流中没有元素也不会返回null</p>
</li>
<li><p>&lt;U&gt; U reduce(U identity,  BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</p>
<p>在上方法的基础上又加了个参数combiner，这个方法用于处理并行流的归纳操作，最后的参数combiner用于归纳各个并行的结果</p>
</li>
</ul>
<h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>collect操作是Stream中最强大的方法了，几乎可以得到任何你想要的结果，collect方法有两个重载方法</p>
<ul>
<li><p>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</p>
</li>
<li><p>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性：函数式编程</title>
    <url>/2020/03/16/31228/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JDK1.8引入了函数式编程，重点包括函数式接口、lambda表达式和方法引用等</p>
<p>所谓函数式编程是把函数作为一个基本单位进行传递。以往Java中参数只能是具体的变量，二函数式编程打破这一规范，可以把整个方法作为一个参数传递</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是JDK1.8时提出的概念，但其实以往的JDK中就已经存在这些结构，只是没有定义化</p>
<p>函数式接口就是只有一个抽象方法的接口。常用的有Runnable、Comparator等</p>
<p>为了规范化，同时避免用户自定义函数式接口时错误地添加其他抽象方法，定义了一个注解 <code>@FunctionalInterface</code>，凡是由该注解标注的接口皆为函数式接口，强制的只能有一个抽象方法</p>
<p>为了函数式接口的扩展，JDK对接口规范进行了修改，接口中除了可以定义抽象方法之外，还可以定义静态方法和默认方法。其中静态方法一般作为工具方法，二默认方法是可以被继承重写的，还能有一个默认实现。除此之外，函数式接口中还可以重写Object中定义的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 典型函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Itest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;<span class="comment">// 重写Object中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这是一个默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这是一个静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK中预定义的函数式接口</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>接口名</th>
<th>抽象方法</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Supplier&lt;T&gt;</td>
<td>T get()</td>
<td>通过操作返回结果</td>
<td>无中生有</td>
</tr>
<tr>
<td>2</td>
<td>IntSupplier</td>
<td>int getAsInt()</td>
<td>通过操作返回一个int值</td>
<td>无中生有</td>
</tr>
<tr>
<td>3</td>
<td>LongSupplier</td>
<td>long getAsLong()</td>
<td>通过操作返回一个long值</td>
<td>无中生有</td>
</tr>
<tr>
<td>4</td>
<td>DoubleSupplier</td>
<td>double getAsDouble()</td>
<td>通过操作返回一个double值</td>
<td>无中生有</td>
</tr>
<tr>
<td>5</td>
<td>BooleanSupplier</td>
<td>boolean getAsBoolean()</td>
<td>通过操作返回一个boolean值</td>
<td>无中生有</td>
</tr>
<tr>
<td>6</td>
<td>Consumer&lt;T&gt;</td>
<td>void accept(T t)</td>
<td>针对参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>7</td>
<td>BiConsumer&lt;T,U&gt;</td>
<td>void accept(T t,U u)</td>
<td>针对两个参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>8</td>
<td>IntConsumer</td>
<td>void accept(int value)</td>
<td>针对int参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>9</td>
<td>LongConsumer</td>
<td>void accept(long value)</td>
<td>针对long参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>10</td>
<td>DoubleConsumer</td>
<td>void accept(double value)</td>
<td>针对double参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>11</td>
<td>ObjIntConsumer&lt;T&gt;</td>
<td>void accept(T t, int value)</td>
<td>针对T和int参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>12</td>
<td>ObjLongConsumer&lt;T&gt;</td>
<td>void accept(T t, long value)</td>
<td>针对T和long参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>13</td>
<td>ObjDoubleConsumer&lt;T&gt;</td>
<td>void accept(T t, double value)</td>
<td>针对T和double参数做一系列操作，无返回值</td>
<td>消费掉了</td>
</tr>
<tr>
<td>14</td>
<td>Function&lt;T, R&gt;</td>
<td>R apply(T t)</td>
<td>根据参数生成一个返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>15</td>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>R apply(T t,U u)</td>
<td>根据两个参数生成一个返回值</td>
<td>多因一果</td>
</tr>
<tr>
<td>16</td>
<td>IntFunction<R></td>
<td>R apply(int value)</td>
<td>根据int参数生成一个返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>17</td>
<td>LongFunction<R></td>
<td>R apply(long value)</td>
<td>根据long参数生成一个返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>18</td>
<td>DoubleFunction<R></td>
<td>R apply(double value)</td>
<td>根据double参数生成一个返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>19</td>
<td>ToIntFunction&lt;T&gt;</td>
<td>int applyAsInt(T value)</td>
<td>根据一个参数生成一个int返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>20</td>
<td>ToIntBiFunction&lt;T, U&gt;</td>
<td>int applyAsInt(T t, U u)</td>
<td>根据两个参数生成一个int返回值</td>
<td>多因一果</td>
</tr>
<tr>
<td>21</td>
<td>ToLongFunction&lt;T&gt;</td>
<td>long applyAsLong(T value)</td>
<td>根据一个参数生成一个long返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>22</td>
<td>ToLongBiFunction&lt;T, U&gt;</td>
<td>long applyAsLong(T t, U u)</td>
<td>根据两个参数生成一个long返回值</td>
<td>多因一果</td>
</tr>
<tr>
<td>23</td>
<td>ToDoubleFunction&lt;T&gt;</td>
<td>double applyAsDouble(T value)</td>
<td>根据一个参数生成一个double返回值</td>
<td>一因一果</td>
</tr>
<tr>
<td>24</td>
<td>ToDoubleBiFunction&lt;T, U&gt;</td>
<td>double applyAsDouble(T t, U u)</td>
<td>根据两个参数生成一个double返回值</td>
<td>多因一果</td>
</tr>
<tr>
<td>25</td>
<td>IntToLongFunction</td>
<td>long applyAsLong(int value)</td>
<td>根据int参数生成一个long结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>26</td>
<td>IntToDoubleFunction</td>
<td>double applyAsDouble(int value)</td>
<td>根据int参数生成一个double结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>27</td>
<td>LongToIntFunction</td>
<td>int applyAsInt(long value)</td>
<td>根据long参数生成一个int结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>28</td>
<td>LongToDoubleFunction</td>
<td>double applyAsDouble(long value)</td>
<td>根据long参数生成一个double结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>29</td>
<td>DoubleToIntFunction</td>
<td>int applyAsInt(double value)</td>
<td>根据double参数生成一个int结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>30</td>
<td>DoubleToLongFunction</td>
<td>long applyAsLong(double value)</td>
<td>根据double参数生成一个long结果返回</td>
<td>一因一果</td>
</tr>
<tr>
<td>31</td>
<td>Predicate&lt;T&gt;</td>
<td>boolean test(T t)</td>
<td>根据参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>32</td>
<td>BiPredicate&lt;T, U&gt;</td>
<td>boolean test(T t, U u)</td>
<td>根据两个参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>33</td>
<td>IntPredicate</td>
<td>boolean test(int value)</td>
<td>根据int参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>34</td>
<td>LongPredicate</td>
<td>boolean test(long value)</td>
<td>根据long参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>35</td>
<td>DoublePredicate</td>
<td>boolean test(double value)</td>
<td>根据double参数返回校验结果</td>
<td>校验参数</td>
</tr>
<tr>
<td>36</td>
<td>UnaryOperator&lt;T&gt;</td>
<td>T apply(T t)</td>
<td>根据参数通过操作返回结果</td>
<td>一元操作</td>
</tr>
<tr>
<td>37</td>
<td>BinaryOperator&lt;T&gt;</td>
<td>T apply(T t1,T t2)</td>
<td>根据两个参数通过操作返回结果</td>
<td>二元操作</td>
</tr>
<tr>
<td>38</td>
<td>IntUnaryOperator</td>
<td>int applyAsInt(int operand)</td>
<td>根据int参数通过操作返回int结果</td>
<td>一元操作</td>
</tr>
<tr>
<td>39</td>
<td>IntBinaryOperator</td>
<td>int applyAsInt(int left, int right)</td>
<td>根据两个int参数通过操作返回int结果</td>
<td>二元操作</td>
</tr>
<tr>
<td>40</td>
<td>LongUnaryOperator</td>
<td>long applyAsLong(long operand)</td>
<td>根据long参数通过操作返回long结果</td>
<td>一元操作</td>
</tr>
<tr>
<td>41</td>
<td>LongBinaryOperator</td>
<td>long applyAsLong(long left, long right)</td>
<td>根据两个long参数通过操作返回long结果</td>
<td>二元操作</td>
</tr>
<tr>
<td>42</td>
<td>DoubleUnaryOperator</td>
<td>double applyAsDouble(double operand)</td>
<td>根据double参数通过操作返回double结果</td>
<td>一元操作</td>
</tr>
<tr>
<td>43</td>
<td>DoubleBinaryOperator</td>
<td>double applyAsDouble(double left, double right)</td>
<td>根据两个double参数通过操作返回double结果</td>
<td>二元操作</td>
</tr>
</tbody></table>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式可用于两个地方：集合遍历和替换匿名内部类。前者基于Iterable接口中定义的forEach方法，后者则依据函数式接口</p>
<ol>
<li><p>forEach方法</p>
<p>forEach方法是对函数式接口的有效利用，将遍历的书写流程简化，不用再写一大堆的for循环框架代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LanbdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Collections.EMPTY_LIST;</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">        Map&lt;String,Object&gt; map = Collections.EMPTY_MAP;</span><br><span class="line">        map.forEach((k,v) -&gt; System.out.println(k + <span class="string">":"</span>+ v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forEach方法的参数是Consumer或BigConsumer，主要是用于消费资源，即需提供参数但没有返回值的方法</p>
<p>Iterable中的forEach方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterable的实现类均可以通过重写该方法来自定义遍历的方式</p>
</li>
<li><p>替换匿名内部类</p>
<p>Lambda替换匿名内部类有一个前提，那就是这个匿名内部类的接口类型必须为函数式接口，如果不是函数式接口，是无法使用Lambda替换的。</p>
<p>常用的函数式接口为Runnable，使用匿名内部类方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        	@Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">             System.out.println(&quot;采用匿名内部类&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lambda替换如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"采用匿名内部类"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用出现的目的是为了解决所需的操作已经存在的情况</p>
<p>当我们需要传递的操作已经存在，那就不必再费尽心思的再写一个出来啦，直接使用方法引用来将已有的方法给它就行了</p>
<p>方法引用使用<code>::</code>双冒号组成的操作符来指定方法，参数不再是显式传递，而是会自动传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LanbdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(Supplier&lt;String&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"huahua"</span>);</span><br><span class="line">        System.out.println(getName(person::getName)); <span class="comment">// 打印：huahua</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们使用了方法引用：person::getName，Person类中有已定义好的获取name的方法，这里就可以直接引用该方法。Supplier是供应者，可以无中生有，也就是不需要参数，产生一个返回值</p>
<p>方法引用的种类：</p>
<ul>
<li>类的构造器引用：ArrayList::new、String[]::new</li>
<li>类的静态方法引用：String::valueOf、Integer::valueOf</li>
<li>类的实例方法引用：String::length、Person::getName</li>
<li>对象的实例方法引用：sring::length、person::getName</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识：Enum深入解析</title>
    <url>/2020/03/16/36839/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>枚举是一个语法糖，使用<strong>enum</strong>定义一个枚举，实际上是定义了一个类继承了<strong>Enum</strong>类</p>
<p>了解了<strong>Enum</strong>类，就能了解枚举</p>
<h2 id="Enum-解析"><a href="#Enum-解析" class="headerlink" title="Enum 解析"></a>Enum 解析</h2><ol>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Constable</span>, <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>枚举类实现了<strong>Comparable</strong>和<strong>Serializable</strong>接口，这表示每个枚举都拥有比较和序列化的功能</p>
</li>
<li><p>属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个属性是枚举的内置属性，name表示枚举值的名称，ordinal表示枚举值的序号</p>
</li>
<li><p>构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Enum</strong>只有这一个构造器，声明为protected是为了让继承它的子类(即我们定义的各种枚举)来调用</p>
</li>
<li><p>equals和hashcode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>==other;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的equals方法就是直接使用==来比较的，所以枚举的比较使用==和equals都是可以的</p>
</li>
<li><p>禁用的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这四个方法被禁用，目的是：</p>
<ul>
<li>clone 保证单例唯一</li>
<li>finalize 禁用终引用</li>
<li>readObjeect 保证单例唯一</li>
<li>readObjectNoData 保证单例唯一</li>
</ul>
</li>
<li><p>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span> </span>&#123;</span><br><span class="line">    Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;</span><br><span class="line">    Enum&lt;E&gt; self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (self.getClass() != other.getClass() &amp;&amp; <span class="comment">// optimization</span></span><br><span class="line">        self.getDeclaringClass() != other.getDeclaringClass())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">    <span class="keyword">return</span> self.ordinal - other.ordinal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span> </span>&#123;</span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">         <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>compartTo 用于定义比较的方式，可以看出是使用序号作为比较条件的</li>
<li>valueOf 用于获取到指定枚举类型中指定枚举名称的枚举值</li>
</ul>
</li>
</ol>
<h2 id="枚举的实现"><a href="#枚举的实现" class="headerlink" title="枚举的实现"></a>枚举的实现</h2><p>枚举是一种编译器语法糖，当使用<strong>enum</strong>关键字定义一个枚举，编译之后，编译器会对其进行加工：</p>
<ul>
<li>编译成class类型，并继承Enum</li>
<li>添加静态方法values，用于获取所以枚举值的数组</li>
<li>添加方法valueOf，实现Enum中的valueOf方法，可根据具体的枚举名称字符串获取对应枚举值</li>
<li>添加私有构造器，其中调用Enum中定义的唯一的构造器</li>
<li>定义静态常量枚举值</li>
<li>添加静态块为这些静态枚举常量赋值</li>
</ul>
<p>通过上述方法加工之后，枚举类被解析为一个普通的类，类名不变</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解(3)：无重复字符的最长字串</title>
    <url>/2020/03/14/24182/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>长度</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是<strong>子串</strong>的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>使用一个哈希表，key为字符，value为字符下标+1，+1表示从字符位置后一个开始才不重复</p>
<p>使用两个变量 l，r表示非重复字串的左右两端索引</p>
<p>遍历字符串，当遇到重复字符时，更新 l 值</p>
<p>无论是否更新 l ，都会更新 map 和结果 max</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, len = s.length();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; len; r++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(r);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">            l = Math.max(map.get(c), l);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, r - l + <span class="number">1</span>);</span><br><span class="line">        map.put(c, r + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n)$，空间复杂度 $O(min(m,n))$</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解(2)：两数相加</title>
    <url>/2020/03/14/33378/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<p>相关标签：<strong>链表</strong> <strong>数学</strong></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode a = l1, b = l2, cur = result;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = a == <span class="keyword">null</span> ? <span class="number">0</span> : a.val;</span><br><span class="line">        <span class="keyword">int</span> q = b == <span class="keyword">null</span> ? <span class="number">0</span> : b.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v = (p + q + n) % <span class="number">10</span>;</span><br><span class="line">        n = (p + q + n) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(v);</span><br><span class="line">        cur = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            a = a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(max(m,n))​$，空间复杂度 $O(max(m,n))​$</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解(1)：两数之和</title>
    <url>/2020/03/14/26270/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<p>相关标签： <strong>数组</strong> <strong>哈希表</strong></p>
<h2 id="解法1-暴力破解"><a href="#解法1-暴力破解" class="headerlink" title="解法1 暴力破解"></a>解法1 暴力破解</h2><p>遍历数组，对每个元素 nums[i]，查找剩下的元素中是否有值等于 target-nums[i]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target - nums[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n^2)$，空间复杂度 $O(1)​$</p>
<h2 id="解法2-两遍哈希表"><a href="#解法2-两遍哈希表" class="headerlink" title="解法2 两遍哈希表"></a>解法2 两遍哈希表</h2><p>构建一个哈希表，第一次循环时把元素的值和索引添加到表中，第二次循环时检查每个元素 nums[i] 所对应的目标元素 target-nums[i] 是否在表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put( nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = target - nums[i];</span><br><span class="line">        Integer index = map.get(val);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val) &amp;&amp; index != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, index&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n)$，空间复杂度 $O(n)​$</p>
<h2 id="解法3-一遍哈希表"><a href="#解法3-一遍哈希表" class="headerlink" title="解法3 一遍哈希表"></a>解法3 一遍哈希表</h2><p>在第一次循环时就检查每个元素 nums[i] 所对应的目标元素 target-nums[i] 是否在表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum3(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = target - nums[i];</span><br><span class="line">        Integer index = map.get(val);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val) &amp;&amp; index != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, index&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n)$，空间复杂度 $O(n)$</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：斐波那契数列</title>
    <url>/2020/03/04/25921/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>斐波那契数列是这样一个数列，它满足：$f(n)=\begin{cases}0&amp;\text{n=0}\\1&amp;\text{n=1}\\f(n-1)+f(n-2)&amp;\text{n&gt;=2}\end{cases}$</p>
<h2 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h2><p>实现很简单，当n=0返回0，n=1返回1，当n&gt;=2时使用递归返回前两项之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> n &lt; <span class="number">2</span> ? n : fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码很简单，只用1行就实现了斐波那契的算法，但这种单纯的递归实现会有很严重的性能问题。我用自己电脑计算 fib(50) 时就花了大概45秒，fib(60) 就算不出来了，一直卡着</p>
<p>之所以出现这种情况，是因为在递归的过程中存在大量重复的计算，如下图所示：</p>
<img src="/2020/03/04/25921/fibonacci1.jpg" class="">

<p>可见，仅仅是对 fib(10) 的计算，而且仅画出了4层，就出现了大量的重复。随着 n 的递增，为求出结果，重复的计算会急剧增加，这种方法的时间复杂度是 $O(n^2)​$</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>使用尾递归，把每次计算的结果保存下来，计算结果参与下一次的计算，从而减少计算量。原本递归产生的栈的层次像二叉树一样以指数级增长，现在栈的层次像数组，变成线性增长了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">long</span> first, <span class="keyword">long</span> second, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first + second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(second, first + second, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h2><p>不使用递归，而是使用迭代的方式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n1 = <span class="number">0</span>, n2 = <span class="number">1</span>, n3 = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        n3 = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现3"><a href="#实现3" class="headerlink" title="实现3"></a>实现3</h2><p>实际上斐波那契数列数列是有非递推式的通项公式的: $f(n)=\frac{1}{\sqrt5}(\frac{1+\sqrt5}{2})^n-\frac{1}{\sqrt5}(\frac{1-\sqrt5}{2})^n$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>) (Math.pow((<span class="number">1</span> + Math.sqrt(<span class="number">5</span>)) / <span class="number">2</span>, n) / Math.sqrt(<span class="number">5</span>) </span><br><span class="line">                   - Math.pow((<span class="number">1</span> - Math.sqrt(<span class="number">5</span>)) / <span class="number">2</span>, n) / Math.sqrt(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通项公式中要求某个数的 n 次幂，所以空间复杂度为 $O(\log_2n)$</p>
<h2 id="实现4"><a href="#实现4" class="headerlink" title="实现4"></a>实现4</h2><p>使用矩阵快速幂方式实现</p>
<p>斐波那契数列的通项公式为 $f(n)=\begin{cases}0&amp;\text{n=0}\\1&amp;\text{n=1}\\f(n-1)+f(n-2)&amp;\text{n&gt;=2}\end{cases}$</p>
<p>根据通项公式可写成以下形式：</p>
<p>$f(n+1)=1*f(n)+1*f(n-1)$</p>
<p>$f(n)=1*f(n-1)+1*f(n-2)$</p>
<p>$f(n)=1*f(n)+0*f(n-1)$</p>
<p>$f(n-1)=1*f(n-1)+0*f(n-2)​$</p>
<p>用矩阵表示为：</p>
<p>$$\begin{bmatrix}f(n+1)&amp;f(n)\\f(n)&amp;f(n-1)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}*\begin{bmatrix}f(n)&amp;f(n-1)\\f(n-1)&amp;f(n-2)\end{bmatrix}$$</p>
<p>进一步，可得：</p>
<p>$$\begin{bmatrix}f(n+1)&amp;f(n)\\f(n)&amp;f(n-1)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^2*\begin{bmatrix}f(n-1)&amp;f(n-2)\\f(n-2)&amp;f(n-3)\end{bmatrix}$$</p>
<p>$$=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-1}*\begin{bmatrix}f(2)&amp;f(1)\\f(1)&amp;f(0)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^n$$</p>
<p>所以通过求矩阵 $\begin{bmatrix}1&amp;1\\ 1&amp;0\end{bmatrix}​$ 的n次方就可以得到 $f(n)​$ 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>[][] UNIT = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] fib(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// n 为偶数</span></span><br><span class="line">        <span class="keyword">long</span>[][] matrix = fib(n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMultiply(matrix, matrix);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// n 为奇数</span></span><br><span class="line">        <span class="keyword">long</span>[][] matrix = fib((n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMultiply(UNIT, matrixMultiply(matrix, matrix));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] matrixMultiply(<span class="keyword">long</span>[][] a, <span class="keyword">long</span>[][] b) &#123;</span><br><span class="line">    <span class="keyword">int</span> row = a.length, col = b[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">long</span>[][] result = <span class="keyword">new</span> <span class="keyword">long</span>[row][col];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a[i].length; k++) &#123;</span><br><span class="line">                result[i][j] += a[i][k] * b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现5"><a href="#实现5" class="headerlink" title="实现5"></a>实现5</h2><p>在GMP(GNU多重精度算术库)中，它并没有使用矩阵快速幂的方法，而是使用递推式，不过它使用的递推式更加复杂：</p>
<p>$$f(2k+1)=4*f(k)^2-f(k-1)^2+2*(-1)^k$$</p>
<p>$$f(2k-1)=f(k)^2+f(k-1)^2$$</p>
<p>$$f(2k)=f(2k+1)-f(2k-1)$$</p>
<p>这个算法首先把n转化成二进制形式，然后从最高位开始向低位遍历，设m的二进制前i位(0到i-1位)表示的值为 $k_i​$，那么 $f(k_i)​$ 和 $f(k_i-1)​$ 都是已知的</p>
<ul>
<li>如果第i位为1，那么就用已知的 $f(k_i)$ 和 $f(k_i-1)$ 计算 $f(2k_i+1)$ 和 $f(2k_i)$，得到 $f(k_{i+1})$ 和 $f(k_{i+1}-1)​$</li>
<li>如果第i位为0，那么就用已知的 $f(k_i)​$ 和 $f(k_i-1)​$ 计算 $f(2k_i)​$ 和 $f(2k_i-1)​$，得到 $f(k_{i+1})​$ 和 $f(k_{i+1}-1)​$</li>
</ul>
<p>可以看到迭代的次数跟n的二进制长度一致，所以其时间复杂度也是 $O(\log_2n)$</p>
<p>需要注意的是，上述递推式中的 $f(k)^2$ 和 $f(k-1)^2$ 是可以复用的，实际上每一次迭代只需要进行两次大整数乘法运算</p>
<p>举个栗子：求 $f(25)$，已知 $f(-1)=1$，$f(0)=0$</p>
<p>首先把25转化为二进制形式11001，从最高位开始，它是1，那么此时 k=0</p>
<p>$$f(1)=4*f(0)^2=f(-1)^2+2=1$$</p>
<p>$$f(-1)=1$$</p>
<p>$$f(0)=0$$</p>
<p>然后第2位，同样为1，此时 k=1</p>
<p>$$f(3)=4*f(1)^2-f(0)^2-2=2$$</p>
<p>$$f(1)=1$$</p>
<p>$$f(2)=f(3)-f(1)=1$$</p>
<p>第3位为0，此时 k=3</p>
<p>$$f(7)=4*f(3)^2-f(2)^2-2=13$$</p>
<p>$$f(5)=f(3)^2+f(2)^2=5$$</p>
<p>$$f(6)=f(7)-f(5)=8$$</p>
<p>第4位为0，此时 k=6</p>
<p>$$f(13)=4*f(6)^2-f(5)^2+2=13$$</p>
<p>$$f(11)=f(6)^2+f(5)^2=98$$</p>
<p>$$f(12)=f(13)-f(11)=144$$</p>
<p>第5位为1，此时 k=12，得到最终结果</p>
<p>$$f(25)=4*f(12)^2-f(11)^2+2=75025$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    String b = Integer.toBinaryString(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> prev = <span class="number">1</span>, cur = <span class="number">0</span>, sign = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> prev2 = prev * prev;</span><br><span class="line">        <span class="keyword">long</span> cur2 = cur * cur;</span><br><span class="line">        cur = <span class="number">4</span> * cur2 - prev2 + sign;</span><br><span class="line">        prev = cur2 + prev2;</span><br><span class="line">        <span class="keyword">if</span> (b.charAt(i) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            cur = cur - prev;</span><br><span class="line">            sign = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b.charAt(i) == <span class="string">'1'</span>) &#123;</span><br><span class="line">            prev = cur - prev;</span><br><span class="line">            sign = -<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法总结</title>
    <url>/2020/03/04/45778/</url>
    <content><![CDATA[<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th>排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(n^{1.3})$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td>In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n)$</td>
<td>Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(n\log_2n)$</td>
<td align="center">$O(1)$</td>
<td>In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td>Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n+k)$</td>
<td>Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td>Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p><a href="/2020/02/21/61456/">冒泡排序</a></p>
<p>（无序区，有序区）从无序区通过交换找出最大元素放到有序区前端</p>
</li>
<li><p><a href="/2020/02/21/39445/">选择排序</a></p>
<p>（有序区，无序区）在无序区中找出一个最小的元素跟在有序区后面</p>
</li>
<li><p><a href="/2020/02/21/1609/">插入排序</a></p>
<p>（有序区，无序区）把无序区的第一个元素插入到有序区的合适位置</p>
</li>
<li><p><a href="/2020/02/22/53145/">希尔排序</a></p>
<p>每一轮按照事先决定的间隔进行插入排序，间隔会逐渐缩小至1</p>
</li>
<li><p><a href="/2020/02/22/20366/">快速排序</a></p>
<p>（小数，基准值，大数）在区间中选择一个元素作为基准，把小于基准的元素放在基准之前，大于基准的元素放在基准之后，在分别对小数区和大数区进行排序</p>
</li>
<li><p><a href="/2020/02/24/27532/">归并排序</a></p>
<p>把数据分为两段，从两段中组个选最小的元素移入新数据段的末尾</p>
</li>
<li><p><a href="/2020/03/03/14948/">堆排序</a></p>
<p>（最大堆，有序区）从堆顶把根节点取出来放在有序区之前，再恢复堆</p>
</li>
<li><p><a href="/2020/03/03/4826/">计数排序</a></p>
<p>统计小于等于该元素值的个数 i，该元素就放在目标数组的索引 i 位</p>
</li>
<li><p><a href="/2020/03/03/52110/">桶排序</a></p>
<p>遍历数组把各元素放入对于的桶中，再对桶中个元素进行排序</p>
</li>
<li><p><a href="/2020/03/04/53833/">基数排序</a></p>
<p>低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(10)：基数排序</title>
    <url>/2020/03/04/53833/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>取得数组中的最大数，并取得位数</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/04/53833/radix.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化10个桶</span></span><br><span class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次循环 n*10，当 max/n小于0 时说明已经遍历到了最高位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; max / n &gt; <span class="number">0</span>; n *= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            buckets[(arr[i] / n) % <span class="number">10</span>][i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buckets[j][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    arr[index++] = buckets[j][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(9)：桶排序</title>
    <url>/2020/03/03/52110/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>设定一个定量的数组当作空桶</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶中</li>
<li>对每个不是空的桶进行排序</li>
<li>从不是空的桶里把排好序的数据拼接起来</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/03/52110/bucket.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出数组最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = (value - min) / arr.length;</span><br><span class="line">        bucketArr.get(num).add(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; integers : bucketArr) &#123;</span><br><span class="line">        Collections.sort(integers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把桶中元素取回原数组</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; integers : bucketArr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            arr[index++]=integer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(8)：计数排序</title>
    <url>/2020/03/03/4826/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去1</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/03/4826/counting.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组中最大的值</span></span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 遍历数组arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        count[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, index = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>若原数组值的范围不是从0开始的，计数数组的前面部分空间就会浪费。可以再定义一个变量 min，在给count数组某个下标赋值时把下标减去min</li>
<li>上面的实现中算法是不稳定的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出数组最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数数组，记录每个数组出现的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        count[value - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数每个数字在排序后数组中应该处于的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp = arr.clone();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        arr[--count[temp[i] - min]] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>计数排序是非比较排序，它适用于特定问题，也就是对源数据有要求</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(7)：堆排序</title>
    <url>/2020/03/03/14948/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>堆排序是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区</li>
<li>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1,R2,……Rn-1) 和新的有序区 (Rn)，且满足R[1,2…n-1]&lt;=R[n]</li>
<li>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1,R2,……Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区 (Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/03/03/14948/heap.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后节点的父节点开始把原数组构建为堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次把堆顶元素和最后一个元素交换，再把堆顶heapify</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr, i, <span class="number">0</span>);</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] tree, <span class="keyword">int</span> size, <span class="keyword">int</span> curRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点大于size时退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (curRoot &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前节点的左右字节点索引</span></span><br><span class="line">    <span class="keyword">int</span> l = curRoot * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = curRoot * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> max = curRoot;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; size &amp;&amp; tree[l] &gt; tree[max]) &#123;</span><br><span class="line">        max = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; size &amp;&amp; tree[r] &gt; tree[max]) &#123;</span><br><span class="line">        max = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把当前节点、左右子节点中最大的值与当前节点交换</span></span><br><span class="line">    <span class="keyword">if</span> (max != curRoot) &#123;</span><br><span class="line">        swap(tree, max, curRoot);</span><br><span class="line">        heapify(tree, size, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Bilibili弹幕屏蔽正则</title>
    <url>/2020/02/26/65032/</url>
    <content><![CDATA[<p>自用的b站弹幕屏蔽正则，有效屏蔽一些刷屏、玩烂梗、nt的弹幕</p>
<ol>
<li><p>前排</p>
<p><code>/^\s*[前第]\s*(排|\d+|[二-十]|一$)|关上.+大门/</code></p>
</li>
<li><p>时间</p>
<p><code>/(\d+\D)?\d+\D\d+|年?.+月.+日?|(\d+|[一-十])[十百千万]?(世纪|辈子|年|月|时|小时|分钟|秒)(前|后见)?[^0-9a-zA-Z\u4e00-\u9fa5]*$/</code></p>
</li>
<li><p>+1怪</p>
<p><code>/(\+|加)(\d+|[一-十])[^sS秒]/</code></p>
</li>
<li><p>变色</p>
<p><code>/变.*色|色.*变|(颜|什么.?)色|[戴带].*[冠帽]|[冠帽].*[戴带掉]|帽子|爱.?一.?光|自然.?力量|我.*白色?的?[？?]*$|^(.?[紫基].{2,3}|.?[橘桔].{2,3})$/</code></p>
</li>
<li><p>存活</p>
<p><code>/确\s*认\s*存\s*活|存\s*活\s*确\s*认|^(存活|活着)/</code></p>
</li>
<li><p>完结撒花</p>
<p><code>/[完玩万]\s*[结节結節截美].*[撒散洒杀啥]|[撒散洒杀啥]\s*花[^0-9a-zA-Z\u4e00-\u9fa5]*$|感\s*谢\s*陪\s*伴/</code></p>
</li>
<li><p>虚空对话</p>
<p><code>/([前后上下]面的?|你|[那这]个).*(等|够了|休想|你|我|在下|[跟带加]上)|恶?魔鬼?[吗吧]?[^0-9a-zA-Z\u4e00-\u9fa5]*$/</code></p>
</li>
<li><p>自我意识过剩+饭圈</p>
<p><code>/(我[哒的].?|我.?([男女基]朋?友|老[公婆])|参上|一拜)[^0-9a-zA-Z\u4e00-\u9fa5]*$|是我的|我的[就，\s]|我.*(表示|接受)|归我|承包|[我俺]也?一|先.为敬/</code></p>
</li>
<li><p>nt+烂梗</p>
<ul>
<li><code>/(出现|[上发传转放在到至]).*[在到至]?([bBpP批破比逼哔][iI]?[站占战]|[哔批][里哩]|[bBpP][iI][lL][iI])/</code></li>
<li><code>/(([你女汝][听闻看瞧]|([看听瞧说评])\3|这是).*人|^.?人).*[言话]|[做当作坐座]个人|人.*干.*事/</code></li>
<li><code>/[一亿]人[一亿].|夸父|水娃|我.*喝[一亿]口/</code></li>
<li><code>/典[明眀]粥|[啊阿][帕怕伯泊]基?茶|抽紫烟|神父.*碟|[jJ][iI]?[oO]\s*(等|印|护车)|[bB][oO].*[kK][iI]|上一.+(现在|已经)/</code></li>
<li><code>/[开放停][炮火箭]|[敌友]军|厚葬|秀|意大利[炮跑泡砲面]/</code></li>
<li><code>/[掉上下]线|挂机|回合|重连|续费|登[录陆] |(参与|[介加进]入|[退逃][离出]|离开).{2,4}$|谢.+[刷送]|^.{1,4}([\s\-•·].+)?表示/</code></li>
<li><code>/你币.了/</code></li>
<li><code>/众所周知.*是一/</code></li>
<li><code>/[糟遭曹漕]老头.+坏/</code></li>
<li><code>/馋.*身[子体]|身[子体].*馋/</code></li>
<li><code>/[你宁您].*([看康瞧瞅听学])(\1|着点)/</code></li>
<li><code>/[下上此这].*名单/</code></li>
<li><code>/左.*右.*(大法|手|失)|^(请求)?空降.*[^\d]|[开收停施]工|[oO][pP]|[eE][dD]|正片|(上|前面).*彩蛋/</code></li>
<li><code>/[掉上下]线|挂机|回合|重连|续费|登[录陆]|([一请参作求出助][站战]|参与|[介加进]入|[退逃][离出]|离开|就位).{0,4}$|谢.+[刷送]|^.{1,4}([\s\-•·].+)?表示/</code></li>
<li><code>/[wW].*[dD].*[nN].*[mM].*[dD]|[aA][1iIlLeE]高闪|秋梨膏|我.+了.*什么好说|[rR][uU][sS][hH].*[bB]/</code></li>
<li><code>/(你|君|あなた).*[指手].*[躍跃飛飞舞動动光]/</code></li>
<li><code>/此生.*来世.*/</code></li>
<li><code>/停止.*行为/</code></li>
<li><code>/.*血赚.*不亏/</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(6)：归并排序</title>
    <url>/2020/02/24/27532/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法</strong>的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列</li>
<li>对这两个子序列分别采用归并排序</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/24/27532/merge.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    sort(arr, aux, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sort(arr, aux, left, mid);</span><br><span class="line">    sort(arr, aux, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    merge(arr, aux, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(arr, left, aux, left, right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = left; t &lt;= right; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分的已经全部放到原数组了，将右半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分的已经全部放到原数组了，将左半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt;= aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分取出的元素较小，那么把左半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分取出的元素较小，那么把右半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>和快速排序一样，对于小数组可以使用插入排序或者选择排序，避免递归调用</li>
<li>在merge调用前，可以判断一下<code>arr[mid]</code>是否小于等于<code>arr[mid+1]</code>。如果是的话那么就不用归并了，数组已经是有序的。原因很简单，既然两个子数组已经有序了，那么<code>arr[mid]</code>是第一个子数组的最大值，<code>arr[mid+1]</code>是第二个子数组的最小值。当<code>a[mid]&lt;=a[mid+1]</code>时，数组整体有序</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    sort(arr, aux, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sort(arr, aux, left, mid);</span><br><span class="line">    sort(arr, aux, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 如果左半数组最大的数小于右半数组最小的数，那么说明这两个数组以及有序，不需要合并</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">        merge(arr, aux, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(arr, left, aux, left, right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = left; t &lt;= right; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分的已经全部放到原数组了，将右半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分的已经全部放到原数组了，将左半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt;= aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分取出的元素较小，那么把左半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分取出的元素较小，那么把右半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= left &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h2><p>在上面的实现中，相当于将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。将一个大的数组的排序划分为小数组的排序是自顶向下的排序。还有一种实现是自底向上的排序，即先两两归并，然后四四归并……</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, i, Math.min(i + <span class="number">7</span>, len - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">7</span>; sz &lt; len; sz += sz) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - sz; i += sz + sz) &#123;</span><br><span class="line">            <span class="comment">// 如果左半数组最大的数小于右半数组最小的数，不需要合并</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i + sz - <span class="number">1</span>] &gt; arr[i + sz]) &#123;</span><br><span class="line">                merge(arr, aux, i, i + sz - <span class="number">1</span>, Math.min(i + sz + sz - <span class="number">1</span>, len - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(5)：快速排序</title>
    <url>/2020/02/22/20366/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从数列中挑出一个元素，称为 “基准”</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作</li>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/20366/quick.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组元素等于1 返回</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 选择左端点为基准</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">        <span class="keyword">int</span> pos = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">            <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                swap(arr, pos, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">        swap(arr, left, pos);</span><br><span class="line">        <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">        quickSort(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">    	arr[a] = arr[b];</span><br><span class="line">    	arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速排序最佳情况下时间复杂度为 $O(n\log_2n)$，最坏情况下为 $O(n^2)$，平均复杂度接近最佳情况 $O(n\log_2n)$</p>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化 1"></a>优化 1</h2><p>快排是不断减小问题规模来解决子问题的，需要不断递归。但是递归到规模足够小时，如果继续采用这种 不稳定+递归 的方式执行下去，效率不见得会很好</p>
<p>插入排序的时间复杂度是 $O(n^2)$，但是在已经排序好的数组上面，插入排序的最佳情况是 $O(n)$，插入排序在小数组的排序上是非常高效的，所以在快速排序递归的子序列，如果序列规模足够小，可以使用插入排序替代快速排序，因此可以在快排之前判断数组大小，如果小于一个阈值就使用插入排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort1(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort1(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= left &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-2"><a href="#优化-2" class="headerlink" title="优化 2"></a>优化 2</h2><p>在数组几乎有序时，快排性能不好，因为每趟排序后，左右两个子递归规模相差悬殊，大的那部分时间复杂度最后很可能会达到 $O(n^2)$</p>
<p>解决方法：<strong>三数取中（median-of-three）法</strong>。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中间数位于较为中间的值的可能性就大大提高了。由于整个序列是无序状态，随机选取三个数和从左中右端取三个数其实是一回事，而且随机数生成器本身还会带来时间上的开销，因此随机生成不予考虑。</p>
<p>三数取中法对小数组来说有很大的概率选择到一个比较好的pivot，但是对于大数组来说就不足以保证能够选择出一个好的pivot，因此还有个办法是所谓median-of-nine，这个怎么做呢？它是先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为pivot，也就是median-of-three。取样也不是乱来，分别是在左端点、中点和右端点取样。什么时候采用median-of-nine去选择pivot，这里也有个数组大小的阀值，这个值完全是经验值，设定在40，大小大于40的数组使用median-of-nine选择pivot，大小在7到40之间的数组使用median-of-three选择中数，大小等于7的数组直接选择中数，小于7的数组则直接使用插入排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="comment">// 当数组长度大于40时九数取中</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort2(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort2(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[a] &lt; arr[b]</span><br><span class="line">            ? (arr[b] &lt; arr[c] ? b : arr[a] &lt; arr[c] ? c : a)</span><br><span class="line">            : (arr[b] &gt; arr[c] ? b : arr[a] &gt; arr[c] ? c : a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-3"><a href="#优化-3" class="headerlink" title="优化 3"></a>优化 3</h2><p>目前的算法只使用了一个索引i，i从左向右扫描，遇到比pivot小的，就从pos+1开始的位置进行交换，最终划分点在pos，在递归左右两序列。</p>
<p>更高效的过程是使用i，j两个索引，分别从左右进行扫描，i扫描到大于等于pivot的元素就停止，j扫描到小于等于pivot的元素也停止，交换着两个元素，持续这个过程直至两个索引相遇，这时pivot的位置就落在了j，交换pivot和j的位置，后续的工作和之前一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left + <span class="number">1</span>;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, l++, r--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值交换的合适的位置</span></span><br><span class="line">    swap(arr,left, r);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-4"><a href="#优化-4" class="headerlink" title="优化 4"></a>优化 4</h2><p>减少不必要的交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort4</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; l &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[l++] = arr[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[r--] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时 i==j，将 pivot 填到这个坑中</span></span><br><span class="line">    arr[l] = pivot;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort3(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort3(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-5"><a href="#优化-5" class="headerlink" title="优化 5"></a>优化 5</h2><p>当大量数据，且重复数多时，用三路快排</p>
<p>把数组分为三路，第一路都比pivot小，第二路都等于pivot，第三路都大于pivot</p>
<p>用指针从前到后扫描，如果：</p>
<ol>
<li>cur指向的数小于pivot，那么：交换arr[cur]和arr[i]的值，然后i++,cur++</li>
<li>cur指向的数等于pivot,  那么：cur++</li>
<li>cur指向的数大于pivot，那么：交换arr[cur]和arr[j]的值，然后j–</li>
</ol>
<p>当cur &gt; j的时候说明三路都已经完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort5</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> cur = left+<span class="number">1</span>;</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; pivot)&#123;</span><br><span class="line">            swap(arr,cur++,l++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; pivot)&#123;</span><br><span class="line">            swap(arr, cur, r--);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, r + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(4)：希尔排序</title>
    <url>/2020/02/22/53145/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>希尔排序是第一个突破 $O(n^2)$ 的算法，它是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>希尔排序在排序前根据一个增量值将一个序列分成了好几个序列</li>
<li>对这几个序列做插入排序。排序后，部分较大的数字往后靠，部分较小的数字往前靠</li>
<li>减小增量值从而减少序列的数量，继续对这些序列做插入排序</li>
<li>当序列只剩一个时，这时即可得到排好序的结果</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/53145/shell.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length / <span class="number">2</span>; step &gt; <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curIndex = i;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (curIndex - step &gt;= <span class="number">0</span> &amp;&amp; arr[curIndex - step] &gt; current) &#123;</span><br><span class="line">                arr[curIndex] = arr[curIndex - step];</span><br><span class="line">                curIndex -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[curIndex] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(3)：插入排序</title>
    <url>/2020/02/21/1609/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>插入排序是一种简单直观的排序算法。它通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/1609/insertion.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>插入排序在实现上，通常采用in-place排序（即只需用到 $O(1)$ 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(2)：选择排序</title>
    <url>/2020/02/21/39445/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>选择排序是一种简单直观的排序算法。它的工作原理是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>从第i个(i=1,2,3…n-1)元素开始，从 i~n 的元素中，选出最小的数，将它与第i个元素交换</li>
<li>重复步骤1，直到排序完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/39445/selection.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>选择排序是表现最稳定的排序算法之一，因为无论什么数据进去都是 $O(n^2)$ 的时间复杂度，所以用到它的时候，数据规模越小越好</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(1)：冒泡排序</title>
    <url>/2020/02/21/61456/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，依次比较两个元素，如果发现逆序则交换，使得值较大的元素逐渐从前移向后部，就像水底的气泡逐渐向上冒</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>重复步骤1~3，直到排序完成</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/61456/bubble.gif" class="">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>在第二层循环中设置一个flag判断元素是否交换过，如果一趟比较下来没有元素交换，就说明排序已完成，没有必要继续下面的比较</li>
<li>在每次扫描中，记录最后一次发生交换的位置pos，此时[0, pos-1]是无序区，[pos, n-1]是有序区，这样下一次扫描只需要扫描到pos就行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                pos = j；</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        k = pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <url>/2020/02/20/28b1/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><strong>中缀表达式</strong>：我们平时写的数学表达式一般为中缀表达式，如 <code>1+2*(3*(4-5*6+7))</code>，中缀表达式的特点是：二元运算符总是在两个运算对象之间。人读起来比较好理解，但是计算机处理起来就很麻烦，运算顺序往往因表达式的内容而定，不具规律性</li>
<li><strong>后缀表达式</strong>：又称为<strong>逆波兰表达式</strong>。后缀表达式的特点是：每个运算符都置于其运算对象之后。如上面的中缀表达式转化为后缀表达式为 <code>523312*-1+**+</code></li>
</ul>
<h2 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h2><ol>
<li>初始化一个栈来存放运算符</li>
<li>从左至右依次读取中缀表达式的字符</li>
<li>当读取到数字时，立即放到输出中</li>
<li>当遇到运算符时，比较其与栈顶运算符的优先级<ol>
<li>如果栈为空或栈顶运算符为 ( ，则直接将此运算符入栈</li>
<li>比栈顶高，也将运算符入栈</li>
<li>比栈顶低或相同，将栈顶运算符弹出并输出，再与新的栈顶运算符比较</li>
</ol>
</li>
<li>当遇到括号<ol>
<li>左括号，运算符入栈</li>
<li>右括号，依次弹出栈顶运算符并输出，直到遇到左括号为止，此时舍弃这对括号</li>
</ol>
</li>
<li>重复至表达式最右边，然后将栈中运算符输出</li>
</ol>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>输入 <code>1+2*(3*(4-5*6+7))</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>栈</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>读取 1</td>
<td>把操作数直接输出</td>
<td></td>
<td><code>1</code></td>
</tr>
<tr>
<td>读取 +</td>
<td>栈为空，把运算符压入栈</td>
<td><code>+</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td>读取 2</td>
<td>把操作数直接输出</td>
<td><code>+</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 +，优先级低于 *，把运算符压入栈</td>
<td><code>+*</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 (</td>
<td>把 ( 直接压入栈</td>
<td><code>+*(</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td>读取 3</td>
<td>把操作数直接输出</td>
<td><code>+*(</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 (，把运算符压入栈</td>
<td><code>+*(*</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 (</td>
<td>把 ( 直接压入栈</td>
<td><code>+*(*(</code></td>
<td><code>123</code></td>
</tr>
<tr>
<td>读取 4</td>
<td>把操作数直接输出</td>
<td><code>+*(*(</code></td>
<td><code>1234</code></td>
</tr>
<tr>
<td>读取 -</td>
<td>栈顶为 (，把运算符压入栈</td>
<td><code>+*(*(-</code></td>
<td><code>1234</code></td>
</tr>
<tr>
<td>读取 5</td>
<td>把操作数直接输出</td>
<td><code>+*(*(-</code></td>
<td><code>12345</code></td>
</tr>
<tr>
<td>读取 *</td>
<td>栈顶为 -，优先级低于 *，把运算符压入栈</td>
<td><code>+*(*(-*</code></td>
<td><code>12345</code></td>
</tr>
<tr>
<td>读取 6</td>
<td>把操作数直接输出</td>
<td><code>+*(*(-*</code></td>
<td><code>123456</code></td>
</tr>
<tr>
<td>读取 +</td>
<td>栈顶为 *，优先级高于 +，依次弹出栈中运算符 到输出，到 ( 停止，把运算符压入栈中</td>
<td><code>+*(*(+</code></td>
<td><code>123456*-</code></td>
</tr>
<tr>
<td>读取 7</td>
<td>把操作数直接输出</td>
<td><code>+*(*(+</code></td>
<td><code>123456*-7</code></td>
</tr>
<tr>
<td>读取 )</td>
<td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td>
<td><code>+*(*</code></td>
<td><code>123456*-7+</code></td>
</tr>
<tr>
<td>读取 )</td>
<td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td>
<td><code>+*</code></td>
<td><code>123456*-7+*</code></td>
</tr>
<tr>
<td>结束读取</td>
<td>把栈中的元素全部弹出到输出</td>
<td></td>
<td><code>123456*-7+**+</code></td>
</tr>
</tbody></table>
<p>输出后缀表达式为：<code>123456*-7+**+</code></p>
<h2 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h2><ol>
<li>按次序读取表达式的每一个字符</li>
<li>读到操作数时，把操作数压入栈</li>
<li>读到操作符时，弹出栈顶的两个数做相应运算，把结果压入栈</li>
<li>读取完所有表达式的字符后，弹出栈，结果即为所求的值</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huben.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> koishi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndixToSuffix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入表达式:"</span>);</span><br><span class="line">        String str = in.next();</span><br><span class="line">        System.out.println(<span class="string">"你输入的表达式为: "</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"转化为后缀表达式为："</span> + transfer(str));</span><br><span class="line">        System.out.println(<span class="string">"计算结果为:"</span> + calculate(transfer(str)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把中缀表达式转换为后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 中缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后缀表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transfer</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; (stack.peek() == <span class="string">'*'</span> || stack.peek() == <span class="string">'/'</span>)) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Float&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                stack.push((<span class="keyword">float</span>) (c - <span class="string">'0'</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(cal(c, stack.pop(), stack.pop()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Float <span class="title">cal</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b + a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b * a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b / a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果截图</p>
<img src="/2020/02/20/28b1/result.png" class="">

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
