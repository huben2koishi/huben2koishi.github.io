<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>十大经典排序算法(6)：归并排序</title>
    <url>/2020/02/24/classic-algorithms-merge-sort/</url>
    <content><![CDATA[<!-- build time:Tue Feb 25 2020 19:13:12 GMT+0800 (GMT+08:00) --><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法</strong>的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列</li><li>对这两个子序列分别采用归并排序</li><li>将两个排序好的子序列合并成一个最终的排序序列</li></ol><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/24/classic-algorithms-merge-sort/merge.gif"><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    sort(arr, aux, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sort(arr, aux, left, mid);</span><br><span class="line">    sort(arr, aux, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    merge(arr, aux, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(arr, left, aux, left, right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = left; t &lt;= right; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分的已经全部放到原数组了，将右半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分的已经全部放到原数组了，将左半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt;= aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分取出的元素较小，那么把左半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分取出的元素较小，那么把右半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol><li>和快速排序一样，对于小数组可以使用插入排序或者选择排序，避免递归调用</li><li>在merge调用前，可以判断一下<code>arr[mid]</code>是否小于等于<code>arr[mid+1]</code>。如果是的话那么就不用归并了，数组已经是有序的。原因很简单，既然两个子数组已经有序了，那么<code>arr[mid]</code>是第一个子数组的最大值，<code>arr[mid+1]</code>是第二个子数组的最小值。当<code>a[mid]&lt;=a[mid+1]</code>时，数组整体有序</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    sort(arr, aux, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sort(arr, aux, left, mid);</span><br><span class="line">    sort(arr, aux, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 如果左半数组最大的数小于右半数组最小的数，那么说明这两个数组以及有序，不需要合并</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">        merge(arr, aux, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(arr, left, aux, left, right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = left; t &lt;= right; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分的已经全部放到原数组了，将右半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分的已经全部放到原数组了，将左半部分数组全部依次放入原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt;= aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果左半部分取出的元素较小，那么把左半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果右半部分取出的元素较小，那么把右半部分索引取出的元素放到原数组</span></span><br><span class="line">            arr[t] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= left &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h2><p>在上面的实现中，相当于将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。将一个大的数组的排序划分为小数组的排序是自顶向下的排序。还有一种实现是自底向上的排序，即先两两归并，然后四四归并……</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, i, Math.min(i + <span class="number">7</span>, len - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">7</span>; sz &lt; len; sz += sz) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - sz; i += sz + sz) &#123;</span><br><span class="line">            <span class="comment">// 如果左半数组最大的数小于右半数组最小的数，不需要合并</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i + sz - <span class="number">1</span>] &gt; arr[i + sz]) &#123;</span><br><span class="line">                merge(arr, aux, i, i + sz - <span class="number">1</span>, Math.min(i + sz + sz - <span class="number">1</span>, len - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(5)：快速排序</title>
    <url>/2020/02/22/classic-algorithms-quick-sort/</url>
    <content><![CDATA[<!-- build time:Tue Feb 25 2020 19:13:12 GMT+0800 (GMT+08:00) --><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>从数列中挑出一个元素，称为 “基准”</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作；</li><li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/classic-algorithms-quick-sort/quick.gif"><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组元素等于1 返回</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 选择左端点为基准</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">        <span class="keyword">int</span> pos = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">            <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                swap(arr, pos, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">        swap(arr, left, pos);</span><br><span class="line">        <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">        quickSort(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">    	arr[a] = arr[b];</span><br><span class="line">    	arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序最佳情况下时间复杂度为 $O(n\log_2n)$，最坏情况下为 $O(n^2)$，平均复杂度接近最佳情况 $O(n\log_2n)$</p><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化 1"></a>优化 1</h2><p>快排是不断减小问题规模来解决子问题的，需要不断递归。但是递归到规模足够小时，如果继续采用这种 不稳定+递归 的方式执行下去，效率不见得会很好</p><p>插入排序的时间复杂度是 $O(n^2)$，但是在已经排序好的数组上面，插入排序的最佳情况是 $O(n)$，插入排序在小数组的排序上是非常高效的，所以在快速排序递归的子序列，如果序列规模足够小，可以使用插入排序替代快速排序，因此可以在快排之前判断数组大小，如果小于一个阈值就使用插入排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort1(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort1(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= left &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化-2"><a href="#优化-2" class="headerlink" title="优化 2"></a>优化 2</h2><p>在数组几乎有序时，快排性能不好，因为每趟排序后，左右两个子递归规模相差悬殊，大的那部分时间复杂度最后很可能会达到 $O(n^2)$</p><p>解决方法：<strong>三数取中（median-of-three）法</strong>。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数，从概率来说，取三个数均为最小或最大数的可能性是微乎其微的，因此中间数位于较为中间的值的可能性就大大提高了。由于整个序列是无序状态，随机选取三个数和从左中右端取三个数其实是一回事，而且随机数生成器本身还会带来时间上的开销，因此随机生成不予考虑。</p><p>三数取中法对小数组来说有很大的概率选择到一个比较好的pivot，但是对于大数组来说就不足以保证能够选择出一个好的pivot，因此还有个办法是所谓median-of-nine，这个怎么做呢？它是先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为pivot，也就是median-of-three。取样也不是乱来，分别是在左端点、中点和右端点取样。什么时候采用median-of-nine去选择pivot，这里也有个数组大小的阀值，这个值完全是经验值，设定在40，大小大于40的数组使用median-of-nine选择pivot，大小在7到40之间的数组使用median-of-three选择中数，大小等于7的数组直接选择中数，小于7的数组则直接使用插入排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="comment">// 当数组长度大于40时九数取中</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pos = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="comment">// 小于基准的数移到左边</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            swap(arr, pos, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左端点和基准值的位置</span></span><br><span class="line">    swap(arr, left, pos);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort2(arr, left, pos - <span class="number">1</span>);</span><br><span class="line">    quickSort2(arr, pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mid</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[a] &lt; arr[b]</span><br><span class="line">            ? (arr[b] &lt; arr[c] ? b : arr[a] &lt; arr[c] ? c : a)</span><br><span class="line">            : (arr[b] &gt; arr[c] ? b : arr[a] &gt; arr[c] ? c : a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化-3"><a href="#优化-3" class="headerlink" title="优化 3"></a>优化 3</h2><p>目前的算法只使用了一个索引i，i从左向右扫描，遇到比pivot小的，就从pos+1开始的位置进行交换，最终划分点在pos，在递归左右两序列。</p><p>更高效的过程是使用i，j两个索引，分别从左右进行扫描，i扫描到大于等于pivot的元素就停止，j扫描到小于等于pivot的元素也停止，交换着两个元素，持续这个过程直至两个索引相遇，这时pivot的位置就落在了j，交换pivot和j的位置，后续的工作和之前一样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left + <span class="number">1</span>;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, l++, r--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值交换的合适的位置</span></span><br><span class="line">    swap(arr,left, r);</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化-4"><a href="#优化-4" class="headerlink" title="优化 4"></a>优化 4</h2><p>减少不必要的交换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort4</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//从右到左扫描，扫描出第一个比pivot小的元素，然后j停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; l &amp;&amp; arr[r] &gt; pivot) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[l++] = arr[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左到右扫描，扫描出第一个比pivot大的元素，然后i停在那里。</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; pivot) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[r--] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时 i==j，将 pivot 填到这个坑中</span></span><br><span class="line">    arr[l] = pivot;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort3(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort3(arr, l + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化-5"><a href="#优化-5" class="headerlink" title="优化 5"></a>优化 5</h2><p>当大量数据，且重复数多时，用三路快排</p><p>把数组分为三路，第一路都比pivot小，第二路都等于pivot，第三路都大于pivot</p><p>用指针从前到后扫描，如果：</p><ol><li>cur指向的数小于pivot，那么：交换arr[cur]和arr[i]的值，然后i++,cur++</li><li>cur指向的数等于pivot, 那么：cur++</li><li>cur指向的数大于pivot，那么：交换arr[cur]和arr[j]的值，然后j–</li></ol><p>当cur &gt; j的时候说明三路都已经完成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort5</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当数组长度小于7时使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        insertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数组长度大于7时三数取中</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> m = left + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = len / <span class="number">8</span>;</span><br><span class="line">        l = mid(arr, l, l + s, l + <span class="number">2</span> * s);</span><br><span class="line">        m = mid(arr, m - s, m, m - <span class="number">2</span> * s);</span><br><span class="line">        r = mid(arr, r - <span class="number">2</span> * s, r - s, r);</span><br><span class="line">    &#125;</span><br><span class="line">    m = mid(arr, l, m, r);</span><br><span class="line">    swap(arr, left, m);</span><br><span class="line">    <span class="comment">// 选择左端点为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> cur = left+<span class="number">1</span>;</span><br><span class="line">    l = left;</span><br><span class="line">    r = right;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; pivot)&#123;</span><br><span class="line">            swap(arr,cur++,l++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; pivot)&#123;</span><br><span class="line">            swap(arr, cur, r--);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左右两个子序列</span></span><br><span class="line">    quickSort4(arr, left, l - <span class="number">1</span>);</span><br><span class="line">    quickSort4(arr, r + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(4)：希尔排序</title>
    <url>/2020/02/22/classic-algorithms-shell-sort/</url>
    <content><![CDATA[<!-- build time:Tue Feb 25 2020 19:13:12 GMT+0800 (GMT+08:00) --><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>希尔排序是第一个突破 $O(n^2)$ 的算法，它是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>希尔排序在排序前根据一个增量值将一个序列分成了好几个序列</li><li>对这几个序列做插入排序。排序后，部分较大的数字往后靠，部分较小的数字往前靠</li><li>减小增量值从而减少序列的数量，继续对这些序列做插入排序</li><li>当序列只剩一个时，这时即可得到排好序的结果</li></ol><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/22/classic-algorithms-shell-sort/shell.gif"><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length / <span class="number">2</span>; step &gt; <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curIndex = i;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (curIndex - step &gt;= <span class="number">0</span> &amp;&amp; arr[curIndex - step] &gt; current) &#123;</span><br><span class="line">                arr[curIndex] = arr[curIndex - step];</span><br><span class="line">                curIndex -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[curIndex] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(3)：插入排序</title>
    <url>/2020/02/21/classic-algorithms-insertion-sort/</url>
    <content><![CDATA[<!-- build time:Tue Feb 25 2020 19:13:12 GMT+0800 (GMT+08:00) --><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>插入排序是一种简单直观的排序算法。它通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/classic-algorithms-insertion-sort/insertion.gif"><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(2)：选择排序</title>
    <url>/2020/02/21/classic-algorithms-selection-sort/</url>
    <content><![CDATA[<!-- build time:Tue Feb 25 2020 19:13:12 GMT+0800 (GMT+08:00) --><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>选择排序是一种简单直观的排序算法。它的工作原理是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>从第i个(i=1,2,3…n-1)元素开始，从 i~n 的元素中，选出最小的数，将它与第i个元素交换</li><li>重复步骤1，直到排序完成</li></ol><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/classic-algorithms-selection-sort/selection.gif"><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>选择排序是表现最稳定的排序算法之一，因为无论什么数据进去都是 $O(n^2)$ 的时间复杂度，所以用到它的时候，数据规模越小越好</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法(1)：冒泡排序</title>
    <url>/2020/02/21/classic-algorithms-bubble-sort/</url>
    <content><![CDATA[<!-- build time:Tue Feb 25 2020 19:13:12 GMT+0800 (GMT+08:00) --><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，依次比较两个元素，如果发现逆序则交换，使得值较大的元素逐渐从前移向后部，就像水底的气泡逐渐向上冒</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>重复步骤1~3，直到排序完成</li></ol><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="/2020/02/21/classic-algorithms-bubble-sort/bubble.gif"><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol><li>在第二层循环中设置一个flag判断元素是否交换过，如果一趟比较下来没有元素交换，就说明排序已完成，没有必要继续下面的比较</li><li>在每次扫描中，记录最后一次发生交换的位置pos，此时[0, pos-1]是无序区，[pos, n-1]是有序区，这样下一次扫描只需要扫描到pos就行</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                pos = j；</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        k = pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <url>/2020/02/20/infix-to-suffix/</url>
    <content><![CDATA[<!-- build time:Tue Feb 25 2020 19:13:12 GMT+0800 (GMT+08:00) --><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><strong>中缀表达式</strong>：我们平时写的数学表达式一般为中缀表达式，如 <code>1+2*(3*(4-5*6+7))</code>，中缀表达式的特点是：二元运算符总是在两个运算对象之间。人读起来比较好理解，但是计算机处理起来就很麻烦，运算顺序往往因表达式的内容而定，不具规律性</li><li><strong>后缀表达式</strong>：又称为<strong>逆波兰表达式</strong>。后缀表达式的特点是：每个运算符都置于其运算对象之后。如上面的中缀表达式转化为后缀表达式为 <code>523312*-1+**+</code>。</li></ul><h2 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h2><ol><li>初始化一个栈来存放运算符</li><li>从左至右依次读取中缀表达式的字符</li><li>当读取到数字时，立即放到输出中</li><li>当遇到运算符时，比较其与栈顶运算符的优先级<ol><li>如果栈为空或栈顶运算符为 ( ，则直接将此运算符入栈</li><li>比栈顶高，也将运算符入栈</li><li>比栈顶低或相同，将栈顶运算符弹出并输出，再与新的栈顶运算符比较</li></ol></li><li>当遇到括号<ol><li>左括号，运算符入栈</li><li>右括号，依次弹出栈顶运算符并输出，直到遇到左括号为止，此时舍弃这对括号</li></ol></li><li>重复至表达式最右边，然后将栈中运算符输出</li></ol><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>输入 <code>1+2*(3*(4-5*6+7))</code></p><table><thead><tr><th>操作</th><th>说明</th><th>栈</th><th>输出</th></tr></thead><tbody><tr><td>读取 1</td><td>把操作数直接输出</td><td></td><td><code>1</code></td></tr><tr><td>读取 +</td><td>栈为空，把运算符压入栈</td><td><code>+</code></td><td><code>1</code></td></tr><tr><td>读取 2</td><td>把操作数直接输出</td><td><code>+</code></td><td><code>12</code></td></tr><tr><td>读取 *</td><td>栈顶为 +，优先级低于 *，把运算符压入栈</td><td><code>+*</code></td><td><code>12</code></td></tr><tr><td>读取 (</td><td>把 ( 直接压入栈</td><td><code>+*(</code></td><td><code>12</code></td></tr><tr><td>读取 3</td><td>把操作数直接输出</td><td><code>+*(</code></td><td><code>123</code></td></tr><tr><td>读取 *</td><td>栈顶为 (，把运算符压入栈</td><td><code>+*(*</code></td><td><code>123</code></td></tr><tr><td>读取 (</td><td>把 ( 直接压入栈</td><td><code>+*(*(</code></td><td><code>123</code></td></tr><tr><td>读取 4</td><td>把操作数直接输出</td><td><code>+*(*(</code></td><td><code>1234</code></td></tr><tr><td>读取 -</td><td>栈顶为 (，把运算符压入栈</td><td><code>+*(*(-</code></td><td><code>1234</code></td></tr><tr><td>读取 5</td><td>把操作数直接输出</td><td><code>+*(*(-</code></td><td><code>12345</code></td></tr><tr><td>读取 *</td><td>栈顶为 -，优先级低于 *，把运算符压入栈</td><td><code>+*(*(-*</code></td><td><code>12345</code></td></tr><tr><td>读取 6</td><td>把操作数直接输出</td><td><code>+*(*(-*</code></td><td><code>123456</code></td></tr><tr><td>读取 +</td><td>栈顶为 *，优先级高于 +，依次弹出栈中运算符 到输出，到 ( 停止，把运算符压入栈中</td><td><code>+*(*(+</code></td><td><code>123456*-</code></td></tr><tr><td>读取 7</td><td>把操作数直接输出</td><td><code>+*(*(+</code></td><td><code>123456*-7</code></td></tr><tr><td>读取 )</td><td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td><td><code>+*(*</code></td><td><code>123456*-7+</code></td></tr><tr><td>读取 )</td><td>依次弹出栈顶运算符并输出，直到遇到 (，把 ( 弹出</td><td><code>+*</code></td><td><code>123456*-7+*</code></td></tr><tr><td>结束读取</td><td>把栈中的元素全部弹出到输出</td><td></td><td><code>123456*-7+**+</code></td></tr></tbody></table><p>输出后缀表达式为：<code>123456*-7+**+</code></p><h2 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h2><ol><li>按次序读取表达式的每一个字符</li><li>读到操作数时，把操作数压入栈</li><li>读到操作符时，弹出栈顶的两个数做相应运算，把结果压入栈</li><li>读取完所有表达式的字符后，弹出栈，结果即为所求的值</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huben.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> koishi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndixToSuffix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入表达式:"</span>);</span><br><span class="line">        String str = in.next();</span><br><span class="line">        System.out.println(<span class="string">"你输入的表达式为: "</span> + str);</span><br><span class="line">        System.out.println(<span class="string">"转化为后缀表达式为："</span> + transfer(str));</span><br><span class="line">        System.out.println(<span class="string">"计算结果为:"</span> + calculate(transfer(str)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把中缀表达式转换为后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 中缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后缀表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transfer</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; (stack.peek() == <span class="string">'*'</span> || stack.peek() == <span class="string">'/'</span>)) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 后缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Float&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                stack.push((<span class="keyword">float</span>) (c - <span class="string">'0'</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(cal(c, stack.pop(), stack.pop()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Float <span class="title">cal</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b + a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b * a;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b / a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果截图</p><img src="/2020/02/20/infix-to-suffix/result.png"><!-- rebuild by neat -->]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
